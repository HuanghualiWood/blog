<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="/blog/atom.xml" rel="self"/>
  
  <link href="https://github.com/HuanghualiWood/blog/"/>
  <updated>2020-06-09T16:00:00.000Z</updated>
  <id>https://github.com/HuanghualiWood/blog/</id>
  
  <author>
    <name>minhao</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>线性表习题</title>
    <link href="https://github.com/HuanghualiWood/blog/2020/06/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%A0%E9%A2%98/"/>
    <id>https://github.com/HuanghualiWood/blog/2020/06/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%A0%E9%A2%98/</id>
    <published>2020-06-09T16:00:00.000Z</published>
    <updated>2020-06-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>/<strong><strong>****</strong></strong><br>线性表习题<br><strong><strong>****</strong></strong>/</p><p>/<em>2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素</em>/<br>/<em>2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）</em>/<br>/<em>2-2-8 将数组中两个顺序表的位置置换</em>/<br>/<em>2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点</em>/<br>/<em>2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间</em>/<br>/<em>2-3-3 L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值</em>/<br>/<em>2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）</em>/<br>/<em>2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)</em>/<br>/<em>2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序</em>/</p><p>#include <iostream><br>#include <string><br>#include<cstdio><br>#define Elemtype int</p><p>//顺序存储结构<br>typedef struct {<br>    Elemtype data[50] = { 4, 3, 3, 4, 2, 4, 5, 6, 6, 6 };<br>    Elemtype length;<br>}Sqlist;<br>Sqlist L;<br>//链式存储结构<br>typedef struct LNode {<br>    Elemtype data;<br>    struct LNode* next;<br>}LNode,*Linklist;</p><p>/<em>————<br>建立链表，注意双指针以及辅助指针的使用<br>————-</em>/<br>//指针的引用<br>void Linklist_init(Linklist &amp;L) {<br>    L = (Linklist)malloc(sizeof(LNode));<br>    LNode* tmp, * r = L;//必须要一个辅助指针<em>r<br>    L-&gt;data = -1;<br>    L-&gt;next = NULL;<br>    for (int i = 0; i &lt; 10; i++) {<br>        tmp = (LNode</em>)malloc(sizeof(LNode));<br>        if (tmp != NULL) {<br>            tmp-&gt;data = i ;<br>            r-&gt;next = tmp;<br>            r = tmp;<br>        }<br>    }<br>    r-&gt;next = NULL;<br>}<br>//二级指针，传入实参地址<br>void Linklist_init2(LNode <em>* L) {<br>    *L = (LNode</em>)malloc(sizeof(LNode));<br>    LNode* tmp, * r = <em>L;<br>    r-&gt;data = -1;<br>    r-&gt;next = NULL;<br>    for (int i = 0; i &lt; 20; i++) {<br>        tmp = (LNode</em>)malloc(sizeof(LNode));<br>        if (tmp != NULL) {<br>            tmp-&gt;data = i % 5;<br>            r-&gt;next = tmp;<br>            r = tmp;<br>        }<br>    }<br>    r-&gt;next = NULL;<br>}<br>//return返回<br>Linklist Linklist_init3(void) {<br>    Linklist L = (Linklist)malloc(sizeof(LNode));<br>    LNode* tmp, * r = L;<br>    r-&gt;data = -1;<br>    r-&gt;next = NULL;<br>    for (int i = 0; i &lt; 10; i++) {<br>        tmp = (LNode<em>)malloc(sizeof(LNode));<br>        if (tmp != NULL) {<br>            tmp-&gt;data = i % 6;<br>            r-&gt;next = tmp;<br>            r = tmp;<br>        }<br>    }<br>    r-&gt;next = NULL;<br>    return L;<br>}<br>//————————<br>/*2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素</em>/<br>void delet_x(Sqlist &amp;L, int value) {<br>    int i=0, k=0, j=0;<br>    int length = L.length;<br>    j = 0;<br>    while (i&lt;L.length) {<br>        if (k != 0) {<br>            L.data[i-k] = L.data[i];<br>        }<br>        if (L.data[i] == value) {<br>            k++;<br>            length–;<br>        }<br>        i++;<br>    }<br>    for (i = length; i &lt; L.length; i++)<br>        L.data[i] = 0;<br>    L.length = length;<br>}<br>/<em>2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）</em>/<br>//理解错误，做成了，删除线性表范围在s和t之间的值为x的元素<br>bool delte_x_at(Sqlist &amp;L, int s, int t, int value) {<br>    if (s &gt;= t)return false;<br>    if (L.length &lt;= 0)return false;<br>    int i=0, j=0,k=0;<br>    for (i = s+1; i &lt; t; i++) {<br>        if (L.data[i] != value) {<br>            L.data[k+s+1] = L.data[i];<br>            k++;<br>        }<br>    }<br>    j = t - s - 1 - k;<br>    for (i = t; i &lt; L.length; i++)<br>        L.data[i - j] = L.data[i];<br>    for (i =0; i &lt;j; i++)<br>        L.data[L.length - 1 - i] = 0;<br>    L.length = L.length - (t - s - 1) + k;<br>    return true;<br>}<br>/<em>2-2-8 将数组中两个顺序表的位置置换</em>/</p><h1 id="逆置算法"><a href="#逆置算法" class="headerlink" title="逆置算法"></a>逆置算法</h1><p>int arr[10] = { 1,2,3,4,5,6,1,2,3,4 };<br>bool reverse(int arr[], int left, int right) {<br>    if (left &gt; right)return false;<br>    int mid = (left+right) / 2;<br>    for (int i = 0; i &lt;= mid - left; i++) {<br>        int tmp = arr[i+left];<br>        arr[i + left] = arr[right - i];<br>        arr[right - i] = tmp;<br>    }<br>    return true;<br>}<br>bool Sqlist_rev(int arr[],int m, int n) {<br>    reverse(arr, 0, m + n - 1);<br>    reverse(arr,0, n - 1);<br>    reverse(arr, n, m+n - 1);<br>    return true;<br>}</p><p>/<em>2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点</em>/<br>bool Linklist_delele(Linklist&amp; L, int x) {<br>    if (!L)return false;<br>    if (L-&gt;data == x) {<br>        LNode <em>q = L;<br>        L = L-&gt;next;<br>        free(q);<br>        Linklist_delele(L, x);<br>    }<br>    Linklist_delele(L-&gt;next, x);<br>    return true;<br>}<br>/*2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间</em>/<br>//——————————————————<br>void Linklist_del(Linklist &amp;L, Elemtype x) {<br>    LNode *q, *p = L-&gt;next,  *pre = L;<br>    while (p) {<br>        if (p-&gt;data == x) {<br>            q = p;<br>            p = p-&gt;next;//p还要往前移一个，和L的位置重合<br>            pre-&gt;next = p;<br>            free(q);<br>            printf(“. “);<br>        }<br>        else {<br>            pre = p;<br>            p = p-&gt;next;<br>        }<br>    }<br>}<br>//删除也可以传入一级指针,无需指针的引用<br>void Linklist_del2(Linklist L, Elemtype x) {//L此时为形参，函数内生成L头结点的副本，不过指向的内容仍然<br>    Linklist q,  p = L-&gt;next,  pre = L;     //是L。可以实现对L的删除。<br>    while (p) {<br>        if (p-&gt;data == x) {<br>            q = p;<br>            p = p-&gt;next;<br>            L-&gt;next = p;<br>            free(q);<br>            printf(“. “);<br>        }<br>        else {<br>            pre = p;<br>            p = p-&gt;next;<br>        }<br>    }<br>}</p><h1 id="尾插法，删除特定值"><a href="#尾插法，删除特定值" class="headerlink" title="尾插法，删除特定值"></a>尾插法，删除特定值</h1><p>void Linklist_del3(Linklist &amp;L, Elemtype x) {<br>    Linklist q, p = L-&gt;next, r = L;<br>    while (p) {<br>        if (p-&gt;data != x) {<br>            r-&gt;next=p;<br>            r = p;<br>            p= p-&gt;next;<br>        }<br>        else {<br>            q = p;<br>            p = p-&gt;next;<br>            free(q);<br>            printf(“. “);<br>        }<br>    }<br>    r-&gt;next = NULL;<br>}</p><p>/<em>2-3-3L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值</em>/<br>void Linklist_reverse(Linklist L) {<br>    if(L-&gt;next)<br>      Linklist_reverse(L-&gt;next);<br>    printf(“%d “, L-&gt;data);<br>}<br>/<em>2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）</em>/<br>void dellmin4(Linklist &amp;L) {<br>    LNode* pre = L, * p = L-&gt;next;<br>    LNode* tmp=p,<em>tmppre=pre ;<br>    while (p != NULL) {<br>        if (tmp-&gt;data &gt; p-&gt;data) {<br>            tmp = p;<br>            tmppre = pre;<br>        }<br>        pre = p;<br>        p = p-&gt;next;<br>    }<br>    tmppre-&gt;next = tmp-&gt;next;<br>    free(tmp);<br>}<br>/*2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)</em>/<br>//xxxxx<br>void Linklist_reverse2(Linklist &amp;L) {<br>    LNode *pre = NULL, *p = L-&gt;next, * tmp = L;<br>    while (p != NULL) {<br>        tmp = p-&gt;next;<br>        p-&gt;next = pre;<br>        pre = p;<br>        p = tmp;<br>    }<br>    L-&gt;next=pre;<br>}</p><h1 id="2头插法，精妙！"><a href="#2头插法，精妙！" class="headerlink" title="2头插法，精妙！"></a>2头插法，精妙！</h1><p>void Linklist_reverse2_2(Linklist&amp; L) {<br>    LNode * first = L, * p = L-&gt;next, * tmp = L;<br>    while (p != NULL) {<br>        tmp = p-&gt;next;<br>        first = L-&gt;next;<br>        L-&gt;next = p;<br>        p-&gt;next = first;<br>        first-&gt;next = tmp;<br>    }</p><p>}<br>/<em>2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序</em>/<br>//不应该使用选择排序，选择最小结点操作很麻烦<br>void Linklist_increaseorder(Linklist &amp;L) {<br>    LNode * p = L-&gt;next,*prep=L;<br>    LNode * q = NULL, * preq = L;<br>    LNode * min = p, * premin = p;<br>    while (p != NULL) {<br>        premin = min = p;<br>        preq = premin;<br>        q = p;<br>        printf(“p:%d “, p-&gt;data);<br>        while (q != NULL) {<br>            printf(“ q:%d  “, q-&gt;data);<br>            if (q-&gt;data &lt; min-&gt;data) {<br>                premin = preq;<br>                min = q;<br>                printf(“%d”, min-&gt;data);<br>            }<br>            preq = q;<br>            q = q-&gt;next;<br>        }<br>        if (min-&gt;next != NULL)<br>            premin-&gt;next = min-&gt;next;<br>        else premin-&gt;next = NULL;//少了这一句链表编程循环队列-_-,死循环！！！！<br>        if (min == p) {<br>            printf(“no min \n “);<br>            prep = p;<br>            p = p-&gt;next;<br>        }<br>        else<br>        {<br>            prep-&gt;next = min;<br>            prep = min;<br>            min-&gt;next = p;<br>        }<br>    }</p><p>}<br>/<em>链表的插入排序</em>/<br>//比较恶心,优点难度，注重细节<br>void Linklist_increaseorder2(Linklist&amp; L) {<br>    LNode * r , * p = L-&gt;next,*pre=L;<br>    r = p-&gt;next;<br>    p-&gt;next = NULL; //!!!!这里没有想到 构造只含一个数据结点的有序表。少了这个会死循环<br>    p = r;<br>    while (p != NULL) {<br>        r = p-&gt;next;<br>        pre = L;<br>        while (pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;data<p->data)<br>            pre = pre-&gt;next;<br>        p-&gt;next = pre-&gt;next;<br>        pre-&gt;next = p;<br>        p = r;<br>    }<br>}</p><p>Linklist L1, L2, L3;<br>void printL(Linklist L) {<br>    Linklist p = L-&gt;next;<br>    while (p != NULL)<br>    {<br>        printf(“ %d”, p-&gt;data);<br>        p = p-&gt;next;<br>    }<br>}<br>int main() {<br>    int n,tmp;<br>    //scanf(“%d”, &amp;n);<br>    //L.length = n;<br>    //for (int i = 0; i &lt; n; i++) {<br>        //scanf(“%d”, &amp;tmp);<br>        //L.data[i] = tmp;<br>    //}<br>    //delet_x(L, 4);<br>    //delte_x_at(L, 0, 7, 4);<br>    //for (int i = 0; i &lt; L.length; i++) {<br>        //printf(“%d “, L.data[i]);<br>    //}<br>    //sqlrev(arr, 6, 4);</p><pre><code>//Linklist_init(L1);//Linklist_init2(&amp;L1);L2 = Linklist_init3();//Linklist_reverse(L-&gt;next);//Linklist_delele(L, 1);//Linklist_del(L,0);//Linklist_del2(L, 2);//Linklist_del3(L, 2);//dellmin4(L);//Linklist_reverse2(L1);//Linklist_increaseorder(L2);Linklist_increaseorder2(L2);printL(L2);    return 0;</code></pre><p>}</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;/&lt;strong&gt;&lt;strong&gt;****&lt;/strong&gt;&lt;/strong&gt;&lt;br&gt;线性表习题&lt;br&gt;&lt;strong&gt;&lt;strong&gt;****&lt;/strong&gt;&lt;/strong&gt;/&lt;/p&gt;
&lt;p&gt;/&lt;em&gt;2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法
      
    
    </summary>
    
    
      <category term="习题" scheme="https://github.com/HuanghualiWood/blog/categories/%E4%B9%A0%E9%A2%98/"/>
    
    
      <category term="数据结构" scheme="https://github.com/HuanghualiWood/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="线性表的操作" scheme="https://github.com/HuanghualiWood/blog/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    
  </entry>
  
  <entry>
    <title>PT2262解码原理</title>
    <link href="https://github.com/HuanghualiWood/blog/2020/06/10/test/"/>
    <id>https://github.com/HuanghualiWood/blog/2020/06/10/test/</id>
    <published>2020-06-09T16:00:00.000Z</published>
    <updated>2020-06-09T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<center># PT2262解码原理 </center><br><p><div class="row">    <embed src="./test.pdf" width="100%" height="550" type="application/pdf"></div>]]></content>
    
    <summary type="html">
    
      
      
        &lt;center&gt;
# PT2262解码原理 
&lt;/center&gt;


&lt;br&gt;


&lt;p&gt;

	&lt;div class=&quot;row&quot;&gt;
    &lt;embed src=&quot;./test.pdf&quot; width=&quot;100%&quot; height=&quot;550&quot; type=&quot;application/pd
      
    
    </summary>
    
    
      <category term="单片机" scheme="https://github.com/HuanghualiWood/blog/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"/>
    
    
      <category term="解码" scheme="https://github.com/HuanghualiWood/blog/tags/%E8%A7%A3%E7%A0%81/"/>
    
  </entry>
  
  <entry>
    <title>Pat1030 Dijkstra</title>
    <link href="https://github.com/HuanghualiWood/blog/2020/02/25/pat1030%20Dijkstra%20%E5%A0%86%E4%BC%98%E5%8C%96/"/>
    <id>https://github.com/HuanghualiWood/blog/2020/02/25/pat1030%20Dijkstra%20%E5%A0%86%E4%BC%98%E5%8C%96/</id>
    <published>2020-02-24T16:00:00.000Z</published>
    <updated>2020-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>A traveler’s map gives the distances between cities along the highways,together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.<br>Input Specification:</p><p>Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format:</p><pre><code>City1 City2 Distance Cost</code></pre><p>where the numbers are all integers no more than 500, and are separated by a space.<br>Output Specification:</p><p>For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.<br>Sample Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">4 5 0 3</span><br><span class="line">0 1 1 20</span><br><span class="line">1 3 2 30</span><br><span class="line">0 3 4 10</span><br><span class="line">0 2 2 20</span><br><span class="line">2 3 1 20</span><br><span class="line">Sample Output:</span><br><span class="line"></span><br><span class="line">0 2 3 3 40</span><br></pre></td></tr></table></figure><hr><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;cstdio&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line">#include &lt;algorithm&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 501</span><br><span class="line">struct Edge &#123;</span><br><span class="line">int from, to;</span><br><span class="line">int weight;</span><br><span class="line">int dist;</span><br><span class="line">Edge(int a,int b, int c,int d) : from(a),to(b), weight(c),dist(d) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">struct Node &#123;</span><br><span class="line">int dist, Nv;</span><br><span class="line">Node(int a, int b) :dist(a), Nv(b) &#123;&#125;; </span><br><span class="line">bool operator &lt; (const Node &amp;rhs) const &#123;</span><br><span class="line">return dist &gt; rhs.dist;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int Nv, Ne;</span><br><span class="line">vector&lt;Edge&gt; G[MAX];</span><br><span class="line">priority_queue&lt;Node&gt; q;</span><br><span class="line">int collected[MAX];</span><br><span class="line">int dist[MAX],pre[MAX],cost[MAX];</span><br><span class="line">void init() &#123;</span><br><span class="line">memset(pre, -1, sizeof(pre));</span><br><span class="line">memset(collected, 0, sizeof(collected));</span><br><span class="line">memset(dist, INF, sizeof(dist));</span><br><span class="line">&#125;</span><br><span class="line">void dijkstra(int s,int dir) &#123;</span><br><span class="line">q.push(Node&#123; 0,s &#125;);</span><br><span class="line">dist[s] &#x3D; 0;</span><br><span class="line">q.push(Node&#123; 0,s &#125;);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">Node front &#x3D; q.top();</span><br><span class="line">q.pop();</span><br><span class="line">int v &#x3D; front.Nv;</span><br><span class="line">if (v &#x3D;&#x3D; dir)break;</span><br><span class="line">for (Edge &amp;e:G[v]) &#123;</span><br><span class="line">int w &#x3D; e.to;</span><br><span class="line">if (collected[w]!&#x3D;false) continue;</span><br><span class="line">if (dist[v] + e.dist&lt;dist[w]) &#123;</span><br><span class="line">dist[w] &#x3D; e.dist + dist[v];</span><br><span class="line">pre[w] &#x3D; v;</span><br><span class="line">cost[w] &#x3D; cost[v] + e.weight;</span><br><span class="line">q.push(Node&#123; dist[w],w&#125;);</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; v&lt;&lt;&quot; &quot;&lt;&lt;w &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">else if (dist[v] + e.dist &#x3D;&#x3D; dist[w]) &#123;</span><br><span class="line">if (cost[v] + e.weight &lt; cost[w]) &#123;</span><br><span class="line">pre[w] &#x3D; v;</span><br><span class="line">cost[w] &#x3D; cost[v] + e.weight;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">init();</span><br><span class="line">int N, M, C1, C2;</span><br><span class="line">cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2;</span><br><span class="line">for (int i &#x3D; 0, v, w, d, c; i &lt; M; i++) &#123;</span><br><span class="line">cin &gt;&gt; v &gt;&gt; w &gt;&gt; d &gt;&gt; c;</span><br><span class="line">G[v].push_back(Edge(v,w,c, d));</span><br><span class="line">G[w].push_back(Edge(w,v,c, d));</span><br><span class="line">&#125;</span><br><span class="line">dijkstra(C1,C2);</span><br><span class="line">vector&lt;int&gt; path;</span><br><span class="line">for (int i &#x3D; C2; i!&#x3D;-1;i&#x3D;pre[i]) </span><br><span class="line">&#123;</span><br><span class="line">path.push_back(i);</span><br><span class="line">&#125;</span><br><span class="line">for (int i &#x3D; path.size()-1; i &gt;&#x3D; 0; i--) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;;</span><br><span class="line">cout &lt;&lt;dist[C2]&lt;&lt;&quot; &quot;&lt;&lt; cost[C2];</span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="笔记"><a href="#笔记" class="headerlink" title="笔记"></a>笔记</h3><ul><li>堆优化</li></ul><blockquote><p>堆优化的主要思想就是使用一个优先队列（就是每次弹出的元素一定是整个队列中最小的元素）来代替最近距离的查找，用邻接表代替邻接矩阵，这样可以大幅度节约时间开销。</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;A traveler’s map gives the distances between cities along the highways,together with the cost of each highway. Now you are supposed to wr
      
    
    </summary>
    
    
      <category term="pat" scheme="https://github.com/HuanghualiWood/blog/categories/pat/"/>
    
    
      <category term="Dijkstra堆优化" scheme="https://github.com/HuanghualiWood/blog/tags/Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96/"/>
    
      <category term="优先队列" scheme="https://github.com/HuanghualiWood/blog/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"/>
    
  </entry>
  
  <entry>
    <title>Pat1076 BFS</title>
    <link href="https://github.com/HuanghualiWood/blog/2020/02/25/pat1076%20BFS/"/>
    <id>https://github.com/HuanghualiWood/blog/2020/02/25/pat1076%20BFS/</id>
    <published>2020-02-24T16:00:00.000Z</published>
    <updated>2020-02-24T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.<br>Input Specification:</p><p>Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format:</p><p>M[i] user_list[i]</p><p>where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space.</p><p>Then finally a positive K is given, followed by K UserID’s for query.<br>Output Specification:</p><p>For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.<br>Sample Input:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">7 3</span><br><span class="line">3 2 3 4</span><br><span class="line">0</span><br><span class="line">2 5 6</span><br><span class="line">2 3 1</span><br><span class="line">2 3 4</span><br><span class="line">1 4</span><br><span class="line">1 5</span><br><span class="line">2 2 6</span><br><span class="line">Sample Output:</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">#include &lt;cstring&gt;</span><br><span class="line">#include &lt;stdio.h&gt;</span><br><span class="line">#include &lt;queue&gt;</span><br><span class="line">#include &lt;vector&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">#define MAX 1001</span><br><span class="line">struct Edge &#123;</span><br><span class="line">int from, to;</span><br><span class="line">Edge(int a, int b) :from(a), to(b) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line">struct Node &#123;</span><br><span class="line">int nv,level;&#x2F;&#x2F;在结构体中添加路径层数</span><br><span class="line">Node(int a, int b) :nv(a), level(b) &#123;&#125;;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">vector&lt;Edge&gt; G[MAX];</span><br><span class="line">int visited[MAX],num[MAX],pre[MAX];</span><br><span class="line"></span><br><span class="line">void init() &#123;</span><br><span class="line">memset(visited, 0, sizeof(visited));</span><br><span class="line">&#125;</span><br><span class="line">void BFS(int s,int len) &#123;</span><br><span class="line">queue&lt;Node&gt; q;</span><br><span class="line">q.push(Node&#123;s,0&#125;);</span><br><span class="line">while (!q.empty()) &#123;</span><br><span class="line">Node node &#x3D; q.front();</span><br><span class="line">q.pop();</span><br><span class="line">int v &#x3D; node.nv;</span><br><span class="line">int level &#x3D; node.level;</span><br><span class="line">if (level &#x3D;&#x3D; len)break;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; v;</span><br><span class="line">visited[v] &#x3D; 1;</span><br><span class="line">for (Edge&amp; e : G[v]) &#123;</span><br><span class="line">int w &#x3D; e.to;</span><br><span class="line">if (visited[w])continue;</span><br><span class="line">visited[w] &#x3D; 1;</span><br><span class="line">num[s]++;</span><br><span class="line">q.push(Node(w,level+1));</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; &quot;--&quot;&lt;&lt; w&lt;&lt;&quot; &quot;;</span><br><span class="line">&#125;</span><br><span class="line">&#x2F;&#x2F;cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">memset(G, 0, sizeof(G));</span><br><span class="line">int M, L,tmp;</span><br><span class="line">cin &gt;&gt; M &gt;&gt; L;</span><br><span class="line">for (int i &#x3D; 1; i &lt;&#x3D; M; i++) &#123;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">for (int j &#x3D; 1; j &lt;&#x3D; tmp; j++) &#123;</span><br><span class="line">int x;</span><br><span class="line">cin &gt;&gt; x;</span><br><span class="line">G[x].push_back(Edge&#123; x,i &#125;);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cin &gt;&gt; tmp;</span><br><span class="line">for (int i &#x3D; 0; i &lt; tmp; i++) &#123;</span><br><span class="line">int a;</span><br><span class="line">cin &gt;&gt; a;</span><br><span class="line">init();</span><br><span class="line">BFS(a, L);</span><br><span class="line">cout &lt;&lt; num[a];</span><br><span class="line">if (i !&#x3D; tmp - 1)cout &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="心得"><a href="#心得" class="headerlink" title="心得"></a>心得</h3><p>这道题是单向无权图–&gt;BFS</p><ul><li>题目编号从1-N；建图应该从1到N方便</li><li>记录BFS遍历图的层数，在结点结构体中添加层数信息。在BFS中更新。</li><li>BFS跟Dijkstra的区别：BFS只要访问到邻接点，邻接点就要被收录而不用再通过邻接点去做松弛操作更新它的邻接点的最小路径</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hen
      
    
    </summary>
    
    
      <category term="pat" scheme="https://github.com/HuanghualiWood/blog/categories/pat/"/>
    
    
      <category term="BFS" scheme="https://github.com/HuanghualiWood/blog/tags/BFS/"/>
    
      <category term="BFS如何记录层数" scheme="https://github.com/HuanghualiWood/blog/tags/BFS%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E5%B1%82%E6%95%B0/"/>
    
  </entry>
  
  <entry>
    <title>Markdown语法</title>
    <link href="https://github.com/HuanghualiWood/blog/2020/02/24/markdown%E8%AF%AD%E6%B3%95/"/>
    <id>https://github.com/HuanghualiWood/blog/2020/02/24/markdown%E8%AF%AD%E6%B3%95/</id>
    <published>2020-02-24T04:21:50.588Z</published>
    <updated>2020-02-24T04:21:50.588Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;div style&#x3D;&#39;display: none&#39;&gt;</span><br><span class="line">哈哈我是注释，不会在浏览器中显示。</span><br><span class="line">&lt;&#x2F;div&gt;</span><br><span class="line"></span><br><span class="line">- 标题</span><br><span class="line"># 一级标题</span><br><span class="line">## 二级标题</span><br><span class="line">### 三级标题</span><br><span class="line">#### 四级标题</span><br><span class="line">##### 五级标题</span><br><span class="line">###### 六级标题  &lt;!--最多6级标题--&gt;</span><br><span class="line"></span><br><span class="line">- 任务列表</span><br><span class="line">- [ ] 任务一 未做任务 &#96;- + 空格 + [ ]&#96;</span><br><span class="line">- [x] 任务二 已做任务 &#96;- + 空格 + [x]&#96;</span><br><span class="line">-</span><br></pre></td></tr></table></figure><div style='display: none'>哈哈我是注释，不会在浏览器中显示。</div><ul><li><p>标题</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题"></a>一级标题</h1><h2 id="二级标题"><a href="#二级标题" class="headerlink" title="二级标题"></a>二级标题</h2><h3 id="三级标题"><a href="#三级标题" class="headerlink" title="三级标题"></a>三级标题</h3><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题"></a>四级标题</h4><h5 id="五级标题"><a href="#五级标题" class="headerlink" title="五级标题"></a>五级标题</h5><h6 id="六级标题"><a href="#六级标题" class="headerlink" title="六级标题  "></a>六级标题  <!--最多6级标题--></h6></li><li><p>任务列表</p></li><li><input disabled="" type="checkbox"> <p>任务一 未做任务 <code>- + 空格 + [ ]</code></p></li><li><input checked="" disabled="" type="checkbox"> <p>任务二 已做任务 <code>- + 空格 + [x]</code></p></li><li></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">【1】 &amp;emsp;或&amp;#8195; &#x2F;&#x2F;全角</span><br><span class="line">【2】 &amp;ensp;或&amp;#8194; &#x2F;&#x2F;半角</span><br><span class="line">【3】 &amp;nbsp;或&amp;#160;  &#x2F;&#x2F;半角之半角</span><br><span class="line"></span><br><span class="line">&lt;center&gt;行中心对齐&lt;&#x2F;center&gt;</span><br><span class="line">&lt;p align&#x3D;&quot;left&quot;&gt;行左对齐&lt;&#x2F;p&gt;</span><br><span class="line">&lt;p align&#x3D;&quot;right&quot;&gt;行右对齐&lt;&#x2F;p&gt;</span><br></pre></td></tr></table></figure><p>【1】 &emsp;或&#8195; //全角<br>【2】 &ensp;或&#8194; //半角<br>【3】 &nbsp;或&#160;  //半角之半角</p><center>行中心对齐</center><p align="left">行左对齐</p><p align="right">行右对齐</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">&gt;*斜体*或_斜体_</span><br><span class="line"></span><br><span class="line">&gt;**粗体**</span><br><span class="line"></span><br><span class="line">&gt;***加粗斜体***</span><br><span class="line"></span><br><span class="line">&gt;~~删除线~~</span><br><span class="line"></span><br><span class="line">&gt;++下划线++</span><br><span class="line"></span><br><span class="line">&gt;&#x3D;&#x3D;背景高亮&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><blockquote><p><em>斜体</em>或<em>斜体</em></p></blockquote><blockquote><p><strong>粗体</strong></p></blockquote><blockquote><p><strong><em>加粗斜体</em></strong></p></blockquote><blockquote><p><del>删除线</del></p></blockquote><blockquote><p>++下划线++</p></blockquote><blockquote><p>==背景高亮==</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#0099ff size&#x3D;12 face&#x3D;&quot;黑体&quot;&gt;黑体&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;gray size&#x3D;5&gt;gray&lt;&#x2F;font&gt;</span><br><span class="line">&lt;font color&#x3D;#00ffff size&#x3D;3&gt;null&lt;&#x2F;font&gt;</span><br></pre></td></tr></table></figure><p><font face="黑体">我是黑体字</font><br><font face="微软雅黑">我是微软雅黑</font><br><font face="STCAIYUN">我是华文彩云</font><br><font color=#0099ff size=12 face="黑体">黑体</font><br><font color=gray size=5>gray</font><br><font color=#00ffff size=3>null</font></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">* 无序列表项 一</span><br><span class="line">+ 无序列表项 二</span><br><span class="line">- 无序列表项 三</span><br><span class="line">1. 有序列表项 一</span><br><span class="line">2. 有序列表项 二</span><br><span class="line">3. 有序列表项 三</span><br></pre></td></tr></table></figure><ul><li>无序列表项 一</li></ul><ul><li>无序列表项 二</li></ul><ul><li>无序列表项 三</li></ul><ol><li>有序列表项 一</li><li>有序列表项 二</li><li>有序列表项 三</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">&lt;center&gt;  &lt;!--开始居中对齐--&gt;</span><br><span class="line"></span><br><span class="line">![GitHub set up](http:&#x2F;&#x2F;zh.mweb.im&#x2F;asset&#x2F;img&#x2F;set-up-git.gif &quot;图片Title&quot;)</span><br><span class="line"></span><br><span class="line">![图片Alt](图片地址 &quot;图片Title&quot;)</span><br><span class="line"></span><br><span class="line">&lt;&#x2F;center&gt; &lt;!--结束居中对齐--&gt;</span><br><span class="line"></span><br><span class="line">&gt;- 超链接</span><br><span class="line"></span><br><span class="line">&gt;欢迎阅读 [择势勤](https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;16d77399d3a7 &quot;择势勤&quot;)</span><br><span class="line"></span><br><span class="line">&gt;网站[Google][1]、[Leanote][2]。</span><br><span class="line"></span><br><span class="line">[1]:http:&#x2F;&#x2F;www.google.com </span><br><span class="line">[2]:http:&#x2F;&#x2F;www.leanote.com</span><br><span class="line"></span><br><span class="line">- 注脚</span><br><span class="line">使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]。</span><br><span class="line"></span><br><span class="line">[^1]:Markdown是一种纯文本标记语言</span><br><span class="line"></span><br><span class="line">[^2]:HyperText Markup Language 超文本标记语言</span><br><span class="line"></span><br><span class="line">- 在段落填写[TOC]以显示全文内容的目录结构</span><br><span class="line">[TOC]</span><br></pre></td></tr></table></figure><center>  <!--开始居中对齐--><p><img src="https://ss2.bdstatic.com/70cFvnSh_Q1YnxGkpoWK1HF6hhy/it/u=1969454436,2593720224&fm=26&gp=0.jpg" alt="GitHub set up"></p></center> <!--结束居中对齐--><blockquote><ul><li>超链接</li></ul></blockquote><blockquote><p>欢迎阅读 <a href="https://www.jianshu.com/u/16d77399d3a7" target="_blank" rel="noopener" title="择势勤">择势勤</a></p></blockquote><blockquote><p>网站<a href="http://www.google.com" target="_blank" rel="noopener">Google</a>、<a href="http://www.leanote.com" target="_blank" rel="noopener">Leanote</a>。</p></blockquote><ul><li>注脚<br>使用 Markdown<a href="Markdown是一种纯文本标记语言">^1</a>可以效率的书写文档, 直接转换成 HTML[^2]。</li></ul><p>[^2]:HyperText Markup Language 超文本标记语言</p><ul><li>在段落填写[TOC]以显示全文内容的目录结构<br>[TOC]</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">include &lt;stdio.h&gt;</span><br><span class="line">int main(void)</span><br><span class="line">&#123;</span><br><span class="line">printf(&quot;Hello world\n&quot;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><table><thead><tr><th>学号</th><th>姓名</th><th>序号</th></tr></thead><tbody><tr><td>小明明</td><td>男</td><td>5</td></tr><tr><td>小红</td><td>女</td><td>79</td></tr><tr><td>小陆</td><td>男</td><td>192</td></tr></tbody></table><hr><p>摘自 <a href="https://www.jianshu.com/p/ebe52d2d468f" target="_blank" rel="noopener">简书</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class
      
    
    </summary>
    
    
      <category term="basic" scheme="https://github.com/HuanghualiWood/blog/categories/basic/"/>
    
    
      <category term="markdown" scheme="https://github.com/HuanghualiWood/blog/tags/markdown/"/>
    
  </entry>
  
  <entry>
    <title>Samba服务器</title>
    <link href="https://github.com/HuanghualiWood/blog/2020/02/23/SAMBA%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://github.com/HuanghualiWood/blog/2020/02/23/SAMBA%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-02-22T16:00:00.000Z</published>
    <updated>2020-02-22T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="samba的功能"><a href="#samba的功能" class="headerlink" title="samba的功能"></a>samba的功能</h3><ul><li>共享文件和打印机服务</li><li>身份认证，提供不同身份用户的个别数据</li><li>进行window网络上的主机名解析</li><li>可以进行设备的共享</li></ul><h3 id="samba常见的应用"><a href="#samba常见的应用" class="headerlink" title="samba常见的应用"></a>samba常见的应用</h3><ul><li>1利用软件直接剪辑www主机上面的网页数据</li><li>做成可以直接连接的文件服务器</li><li>打印机服务器</li></ul><p>samba使用的NetBIOS通信协议</p><p>samba使用的daemons</p><ul><li><p>nmbd 这个daemon用来管理工作组，NetBIOS Name 等解析。主要利用UDP协议开启port137，138来负责名称解析的任务</p></li><li><p>smbd 这个daemon主要功能用来管理samba主机共享的目录，文件与打印机等。利用可靠的TCP协议来传输数据，开放的端口139及445</p></li></ul><h4 id="连接模式（Peer-Peer（对等模式），Domain-model（主控模式））"><a href="#连接模式（Peer-Peer（对等模式），Domain-model（主控模式））" class="headerlink" title="连接模式（Peer/Peer（对等模式），Domain model（主控模式））"></a>连接模式（Peer/Peer（对等模式），Domain model（主控模式））</h4>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;samba的功能&quot;&gt;&lt;a href=&quot;#samba的功能&quot; class=&quot;headerlink&quot; title=&quot;samba的功能&quot;&gt;&lt;/a&gt;samba的功能&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;共享文件和打印机服务&lt;/li&gt;
&lt;li&gt;身份认证，提供不同身份用户的个别数据&lt;/
      
    
    </summary>
    
    
      <category term="网络" scheme="https://github.com/HuanghualiWood/blog/categories/%E7%BD%91%E7%BB%9C/"/>
    
    
      <category term="萌新" scheme="https://github.com/HuanghualiWood/blog/tags/%E8%90%8C%E6%96%B0/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://github.com/HuanghualiWood/blog/2020/02/01/hello-world/"/>
    <id>https://github.com/HuanghualiWood/blog/2020/02/01/hello-world/</id>
    <published>2020-01-31T16:00:00.000Z</published>
    <updated>2020-01-31T16:00:00.000Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.
      
    
    </summary>
    
    
    
      <category term="萌新" scheme="https://github.com/HuanghualiWood/blog/tags/%E8%90%8C%E6%96%B0/"/>
    
  </entry>
  
</feed>
