{"meta":{"title":"Hexo","subtitle":"","description":"","author":"minhao","url":"https://blog-1e57ca-1302405762.tcloudbaseapp.com","root":"/"},"pages":[{}],"posts":[{"title":"Ps","date":"2020-06-13T02:01:11.000Z","path":"2020/06/13/ps/","text":"ps素描方法:1去色，查找边缘，成角的线条，图册混合模式，颜色减淡2去色，反相，最小值，混合选项，创建空白图层，选区羽化，添加蒙版，添加杂色，填充rgb240x3的图层蒙版：*图层蒙版*剪贴蒙版 Crtl+Shift+G矢量蒙版快速蒙版通道：颜色通道:存储颜色专色通道 增强画质第一，先打开原图，双击解锁。第二，CTRL+J创建副本养成好习惯。对副本模式选择“亮度”第三，选择“滤镜”菜单下的“锐化—USM锐化”命令，在设置窗口中适当调节一下锐化参数，根据你原图模糊的情况来调节，第四，经过第三步，为照片清晰大致做了个基础。接着选择“图像”菜单下“模式—LAB颜色”命令，在弹出的窗口中选择“拼合”图层确定。在LAB模式下，再创建副本。第六， 在“通道”面板中看到图层通道上有了“明度”通道，选定这个通道，再使用“滤镜”菜单的“锐化—USM锐化”命令，设置好锐化参数将这个通道锐化处第七，返回图层面板，把副本图层的模式修改为“柔光”，调节透明度为30%。看看此时的图像不仅画面更清晰，色彩也更加绚丽了。（这部可根据自己的照片情况增删）","comments":true,"categories":[],"tags":[{"name":"ps note","slug":"ps-note","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/ps-note/"}]},{"title":"图的遍历/最短路径","date":"2020-06-13T01:58:01.058Z","path":"2020/06/13/图的遍历&最短路径/","text":"一.DFS DFS求连通分量的个数 什么是连通分量？ 连通分量个数就是使用DFS的次数 BFS 宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 松弛函数 对边集合 E 中任意边，以 w(u,v) 表示顶点 u 出发到顶点 v 的边的权值，以 d[v] 表示当前从起点 s 到顶点 v 的路径权值 若存在边 w(u,v)，使得： 则更新 d[v] 值： 所以松弛函数的作用，就是判断是否经过某个顶点，或者说经过某条边，可以缩短起点到终点的路径权值。 为什么将缩短距离的操作称之为“松弛”，不妨理解为，选择某种方式后，到达目的的总代价降低了。什么名字无关紧要，不必纠结。 -堆优化优化Dijkstra","comments":true,"categories":[],"tags":[{"name":"“图”","slug":"“图”","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E2%80%9C%E5%9B%BE%E2%80%9D/"}]},{"title":"1","date":"2020-06-13T01:55:48.000Z","path":"2020/06/13/1/","text":"title: c++队列堆栈 tags: “c++base” catogories: - pta 添加库queue 1234#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std; 五个操作q.push()q.pop()q.front()q.back()q.empty() 2.bool empty() const 判断队列是否为空 c.empty(); 3.size_type size() const 返回队列中元素个数 c.size() 4.value_type&amp; front(); const value_type&amp; front() const; 返回队列中第一个元素,即最后插入到队列中的那个元素 c.front(); 5.value_type&amp; back(); const value_type&amp; back() const; 返回队列中最后一个元素，即最先入队的那个元素 c.back(); 6.void push (const value_type&amp; val) 插入一个新元素在队尾 c.push(value) 7.void emplace(Args&amp;&amp; args) 插入一个新的元素在队尾 c.emplace(args); 8.void pop() 移除队首元素 c.pop(); 9.void swap(queue&amp; x) 交换两个队列的内容 c.swap(d); 10.与stack和vector一样，重载了几个运算符:== != &lt; &lt;= &gt; &gt;=","comments":true,"categories":[],"tags":[]},{"title":"Layout","date":"2020-06-13T01:55:06.000Z","path":"2020/06/13/layout/","text":"","comments":true,"categories":[],"tags":[]},{"title":"C++队列堆栈stl","date":"2020-06-13T01:54:03.000Z","path":"2020/06/13/c++队列堆栈stl/","text":"title: c++队列堆栈 tags: “c++base” catogories: - pta 添加库queue 1234#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std; 五个操作q.push()q.pop()q.front()q.back()q.empty() 2.bool empty() const 判断队列是否为空 c.empty(); 3.size_type size() const 返回队列中元素个数 c.size() 4.value_type&amp; front(); const value_type&amp; front() const; 返回队列中第一个元素,即最后插入到队列中的那个元素 c.front(); 5.value_type&amp; back(); const value_type&amp; back() const; 返回队列中最后一个元素，即最先入队的那个元素 c.back(); 6.void push (const value_type&amp; val) 插入一个新元素在队尾 c.push(value) 7.void emplace(Args&amp;&amp; args) 插入一个新的元素在队尾 c.emplace(args); 8.void pop() 移除队首元素 c.pop(); 9.void swap(queue&amp; x) 交换两个队列的内容 c.swap(d); 10.与stack和vector一样，重载了几个运算符:== != &lt; &lt;= &gt; &gt;=","comments":true,"categories":[],"tags":[]},{"title":"数电","date":"2020-06-11T16:41:57.000Z","path":"2020/06/12/数电/","text":"# 数电笔记","comments":true,"categories":[],"tags":[{"name":"数电","slug":"数电","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E6%95%B0%E7%94%B5/"}]},{"title":"PT2262解码原理","date":"2020-06-09T16:00:00.000Z","path":"2020/06/10/test/","text":"# PT2262解码原理","comments":true,"categories":[{"name":"单片机","slug":"单片机","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"解码","slug":"解码","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E8%A7%A3%E7%A0%81/"}]},{"title":"线性表习题","date":"2020-06-09T16:00:00.000Z","path":"2020/06/10/线性表习题/","text":"线性表习题123456789&#x2F;*2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素*&#x2F;&#x2F;*2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）*&#x2F;&#x2F;*2-2-8 将数组中两个顺序表的位置置换*&#x2F;&#x2F;*2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点*&#x2F;&#x2F;*2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间*&#x2F;&#x2F;*2-3-3 L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值*&#x2F;&#x2F;*2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）*&#x2F;&#x2F;*2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)*&#x2F;&#x2F;*2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序*&#x2F; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;cstdio&gt;#define Elemtype int&#x2F;&#x2F;顺序存储结构typedef struct &#123; Elemtype data[50] &#x3D; &#123; 4, 3, 3, 4, 2, 4, 5, 6, 6, 6 &#125;; Elemtype length;&#125;Sqlist;Sqlist L;&#x2F;&#x2F;链式存储结构typedef struct LNode &#123; Elemtype data; struct LNode* next;&#125;LNode,*Linklist;&#x2F;*------------建立链表，注意双指针以及辅助指针的使用-------------*&#x2F;&#x2F;&#x2F;指针的引用void Linklist_init(Linklist &amp;L) &#123; L &#x3D; (Linklist)malloc(sizeof(LNode)); LNode* tmp, * r &#x3D; L;&#x2F;&#x2F;必须要一个辅助指针*r L-&gt;data &#x3D; -1; L-&gt;next &#x3D; NULL; for (int i &#x3D; 0; i &lt; 10; i++) &#123; tmp &#x3D; (LNode*)malloc(sizeof(LNode)); if (tmp !&#x3D; NULL) &#123; tmp-&gt;data &#x3D; i ; r-&gt;next &#x3D; tmp; r &#x3D; tmp; &#125; &#125; r-&gt;next &#x3D; NULL;&#125;&#x2F;&#x2F;二级指针，传入实参地址void Linklist_init2(LNode ** L) &#123; *L &#x3D; (LNode*)malloc(sizeof(LNode)); LNode* tmp, * r &#x3D; *L; r-&gt;data &#x3D; -1; r-&gt;next &#x3D; NULL; for (int i &#x3D; 0; i &lt; 20; i++) &#123; tmp &#x3D; (LNode*)malloc(sizeof(LNode)); if (tmp !&#x3D; NULL) &#123; tmp-&gt;data &#x3D; i % 5; r-&gt;next &#x3D; tmp; r &#x3D; tmp; &#125; &#125; r-&gt;next &#x3D; NULL;&#125;&#x2F;&#x2F;return返回Linklist Linklist_init3(void) &#123; Linklist L &#x3D; (Linklist)malloc(sizeof(LNode)); LNode* tmp, * r &#x3D; L; r-&gt;data &#x3D; -1; r-&gt;next &#x3D; NULL; for (int i &#x3D; 0; i &lt; 10; i++) &#123; tmp &#x3D; (LNode*)malloc(sizeof(LNode)); if (tmp !&#x3D; NULL) &#123; tmp-&gt;data &#x3D; i % 6; r-&gt;next &#x3D; tmp; r &#x3D; tmp; &#125; &#125; r-&gt;next &#x3D; NULL; return L;&#125; /2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素/ 123456789101112131415161718void delet_x(Sqlist &amp;L, int value) &#123; int i&#x3D;0, k&#x3D;0, j&#x3D;0; int length &#x3D; L.length; j &#x3D; 0; while (i&lt;L.length) &#123; if (k !&#x3D; 0) &#123; L.data[i-k] &#x3D; L.data[i]; &#125; if (L.data[i] &#x3D;&#x3D; value) &#123; k++; length--; &#125; i++; &#125; for (i &#x3D; length; i &lt; L.length; i++) L.data[i] &#x3D; 0; L.length &#x3D; length;&#125; /2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）///理解错误，做成了，删除线性表范围在s和t之间的值为x的元素 123456789101112131415161718bool delte_x_at(Sqlist &amp;L, int s, int t, int value) &#123; if (s &gt;&#x3D; t)return false; if (L.length &lt;&#x3D; 0)return false; int i&#x3D;0, j&#x3D;0,k&#x3D;0; for (i &#x3D; s+1; i &lt; t; i++) &#123; if (L.data[i] !&#x3D; value) &#123; L.data[k+s+1] &#x3D; L.data[i]; k++; &#125; &#125; j &#x3D; t - s - 1 - k; for (i &#x3D; t; i &lt; L.length; i++) L.data[i - j] &#x3D; L.data[i]; for (i &#x3D;0; i &lt;j; i++) L.data[L.length - 1 - i] &#x3D; 0; L.length &#x3D; L.length - (t - s - 1) + k; return true;&#125; /2-2-8 将数组中两个顺序表的位置置换/ 123456789101112131415161718### 逆置算法int arr[10] &#x3D; &#123; 1,2,3,4,5,6,1,2,3,4 &#125;;bool reverse(int arr[], int left, int right) &#123; if (left &gt; right)return false; int mid &#x3D; (left+right) &#x2F; 2; for (int i &#x3D; 0; i &lt;&#x3D; mid - left; i++) &#123; int tmp &#x3D; arr[i+left]; arr[i + left] &#x3D; arr[right - i]; arr[right - i] &#x3D; tmp; &#125; return true;&#125;bool Sqlist_rev(int arr[],int m, int n) &#123; reverse(arr, 0, m + n - 1); reverse(arr,0, n - 1); reverse(arr, n, m+n - 1); return true;&#125; /2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点/ 1234567891011bool Linklist_delele(Linklist&amp; L, int x) &#123; if (!L)return false; if (L-&gt;data &#x3D;&#x3D; x) &#123; LNode *q &#x3D; L; L &#x3D; L-&gt;next; free(q); Linklist_delele(L, x); &#125; Linklist_delele(L-&gt;next, x); return true;&#125; /2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;&#x2F;------------------------------------------------------void Linklist_del(Linklist &amp;L, Elemtype x) &#123; LNode *q, *p &#x3D; L-&gt;next, *pre &#x3D; L; while (p) &#123; if (p-&gt;data &#x3D;&#x3D; x) &#123; q &#x3D; p; p &#x3D; p-&gt;next;&#x2F;&#x2F;p还要往前移一个，和L的位置重合 pre-&gt;next &#x3D; p; free(q); printf(&quot;. &quot;); &#125; else &#123; pre &#x3D; p; p &#x3D; p-&gt;next; &#125; &#125;&#125;&#x2F;&#x2F;删除也可以传入一级指针,无需指针的引用void Linklist_del2(Linklist L, Elemtype x) &#123;&#x2F;&#x2F;L此时为形参，函数内生成L头结点的副本，不过指向的内容仍然 Linklist q, p &#x3D; L-&gt;next, pre &#x3D; L; &#x2F;&#x2F;是L。可以实现对L的删除。 while (p) &#123; if (p-&gt;data &#x3D;&#x3D; x) &#123; q &#x3D; p; p &#x3D; p-&gt;next; L-&gt;next &#x3D; p; free(q); printf(&quot;. &quot;); &#125; else &#123; pre &#x3D; p; p &#x3D; p-&gt;next; &#125; &#125;&#125;### 尾插法，删除特定值void Linklist_del3(Linklist &amp;L, Elemtype x) &#123; Linklist q, p &#x3D; L-&gt;next, r &#x3D; L; while (p) &#123; if (p-&gt;data !&#x3D; x) &#123; r-&gt;next&#x3D;p; r &#x3D; p; p&#x3D; p-&gt;next; &#125; else &#123; q &#x3D; p; p &#x3D; p-&gt;next; free(q); printf(&quot;. &quot;); &#125; &#125; r-&gt;next &#x3D; NULL;&#125; /2-3-3L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值/ 12345void Linklist_reverse(Linklist L) &#123; if(L-&gt;next) Linklist_reverse(L-&gt;next); printf(&quot;%d &quot;, L-&gt;data); &#125; /2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）/void dellmin4(Linklist &amp;L) { LNode* pre = L, * p = L-&gt;next; LNode* tmp=p,tmppre=pre ; while (p != NULL) { if (tmp-&gt;data &gt; p-&gt;data) { tmp = p; tmppre = pre; } pre = p; p = p-&gt;next; } tmppre-&gt;next = tmp-&gt;next; free(tmp);}/*2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)///xxxxxvoid Linklist_reverse2(Linklist &amp;L) { LNode *pre = NULL, *p = L-&gt;next, * tmp = L; while (p != NULL) { tmp = p-&gt;next; p-&gt;next = pre; pre = p; p = tmp; } L-&gt;next=pre;} 2头插法，精妙！void Linklist_reverse2_2(Linklist&amp; L) { LNode * first = L, * p = L-&gt;next, * tmp = L; while (p != NULL) { tmp = p-&gt;next; first = L-&gt;next; L-&gt;next = p; p-&gt;next = first; first-&gt;next = tmp; } }/2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序///不应该使用选择排序，选择最小结点操作很麻烦void Linklist_increaseorder(Linklist &amp;L) { LNode * p = L-&gt;next,*prep=L; LNode * q = NULL, * preq = L; LNode * min = p, * premin = p; while (p != NULL) { premin = min = p; preq = premin; q = p; printf(“p:%d “, p-&gt;data); while (q != NULL) { printf(“ q:%d “, q-&gt;data); if (q-&gt;data &lt; min-&gt;data) { premin = preq; min = q; printf(“%d”, min-&gt;data); } preq = q; q = q-&gt;next; } if (min-&gt;next != NULL) premin-&gt;next = min-&gt;next; else premin-&gt;next = NULL;//少了这一句链表编程循环队列-_-,死循环！！！！ if (min == p) { printf(“no min \\n “); prep = p; p = p-&gt;next; } else { prep-&gt;next = min; prep = min; min-&gt;next = p; } } }/链表的插入排序///比较恶心,优点难度，注重细节void Linklist_increaseorder2(Linklist&amp; L) { LNode * r , * p = L-&gt;next,*pre=L; r = p-&gt;next; p-&gt;next = NULL; //!!!!这里没有想到 构造只含一个数据结点的有序表。少了这个会死循环 p = r; while (p != NULL) { r = p-&gt;next; pre = L; while (pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;datadata) pre = pre-&gt;next; p-&gt;next = pre-&gt;next; pre-&gt;next = p; p = r; }} Linklist L1, L2, L3;void printL(Linklist L) { Linklist p = L-&gt;next; while (p != NULL) { printf(“ %d”, p-&gt;data); p = p-&gt;next; }} int main() { int n,tmp; //scanf(“%d”, &amp;n); //L.length = n; //for (int i = 0; i &lt; n; i++) { //scanf(“%d”, &amp;tmp); //L.data[i] = tmp; //} //delet_x(L, 4); //delte_x_at(L, 0, 7, 4); //for (int i = 0; i &lt; L.length; i++) { //printf(“%d “, L.data[i]); //} //sqlrev(arr, 6, 4); //Linklist_init(L1); //Linklist_init2(&amp;L1); L2 = Linklist_init3(); //Linklist_reverse(L-&gt;next); //Linklist_delele(L, 1); //Linklist_del(L,0); //Linklist_del2(L, 2); //Linklist_del3(L, 2); //dellmin4(L); //Linklist_reverse2(L1); //Linklist_increaseorder(L2); Linklist_increaseorder2(L2); printL(L2); return 0;}","comments":true,"categories":[{"name":"习题","slug":"习题","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表的操作","slug":"线性表的操作","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"Pat1030 Dijkstra","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/pat1030 Dijkstra 堆优化/","text":"A traveler’s map gives the distances between cities along the highways,together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.Input Specification: Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: City1 City2 Distance Costwhere the numbers are all integers no more than 500, and are separated by a space.Output Specification: For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.Sample Input: 1234567894 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20Sample Output:0 2 3 3 40 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define MAX 501struct Edge &#123; int from, to; int weight; int dist; Edge(int a,int b, int c,int d) : from(a),to(b), weight(c),dist(d) &#123;&#125;;&#125;;struct Node &#123; int dist, Nv; Node(int a, int b) :dist(a), Nv(b) &#123;&#125;; bool operator &lt; (const Node &amp;rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;int Nv, Ne;vector&lt;Edge&gt; G[MAX];priority_queue&lt;Node&gt; q;int collected[MAX];int dist[MAX],pre[MAX],cost[MAX];void init() &#123; memset(pre, -1, sizeof(pre)); memset(collected, 0, sizeof(collected)); memset(dist, INF, sizeof(dist));&#125;void dijkstra(int s,int dir) &#123; q.push(Node&#123; 0,s &#125;); dist[s] &#x3D; 0; q.push(Node&#123; 0,s &#125;); while (!q.empty()) &#123; Node front &#x3D; q.top(); q.pop(); int v &#x3D; front.Nv; if (v &#x3D;&#x3D; dir)break; for (Edge &amp;e:G[v]) &#123; int w &#x3D; e.to; if (collected[w]!&#x3D;false) continue; if (dist[v] + e.dist&lt;dist[w]) &#123; dist[w] &#x3D; e.dist + dist[v]; pre[w] &#x3D; v; cost[w] &#x3D; cost[v] + e.weight; q.push(Node&#123; dist[w],w&#125;); &#x2F;&#x2F;cout &lt;&lt; v&lt;&lt;&quot; &quot;&lt;&lt;w &lt;&lt; endl; &#125; else if (dist[v] + e.dist &#x3D;&#x3D; dist[w]) &#123; if (cost[v] + e.weight &lt; cost[w]) &#123; pre[w] &#x3D; v; cost[w] &#x3D; cost[v] + e.weight; &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); int N, M, C1, C2; cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2; for (int i &#x3D; 0, v, w, d, c; i &lt; M; i++) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; d &gt;&gt; c; G[v].push_back(Edge(v,w,c, d)); G[w].push_back(Edge(w,v,c, d)); &#125; dijkstra(C1,C2); vector&lt;int&gt; path; for (int i &#x3D; C2; i!&#x3D;-1;i&#x3D;pre[i]) &#123; path.push_back(i); &#125; for (int i &#x3D; path.size()-1; i &gt;&#x3D; 0; i--) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; cout &lt;&lt;dist[C2]&lt;&lt;&quot; &quot;&lt;&lt; cost[C2]; return 0;&#125; 笔记 堆优化 堆优化的主要思想就是使用一个优先队列（就是每次弹出的元素一定是整个队列中最小的元素）来代替最近距离的查找，用邻接表代替邻接矩阵，这样可以大幅度节约时间开销。","comments":true,"categories":[{"name":"pat","slug":"pat","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/pat/"}],"tags":[{"name":"Dijkstra堆优化","slug":"Dijkstra堆优化","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96/"},{"name":"优先队列","slug":"优先队列","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}]},{"title":"Pat1076 BFS","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/pat1076 BFS/","text":"Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format: M[i] user_list[i] where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K is given, followed by K UserID’s for query.Output Specification: For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.Sample Input: 1234567891011127 33 2 3 402 5 62 3 12 3 41 41 52 2 6Sample Output:45 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define MAX 1001struct Edge &#123; int from, to; Edge(int a, int b) :from(a), to(b) &#123;&#125;;&#125;;struct Node &#123; int nv,level;&#x2F;&#x2F;在结构体中添加路径层数 Node(int a, int b) :nv(a), level(b) &#123;&#125;;&#125;;vector&lt;Edge&gt; G[MAX];int visited[MAX],num[MAX],pre[MAX];void init() &#123; memset(visited, 0, sizeof(visited));&#125;void BFS(int s,int len) &#123; queue&lt;Node&gt; q; q.push(Node&#123;s,0&#125;); while (!q.empty()) &#123; Node node &#x3D; q.front(); q.pop(); int v &#x3D; node.nv; int level &#x3D; node.level; if (level &#x3D;&#x3D; len)break; &#x2F;&#x2F;cout &lt;&lt; v; visited[v] &#x3D; 1; for (Edge&amp; e : G[v]) &#123; int w &#x3D; e.to; if (visited[w])continue; visited[w] &#x3D; 1; num[s]++; q.push(Node(w,level+1)); &#x2F;&#x2F; cout &lt;&lt; &quot;--&quot;&lt;&lt; w&lt;&lt;&quot; &quot;; &#125; &#x2F;&#x2F;cout &lt;&lt; endl; &#125;&#125;int main()&#123; memset(G, 0, sizeof(G)); int M, L,tmp; cin &gt;&gt; M &gt;&gt; L; for (int i &#x3D; 1; i &lt;&#x3D; M; i++) &#123; cin &gt;&gt; tmp; for (int j &#x3D; 1; j &lt;&#x3D; tmp; j++) &#123; int x; cin &gt;&gt; x; G[x].push_back(Edge&#123; x,i &#125;); &#125; &#125; cin &gt;&gt; tmp; for (int i &#x3D; 0; i &lt; tmp; i++) &#123; int a; cin &gt;&gt; a; init(); BFS(a, L); cout &lt;&lt; num[a]; if (i !&#x3D; tmp - 1)cout &lt;&lt; endl; &#125; return 0;&#125; 心得这道题是单向无权图–&gt;BFS 题目编号从1-N；建图应该从1到N方便 记录BFS遍历图的层数，在结点结构体中添加层数信息。在BFS中更新。 BFS跟Dijkstra的区别：BFS只要访问到邻接点，邻接点就要被收录而不用再通过邻接点去做松弛操作更新它的邻接点的最小路径","comments":true,"categories":[{"name":"pat","slug":"pat","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/pat/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/BFS/"},{"name":"BFS如何记录层数","slug":"BFS如何记录层数","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/BFS%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E5%B1%82%E6%95%B0/"}]},{"title":"Markdown语法","date":"2020-02-24T04:21:50.588Z","path":"2020/02/24/markdown语法/","text":"12345678910111213141516&lt;div style&#x3D;&#39;display: none&#39;&gt;哈哈我是注释，不会在浏览器中显示。&lt;&#x2F;div&gt;- 标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 &lt;!--最多6级标题--&gt;- 任务列表- [ ] 任务一 未做任务 &#96;- + 空格 + [ ]&#96;- [x] 任务二 已做任务 &#96;- + 空格 + [x]&#96;- 哈哈我是注释，不会在浏览器中显示。 标题 一级标题二级标题三级标题四级标题五级标题六级标题 任务列表 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 1234567【1】 &amp;emsp;或&amp;#8195; &#x2F;&#x2F;全角【2】 &amp;ensp;或&amp;#8194; &#x2F;&#x2F;半角【3】 &amp;nbsp;或&amp;#160; &#x2F;&#x2F;半角之半角&lt;center&gt;行中心对齐&lt;&#x2F;center&gt;&lt;p align&#x3D;&quot;left&quot;&gt;行左对齐&lt;&#x2F;p&gt;&lt;p align&#x3D;&quot;right&quot;&gt;行右对齐&lt;&#x2F;p&gt; 【1】 &emsp;或&#8195; //全角【2】 &ensp;或&#8194; //半角【3】 &nbsp;或&#160; //半角之半角 行中心对齐 行左对齐 行右对齐 1234567891011&gt;*斜体*或_斜体_&gt;**粗体**&gt;***加粗斜体***&gt;~~删除线~~&gt;++下划线++&gt;&#x3D;&#x3D;背景高亮&#x3D;&#x3D; 斜体或斜体 粗体 加粗斜体 删除线 ++下划线++ ==背景高亮== 123456&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;&lt;font color&#x3D;#0099ff size&#x3D;12 face&#x3D;&quot;黑体&quot;&gt;黑体&lt;&#x2F;font&gt;&lt;font color&#x3D;gray size&#x3D;5&gt;gray&lt;&#x2F;font&gt;&lt;font color&#x3D;#00ffff size&#x3D;3&gt;null&lt;&#x2F;font&gt; 我是黑体字我是微软雅黑我是华文彩云黑体graynull 123456* 无序列表项 一+ 无序列表项 二- 无序列表项 三1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 无序列表项 一 无序列表项 二 无序列表项 三 有序列表项 一 有序列表项 二 有序列表项 三 123456789101112131415161718192021222324252627&lt;center&gt; &lt;!--开始居中对齐--&gt;![GitHub set up](http:&#x2F;&#x2F;zh.mweb.im&#x2F;asset&#x2F;img&#x2F;set-up-git.gif &quot;图片Title&quot;)![图片Alt](图片地址 &quot;图片Title&quot;)&lt;&#x2F;center&gt; &lt;!--结束居中对齐--&gt;&gt;- 超链接&gt;欢迎阅读 [择势勤](https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;16d77399d3a7 &quot;择势勤&quot;)&gt;网站[Google][1]、[Leanote][2]。[1]:http:&#x2F;&#x2F;www.google.com [2]:http:&#x2F;&#x2F;www.leanote.com- 注脚使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言- 在段落填写[TOC]以显示全文内容的目录结构[TOC] 超链接 欢迎阅读 择势勤 网站Google、Leanote。 注脚使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2]。 [^2]:HyperText Markup Language 超文本标记语言 在段落填写[TOC]以显示全文内容的目录结构[TOC] 12345include &lt;stdio.h&gt;int main(void)&#123;printf(&quot;Hello world\\n&quot;);&#125; 学号 姓名 序号 小明明 男 5 小红 女 79 小陆 男 192 摘自 简书","comments":true,"categories":[{"name":"basic","slug":"basic","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/basic/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/markdown/"}]},{"title":"Samba服务器","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/SAMBA服务器/","text":"samba的功能 共享文件和打印机服务 身份认证，提供不同身份用户的个别数据 进行window网络上的主机名解析 可以进行设备的共享 samba常见的应用 1利用软件直接剪辑www主机上面的网页数据 做成可以直接连接的文件服务器 打印机服务器 samba使用的NetBIOS通信协议 samba使用的daemons nmbd 这个daemon用来管理工作组，NetBIOS Name 等解析。主要利用UDP协议开启port137，138来负责名称解析的任务 smbd 这个daemon主要功能用来管理samba主机共享的目录，文件与打印机等。利用可靠的TCP协议来传输数据，开放的端口139及445 连接模式（Peer/Peer（对等模式），Domain model（主控模式））","comments":true,"categories":[{"name":"网络","slug":"网络","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"萌新","slug":"萌新","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E8%90%8C%E6%96%B0/"}]},{"title":"Hello World","date":"2020-01-31T16:00:00.000Z","path":"2020/02/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"萌新","slug":"萌新","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E8%90%8C%E6%96%B0/"}]}]}