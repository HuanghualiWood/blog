{"meta":{"title":"Hexo","subtitle":"","description":"","author":"minhao","url":"https://blog-1e57ca-1302405762.tcloudbaseapp.com","root":"/"},"pages":[{}],"posts":[{"title":"Hello World","date":"2020-06-13T02:46:15.029Z","path":"2020/06/13/c语言学习/","text":"c语言 >====== >7/9/2018 4:12:24 PM >>*** >>**第三章 数据和C** >>*** >>**1.** **e （数学科学记数法）** >用指数表示法显示数字，以 E+n 替换部分数字，其中 E（代表指数）表示将前面的数字乘以 10 的 n 次幂。例如，用 2 位小数的“科学记数”格式表示 12345678901，结果为 1.23E+10，即 1.23 乘以 10 的 10 次幂。您可以指定要使用的小数位数。 >> >*** >>**2.** **浮点数** >>[（浮点数网站详解）](https://blog.csdn.net/rjs123/article/details/7976499): >>浮点数，是指小数点在数据中的位置可以左右移动的数据。它通常被表示成： N = M* RE 这里的M(Mantissa)被称为浮点数的尾数，R(Radix)被称为阶码的基数，E(Exponent)被称为阶的阶码。 1.2345 × 102，其中 1.2345 为尾数，10为基数，2 为指数 >>尾数实际上是有 >>尾数有时也称为有效数字（Significand） >> >>**为什单精度实际的指数表达范围在-127~127之间**其中单精度数为 8 位，双精度数为 11 位。以单精度数为例，8 位的指数为可以表达 0 到 255 之间的 255 个指数值。但是，指数可以为正数，也可以为负数。为了处理负指数的情况，实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值，单精度数的偏差值为 127，而双精度数的偏差值为 1023。比如，单精度的实际指数值 0 在指数域中将保存为 127；而保存在指数域中的 64 则表示实际的指数值 -63。偏差的引入使得对于单精度数，实际可以表达的指数值的范围就变成-127 到128 之间（包含两端）。我们不久还将看到，实际的指数值-127（保存为全 0）以及 +128（保存为全 1）保留用作特殊值的处理。这样，实际可以表达的有效指数范围就在 -127 和 127 之间。在本文中，最小指数和最大指数分别用 emin 和 emax 来表达 >> >>计算机中一般规定R为2、8或16、是一个确定的常数，不需要在浮点数中明确表示出来。因此，要表示浮点数，一是要给出尾数M的值，通常用定点小数形式表示，它决定了浮点数的表示精度，即可以给出的有效数字的位数。二是要给出阶码，通常用整数形式表示，它指出的是小数点在数据中的位置，决定了浮点数的表示范围。浮点数也要有符号位。 >>floating-point 差不多可以和数学中的实数概念相对应 >>浮点数和整数的区别： >>![浮点数](https://s4.51cto.com/oss/201711/09/1afceb11e5df90996dddd0060587c3cd.jpg) >> 符号位 阶码 尾数 总位数 >> 短浮点数 1 8 23 32 >> 长浮点数 1 11 52 64 >> 临时浮点数 1 15 64 80 >> 对短浮点数和长浮点数，当其尾数不为0值时，其最高一位必定为1，在将这样的浮点数写入内存或磁盘时，不必给出该位，可左移一位去掉它，这种处理技术称为隐藏位技术，目的是用同样多位的尾数能多保存一位二进制位。在将浮点数取回运算器执行运算时，再恢复该隐藏位的值。对临时浮点数，不使用隐藏位技术。 >> **浮点数的运算法则**[百度](https://baike.baidu.com/item/%E7%A7%BB%E7%A0%81/10165919?fr=aladdin) >> **[补充补码，反码,移码](https://www.cnblogs.com/sunfan1988/p/3850242.html)***【详细】 >>源码、反码、补码、移码在计算机中是怎么运算的？ 数值有正负之分,计算机就用一个数的最高位存放符号(0为正,1为负).这就是机器数的原码了.假设机器能处理的位数为8.即字长为1byte,原码能表示数值的范围为 127~（-127） 另外，我们需要知道，在计算机中都是以补码的储存负数的（正数的补码等于他本身，所以也可以理解为计算机储存的是补码），那么我们从源码->>>反码的过程其实是为了计算补码的一个计算的过程。 运算过程：原码-&gt;反码-&gt;补码-&gt;移码 原码 :二进制（开头第一个表示符号0正1负） 反码 ：在原码的基础上，符号位不动，其他位取反 —注意，任何正数的源码=反码=补码，而负数都是通过补码表示的。补码 ：在反码的基础上，运算+1 —注意，任何正数的源码=反码=补码，&lt;&gt;而负数都是通过补码表示的。 用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。引入移码的目的：用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。而实际上这个数是无限接近于零的。那么我们就需要取出其中的 “-0” 值作为机器零。 公式：两数补码的和==两数和的补码。 移码 ：在补码的基础上，符号位取反 负数的存储：c语言中，负数以整数的补码存储 101011（二进制）--> 原码 00101011 --> 反码 01010100 --> 补码 01010101--> 移码 11010101 **二进制运算** 逢二进一，结果写0 **例题1用补码计算2-9** c语言数据类型 ## #include #include void main() { /*int x =2; printf(\"dec=%d;octal=%o;hex=%x\\n\",x,x,x);//显示八进制十六进制 printf(\"dec=%d;octal=%#o;hex=%#x\\n\",x,x,x);//%o %x /*****整数溢出******* int i=2147483647; unsigned int j=4294967295; printf(\"%d;%d;%d\\n\",i,i+1,i+2); printf(\"%u;%u;%u\\n\\n\\n\",j,j+1,j+2);//无符号整型达到最大值时，将溢出到起始点；而int型的起始点是-2147483647 /*******打印short long,longlong,和unsigned类型数********* //使用修饰符h可以显示一个较长的整数被截成short类型的样子 //在传递参数数时，c会自动将short类型的值转换为int类型。int类型被认为是计算机处理起来最方便有效的的整数类型 unsigned int un =3000000000; short end=200; long big=65537; long long verybig=12345678908642; printf(\"un=%u and not un=%d\\n\",un,un); printf(\"end=%hd and not %d\\n\",end,end); printf(\"big=%ld and not %hd\\n\",big,big); printf(\"verybig=%lld and not %ld\\n\",verybig,verybig); /****非打印字符*** //一些动作描述是打印不出来的例如退格，换行，走纸让终端铃响。一，使用ASCⅡ码二，使用转义序列（escape sequence） char beep='\\007'; printf(\"hello\\a\\n\");//发出警报声 /***可移植的指数类型inttypes.h*** //C99标准提供了一些串宏来打印这些可移植类型例如inttype.h头文件将定义串PRId16表示打印16位有符号值 int16_t me16; me16=4593; printf(\"me16=%hd\\n\",me16); printf(\"me16=%\"PRId16\"\\n\",me16); /***float double 和longdouble型***/ //浮点常量：使用f或F后缀使编译器把浮点常量当作float型比如2.3f和9.11E9F //*用%e打印指数计数法的数字 float double型都用%f，%e，%a说明符打印* float aboat =32000.0; double abet =2.14e9; long double dip =5.32e-5; printf(\"%f %e\\n\",aboat,aboat); printf(\"%f %e\\n\",abet,abet); printf(\"%f %e\\n\",dip,dip);//??? //*浮点值的上溢和下溢 float toobig=3.4e38*100.0f; printf(\"%e\",toobig); //练习2,输入一个ascⅡ码，然后输出相应的字符 int a; char ch; printf(\"输入一个整数\\n\"); scanf(\"%d\",&a); ch=a; printf(\"%c\\n\",ch); //练习3，输入一个字母，输出其ascⅡ码 getchar(); int b; char fi; printf(\"输入一个小写字母\"); scanf(\"%c\",&fi); b=fi-32; printf(\"ascⅡ为%d\",b); getchar(); */ //练习3读入一个浮点数，分别以小数形式和指数形式输出 float c; scanf(\"%f\\n\",&c); printf(\"%e\\n%0.1f\\n\",c,c); return 0; } 第四章字符串和格式化输入/输出 === >*** >- strlen() >- const >- print() 和 scanf() >- 使用c预处理器#define指令和ANSIC的const修饰符创建符号常量 使用%s的scanf()只会把第一个字符串读入 C使用读取输入函数 （例如gets（））来处理一般的字符串 常量和C预处理器格式：#define 其次常量一般大写4.3.1 const修饰符 C90新增了一种创建符号常量的第二种方法。使用const把一个变量声明转换成常量const int MONTHS=12; 4.3.2**系统定义的明显常量** 头文件limits.h和float.h 1.sizeof()运算符:以字节为单位给出数据的大小 2.strlen（）函数：以字符为单位给出字符串的长度/string.h/提供函数原型 printf函数 printf格式说明符p71 说明符 功能 %d 有符号十进制整形 %f 单精度浮点数，小数点后保留6位 %lf 双浮点精度 %c 输出一个字符 %s 按实际输出字符串 %e 按指数格式输出 %g 按输出较小原则，自动按%f或%e原则输出浮点数 %o 八进制数 %x 十进制数 %p 输出指针的地址 printf()说明修饰符 修饰符 功能 - 左对齐 :%-20s: + 显示正负号 :%+6.2f 空格 有符号的值若为正，则显示是带前导空格（不现实正号），若为扶，则显示符号 # 显示数据格式 0 用前导零而不是空格填充字段宽度，如果出现-标志或者指定了精度，则忽略该标志:%010d %08.3f .digits 精度 ：%5.2f（字段宽度为五个字符，五位有效数字，保留2位小数） （易混）ll unsigned long long int %8llu t 和整数转换说明符一起使用，表示一个ptrdiff_t值（与两个指针之间的差相对应的类型）%td %12ti z 和整数说明符一起使用，表示一个size_t值（sizeof返回的类型）%zd %12zx printf()分割字符串（字符串较长时）的三种方法 1.多个printf（）语句2.使用反斜杠\\和回车键组合来结束第一行3.采用字符串连接的方法 scanf()函数转换说明符和转换修饰符与printf（）类似p79 **scanf()的返回值**（后面讲到） 如果它没有读取任何项目（当它期望一个数字而你却键入了一个非数字字符串时就会发生这种情况），scanf()会返回值0.当它检测到“文件结尾”（end of file），它返回EOF（EOF是stdio.h中定义的特殊值） 【重点】 4.4.6printf()和scanf()的*的修饰符 printf()*用法：使用*代替数字，使用可变参数确定字段宽度的值 scanf()*的作用：使函数跳过相应的输入项目 如果程序需要读取一个文件中某个特定的列（该文件的数据以统一的列排列），那么该功能将非常有用 //第四章练习 #include #include #include int main(void) { /* //2.4输入名字，在比名字宽三个字符发字段内打印它 char ming[40],xing[40]; printf(\"输入名字\"); scanf(\"%s\",&ming); int a=strlen(ming); printf(\"\\\"%s\\\"\\n\",ming); printf(\"\\\"%20s\\\"\\n\",ming); printf(\"\\\"%*s\\\"\\n\",a+3,ming);//程序清单4.16使用可变宽度的输出字段 //3. float a=21.3; printf(\"The input %0.1f is%0.1e\\n\",a,a); //5 输入名字，在第一行打印输入的姓名，在下一行打印每个名字中字母的个数，把字母个数与相应名字的结尾对齐 char xing[40],name[40]; printf(\"分别输入姓氏名字\\n\"); scanf(\"%s\",&xing); getchar(); scanf(\"%s\",&name); printf(\"%s\\t\",xing); printf(\"%s\\n\",name); printf(\"%*d\\t%*d\\n\",strlen(xing),strlen(xing),strlen(name),strlen(name)); */ //6. double num1=1.0/3.0; float num2=1.0/3.0; printf(\"%.4f,%.12f,%.16f\\n\",num1,num1,num1); printf(\"%.4f,%.12f,%.16f\\n\",num2,num2,num2); printf(\"%d %d\\n\",FLT_DIG,DBL_DIG); return 0; } 第五章运算符，表达式和语句 如何编写带有参数的函数 typedef 复合语句，自动类型和类型指派 1.基本运算符：=+-/2.其它运算符：* sizeof运算符和size_t类型 取模运算符%：modulus operater用于整数运算。该运算计算出用它右边的整数去除它左边的整数得到的余数。如果第一个操作数为负数，那么得到的模也为负数 增量运算符和减量运算符:++ –前缀q=++a：a先自增1然后赋值给q后缀q=a++:a先赋值给q然后再自增1 //先使用n然后将它的值增加 优先级() ++ –5.4副作用和顺序点 副作用：是对数据对象或文件的修改 例如states=50的副作用是将变量的的值设置为50.跟赋值运算符一样，增量减量运算符也有副作用，它们主要由于副作用而被应用顺序点：是程序执行中的一点，在该点处，所有副作用都在进入下一步前被计算表达式是运算符和操作数的组合语句分为简单语句和复合语句或代码块block5.5类型转换程序清单5.14 指派运算符：作用避免自动类型转换，避免降级 int mice; mice=1.6+1.7; mice=(int)1.6+(int)1.7 5.6带有参数的函数 #include void pound(int n); //ANSI风格的原型 int main(void) { int times=5; char ch='!'; float f=6.0; pound(times); pound(ch); pound((int)f); return 0; } void pound(int n) { while(n-->0) printf(\"#\"); printf(\"\\n\"); } 形式参数和实际参数+ 形参：全称为“形式参数”是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。+ 实参：可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。 #include const float f=1.8 , b=32.0; void pfh(int n); void temp(float a); pfh(int n) { int a; a=n*n; printf(\"%d\\n\",a); } temp(a) { float t=f*a+b; float k=t+273.16; printf(\"Celsius=%.2f\\n\",t); printf(\"kelvin=%.2f\\n\",k); } int main(void) { /*int num=1; while(num判断一个数是不是素数. >/* divisors.c -- 使用嵌套if显示一个数的约数*/ >#include >#include >int main(void) { unsigned long num; // 要检查的数 unsigned long div; // 可能的约数 bool isPrime; // 素数的标志 printf(\"Please enter an integer for analysis: \"); printf(\"Enter q to quit/\\n\"); while (scanf(\"%lu\",&num)==1) { for (div = 2, isPrime = true; (div*div) &gt;逻辑运算符&amp;&amp; &gt;!(4&gt;7) 为真 :4不大于7 #include #include // 为isspace()提供函数原型 #include // 为bool\\true和false提供定义 #define STOP '|' int main(void) { char c; // 读入字符 char prev; // 前一个读入字符 long n_chars = 0L; // 字符数 int n_lines = 0; // 行数 int n_words = 0; // 单词数 int p_lines = 0; // 不完整的行数 bool inword = false; // 如果C在一个单词中，则inword 等于true printf(\"Enter text to be analyzed(| to terminate):\\n\"); prev = '\\n'; // 用于识别完整的行 // while ((c = getchar()!= STOP)) // 不正确，只读到一个word,并且编译没有错误. while ((c = getchar())!= STOP) { n_chars++; // 统计字符 if (c == '\\n') n_lines++; //统计行数 if (!isspace(c) && !inword) { inword = true; // 开始一个新单词 n_words++; // 统计单词 } if (isspace(c) && inword) inword = false; // 到达单词尾部 prev = c; // 保存字符值 } if (prev != '\\n') p_lines = 1; printf(\"characters = %ld, words = %d, lines = %d， \", n_chars, n_words, n_lines); printf(\"partial lines = %d\\n\", p_lines); getchar(); getchar(); return(0); } 条件运算符x=(y&lt;0)? -y;y;如果y小于0，那么x=-y，否则x=y循环辅助手段：continue 和break #include #include #include #include int main(void) { /*const int FIRST_OZ=37; const int NEXT_OZ=23; int ounces,cost; printf(\"ounces cost\\n\"); for(ounces=1,cost=FIRST_OZ;ounces=2) to_binary(n/2); putchar('0'+r); return; } > 9.6改变调用函数中的变量 :排序交换变量temp=a;//错误的交换变量a=b;b=temp 指针 void interchange(int * , int*) 地址运算符： &amp; 当后跟一个变量名，给出地址 间接运算符： * 当后跟一个指针名或地址时，给出存储在被指向地址中的数值,优先级和++一样，结合时是从左向右结合的 变量：名称，地址，数值 一个变量一般有两张属性：变量名和数值。程序被编译和加载后，同一个变量在计算机中的两个属性是地址和数值。变量的地址可以被看作是计算机中变量的名称 数值传递：参数用于把调用函数中的数值传给被调函数。 当需要在某函数中直接操作其调用函数的变量时，可以使用指针作为参数。同时，指数参数也可以用来把多个数值返回到调用函数中（return只能返回一个）； *p理解：*p是指向的地址中的值，而p本身是指向类型的指针，p的值是一个地址 break函数是指提前结束循环、接着执行循环下面的语句，不能用于循环语句和switch语句之外的任何其他语句中。 >*** >第十章数组和指针 >=== >[C语言中指针\\*p[N] ,( \\*P)[N]) 及\\**p的区别](https://www.cnblogs.com/kuangsyx/p/7496454.html) 创建数组的几种方法 1.预估最大数据个数，按此数值定义数组空间，完成数据输入 #define MAX_NUM 1000 int a[MAX_NUM]; 这种方法定义数组，方便，安全。缺陷是数组空间大小受系统限制，数据太多了，就不能这样定义了。 运行时，确定输入数据个数，采用指针动态定义数组，或C99提供的动态数组的方法实现 int *p; int n; printf (“input n: “); scanf(“%d”, &amp;n); //输入数据个数 （1）p=(int )malloc(nsizeof(int) ); //动态分配空间 不用了记得要释放free(p) 或 （2）int pa[n] ; //C99支持的动态数组，按n值动态定义数组 还可以采用指针动态扩充数组方法：先分配一定的大小，当数组不够&gt;用时，再重新分配空间。 #define INIT_LEN 100 预分配空间 #define INCE_LEN 10 每次扩充空间 int *p=（int *) malloc(INIT_LEN *sizeof(int) ); int length=INIT_LEN ; 不足时， length+=INCE_LEN ; p=(int *)realloc( p, length) ; //扩充空间 数组与指针的差别p286： 1.两者都可以使用数组符号2.都可以使用指针加法3.只有指针可以使用增量运算 字符串数组(下一章笔记整理到这)： char *mytal[LIM]={“ “,” “,” “}char mytal2[LIM][LINLIM]; 指针数组建立的是一个不规则的数组，每一行的长度由初始化字符串决定 这两个数组的类型也不同，mytal是一个指向char的指针的数组，而mytal2是一个char数组的数组 #include int main(int argc, char* argv[]) { int i, j; int (*p1)[3], *p2[3], **p3; int b[3][3]; for(i=0; i2：void (*b[10]) (void (*)()); >3. double(*)() (*pa)[9]; 答案与分析： 对复杂变量建立一个类型别名的方法很简单，你只要在传统的变量声明表达式里 用类型名替代变量名，然后把关键字typedef加在该语句的开头就行了。 >1：int *(*a[5])(int, char*); //pFun是我们建的一个类型别名 typedef int *(*pFun)(int, char*); //使用定义的新类型来声明对象，等价于int* (*a[5])(int, char*); pFun a[5]; >2：void (*b[10]) (void (*)() ); // 此蓝色部分为个人理解，未找到原文出处 //首先为上面表达式蓝色部分声明一个新类型 typedef void (*pFunParam)(); //整体声明一个新类型 typedef void (*pFun)(pFunParam); //使用定义的新类型来声明对象，等价于void (*b[10]) (void (*)()); pFun b[10]; >3. double(* (*pa)[9] )(); // 此蓝色部分为个人理解，未找到原文出处 //首先为上面表达式蓝色部分声明一个新类型 typedef double(*pFun)(); //整体声明一个新类型 typedef pFun (*pFunParam)[9]; //使用定义的新类型来声明对象，等价于double(*(*pa)[9])(); pFunParam pa; 14.13奇特的指针 |10章做过部分笔记 ，看括号优先级 |:-:|int board[][] |int数组的数组int ptr|指向int的指针的指针int *risks[10]|指针数组，10个元素，每个元素是一个指向int的指针int(rusks)[10]|数组指针，一个指针指向具有十个元素的数组int oof[3][4]|指针数组，二维int (* uuf)[3][4]|二位数组指针int(* uof[3]) [4]|具有4个元素的int数组的指针 14.14函数指针 函数具有可赋值给指针的物理内存地址，一个函数的函数名就是一个指针，它指向函数的代码。一个函数的地址是该函数的进入点，也是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。 不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。 定义形式： 类型 （*指针变量名）（参数列表）； 例如： int (*p)(int i,int j); #include #include using namespace std; int func() { cout < \"my name is zyh_helen\" < endl; return 0; } int main() { int(*p)() = func; //函数指针初始化方式1 int(*p1)() = &func; //函数指针初始化方式2 func();//函数调用方式1 (*p)();//函数调用方式2 p(); //函数调用方式3 system(\"pause\"); return 0; }","comments":true,"categories":[],"tags":[{"name":"c base","slug":"c-base","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/c-base/"}]},{"title":"Ps","date":"2020-06-13T02:01:11.000Z","path":"2020/06/13/ps/","text":"ps素描方法:1去色，查找边缘，成角的线条，图册混合模式，颜色减淡2去色，反相，最小值，混合选项，创建空白图层，选区羽化，添加蒙版，添加杂色，填充rgb240x3的图层蒙版：*图层蒙版*剪贴蒙版 Crtl+Shift+G矢量蒙版快速蒙版通道：颜色通道:存储颜色专色通道 增强画质第一，先打开原图，双击解锁。第二，CTRL+J创建副本养成好习惯。对副本模式选择“亮度”第三，选择“滤镜”菜单下的“锐化—USM锐化”命令，在设置窗口中适当调节一下锐化参数，根据你原图模糊的情况来调节，第四，经过第三步，为照片清晰大致做了个基础。接着选择“图像”菜单下“模式—LAB颜色”命令，在弹出的窗口中选择“拼合”图层确定。在LAB模式下，再创建副本。第六， 在“通道”面板中看到图层通道上有了“明度”通道，选定这个通道，再使用“滤镜”菜单的“锐化—USM锐化”命令，设置好锐化参数将这个通道锐化处第七，返回图层面板，把副本图层的模式修改为“柔光”，调节透明度为30%。看看此时的图像不仅画面更清晰，色彩也更加绚丽了。（这部可根据自己的照片情况增删）","comments":true,"categories":[],"tags":[{"name":"ps note","slug":"ps-note","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/ps-note/"}]},{"title":"图的遍历/最短路径","date":"2020-06-13T01:58:01.058Z","path":"2020/06/13/图的遍历&最短路径/","text":"一.DFS DFS求连通分量的个数 什么是连通分量？ 连通分量个数就是使用DFS的次数 二.BFS 宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 松弛函数(算法导论里的东西) 对边集合 E 中任意边，以 w(u,v) 表示顶点 u 出发到顶点 v 的边的权值，以 d[v] 表示当前从起点 s 到顶点 v 的路径权值 若存在边 w(u,v)，使得： 所以松弛函数的作用，就是判断是否经过某个顶点，或者说经过某条边，可以缩短起点到终点的路径权值。 为什么将缩短距离的操作称之为“松弛”，不妨理解为，选择某种方式后，到达目的的总代价降低了。什么名字无关紧要，不必纠结。 堆优化优化Dijkstra","comments":true,"categories":[],"tags":[{"name":"图","slug":"图","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E5%9B%BE/"}]},{"title":"1","date":"2020-06-13T01:55:48.000Z","path":"2020/06/13/1/","text":"title: c++队列堆栈 tags: “c++base” catogories: - pta 添加库queue 1234#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std; 五个操作q.push()q.pop()q.front()q.back()q.empty() 2.bool empty() const 判断队列是否为空 c.empty(); 3.size_type size() const 返回队列中元素个数 c.size() 4.value_type&amp; front(); const value_type&amp; front() const; 返回队列中第一个元素,即最后插入到队列中的那个元素 c.front(); 5.value_type&amp; back(); const value_type&amp; back() const; 返回队列中最后一个元素，即最先入队的那个元素 c.back(); 6.void push (const value_type&amp; val) 插入一个新元素在队尾 c.push(value) 7.void emplace(Args&amp;&amp; args) 插入一个新的元素在队尾 c.emplace(args); 8.void pop() 移除队首元素 c.pop(); 9.void swap(queue&amp; x) 交换两个队列的内容 c.swap(d); 10.与stack和vector一样，重载了几个运算符:== != &lt; &lt;= &gt; &gt;=","comments":true,"categories":[],"tags":[]},{"title":"C++队列堆栈stl","date":"2020-06-13T01:54:03.000Z","path":"2020/06/13/c++队列堆栈stl/","text":"title: c++队列堆栈 tags: “c++base” catogories: - pta 添加库queue 1234#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std; 五个操作q.push()q.pop()q.front()q.back()q.empty() 2.bool empty() const 判断队列是否为空 c.empty(); 3.size_type size() const 返回队列中元素个数 c.size() 4.value_type&amp; front(); const value_type&amp; front() const; 返回队列中第一个元素,即最后插入到队列中的那个元素 c.front(); 5.value_type&amp; back(); const value_type&amp; back() const; 返回队列中最后一个元素，即最先入队的那个元素 c.back(); 6.void push (const value_type&amp; val) 插入一个新元素在队尾 c.push(value) 7.void emplace(Args&amp;&amp; args) 插入一个新的元素在队尾 c.emplace(args); 8.void pop() 移除队首元素 c.pop(); 9.void swap(queue&amp; x) 交换两个队列的内容 c.swap(d); 10.与stack和vector一样，重载了几个运算符:== != &lt; &lt;= &gt; &gt;=","comments":true,"categories":[],"tags":[]},{"title":"数电","date":"2020-06-11T16:41:57.000Z","path":"2020/06/12/数电/","text":"# 数电笔记","comments":true,"categories":[],"tags":[{"name":"数电","slug":"数电","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E6%95%B0%E7%94%B5/"}]},{"title":"PT2262解码原理","date":"2020-06-09T16:00:00.000Z","path":"2020/06/10/test/","text":"# PT2262解码原理","comments":true,"categories":[{"name":"单片机","slug":"单片机","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"解码","slug":"解码","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E8%A7%A3%E7%A0%81/"}]},{"title":"线性表习题","date":"2020-06-09T16:00:00.000Z","path":"2020/06/10/线性表习题/","text":"线性表习题123456789&#x2F;*2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素*&#x2F;&#x2F;*2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）*&#x2F;&#x2F;*2-2-8 将数组中两个顺序表的位置置换*&#x2F;&#x2F;*2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点*&#x2F;&#x2F;*2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间*&#x2F;&#x2F;*2-3-3 L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值*&#x2F;&#x2F;*2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）*&#x2F;&#x2F;*2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)*&#x2F;&#x2F;*2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序*&#x2F; 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;cstdio&gt;#define Elemtype int&#x2F;&#x2F;顺序存储结构typedef struct &#123; Elemtype data[50] &#x3D; &#123; 4, 3, 3, 4, 2, 4, 5, 6, 6, 6 &#125;; Elemtype length;&#125;Sqlist;Sqlist L;&#x2F;&#x2F;链式存储结构typedef struct LNode &#123; Elemtype data; struct LNode* next;&#125;LNode,*Linklist;&#x2F;*------------建立链表，注意双指针以及辅助指针的使用-------------*&#x2F;&#x2F;&#x2F;指针的引用void Linklist_init(Linklist &amp;L) &#123; L &#x3D; (Linklist)malloc(sizeof(LNode)); LNode* tmp, * r &#x3D; L;&#x2F;&#x2F;必须要一个辅助指针*r L-&gt;data &#x3D; -1; L-&gt;next &#x3D; NULL; for (int i &#x3D; 0; i &lt; 10; i++) &#123; tmp &#x3D; (LNode*)malloc(sizeof(LNode)); if (tmp !&#x3D; NULL) &#123; tmp-&gt;data &#x3D; i ; r-&gt;next &#x3D; tmp; r &#x3D; tmp; &#125; &#125; r-&gt;next &#x3D; NULL;&#125;&#x2F;&#x2F;二级指针，传入实参地址void Linklist_init2(LNode ** L) &#123; *L &#x3D; (LNode*)malloc(sizeof(LNode)); LNode* tmp, * r &#x3D; *L; r-&gt;data &#x3D; -1; r-&gt;next &#x3D; NULL; for (int i &#x3D; 0; i &lt; 20; i++) &#123; tmp &#x3D; (LNode*)malloc(sizeof(LNode)); if (tmp !&#x3D; NULL) &#123; tmp-&gt;data &#x3D; i % 5; r-&gt;next &#x3D; tmp; r &#x3D; tmp; &#125; &#125; r-&gt;next &#x3D; NULL;&#125;&#x2F;&#x2F;return返回Linklist Linklist_init3(void) &#123; Linklist L &#x3D; (Linklist)malloc(sizeof(LNode)); LNode* tmp, * r &#x3D; L; r-&gt;data &#x3D; -1; r-&gt;next &#x3D; NULL; for (int i &#x3D; 0; i &lt; 10; i++) &#123; tmp &#x3D; (LNode*)malloc(sizeof(LNode)); if (tmp !&#x3D; NULL) &#123; tmp-&gt;data &#x3D; i % 6; r-&gt;next &#x3D; tmp; r &#x3D; tmp; &#125; &#125; r-&gt;next &#x3D; NULL; return L;&#125; /2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素/ 123456789101112131415161718void delet_x(Sqlist &amp;L, int value) &#123; int i&#x3D;0, k&#x3D;0, j&#x3D;0; int length &#x3D; L.length; j &#x3D; 0; while (i&lt;L.length) &#123; if (k !&#x3D; 0) &#123; L.data[i-k] &#x3D; L.data[i]; &#125; if (L.data[i] &#x3D;&#x3D; value) &#123; k++; length--; &#125; i++; &#125; for (i &#x3D; length; i &lt; L.length; i++) L.data[i] &#x3D; 0; L.length &#x3D; length;&#125; /2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）///理解错误，做成了，删除线性表范围在s和t之间的值为x的元素 123456789101112131415161718bool delte_x_at(Sqlist &amp;L, int s, int t, int value) &#123; if (s &gt;&#x3D; t)return false; if (L.length &lt;&#x3D; 0)return false; int i&#x3D;0, j&#x3D;0,k&#x3D;0; for (i &#x3D; s+1; i &lt; t; i++) &#123; if (L.data[i] !&#x3D; value) &#123; L.data[k+s+1] &#x3D; L.data[i]; k++; &#125; &#125; j &#x3D; t - s - 1 - k; for (i &#x3D; t; i &lt; L.length; i++) L.data[i - j] &#x3D; L.data[i]; for (i &#x3D;0; i &lt;j; i++) L.data[L.length - 1 - i] &#x3D; 0; L.length &#x3D; L.length - (t - s - 1) + k; return true;&#125; /2-2-8 将数组中两个顺序表的位置置换/ 123456789101112131415161718### 逆置算法int arr[10] &#x3D; &#123; 1,2,3,4,5,6,1,2,3,4 &#125;;bool reverse(int arr[], int left, int right) &#123; if (left &gt; right)return false; int mid &#x3D; (left+right) &#x2F; 2; for (int i &#x3D; 0; i &lt;&#x3D; mid - left; i++) &#123; int tmp &#x3D; arr[i+left]; arr[i + left] &#x3D; arr[right - i]; arr[right - i] &#x3D; tmp; &#125; return true;&#125;bool Sqlist_rev(int arr[],int m, int n) &#123; reverse(arr, 0, m + n - 1); reverse(arr,0, n - 1); reverse(arr, n, m+n - 1); return true;&#125; /2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点/ 1234567891011bool Linklist_delele(Linklist&amp; L, int x) &#123; if (!L)return false; if (L-&gt;data &#x3D;&#x3D; x) &#123; LNode *q &#x3D; L; L &#x3D; L-&gt;next; free(q); Linklist_delele(L, x); &#125; Linklist_delele(L-&gt;next, x); return true;&#125; /2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间/ 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&#x2F;&#x2F;------------------------------------------------------void Linklist_del(Linklist &amp;L, Elemtype x) &#123; LNode *q, *p &#x3D; L-&gt;next, *pre &#x3D; L; while (p) &#123; if (p-&gt;data &#x3D;&#x3D; x) &#123; q &#x3D; p; p &#x3D; p-&gt;next;&#x2F;&#x2F;p还要往前移一个，和L的位置重合 pre-&gt;next &#x3D; p; free(q); printf(&quot;. &quot;); &#125; else &#123; pre &#x3D; p; p &#x3D; p-&gt;next; &#125; &#125;&#125;&#x2F;&#x2F;删除也可以传入一级指针,无需指针的引用void Linklist_del2(Linklist L, Elemtype x) &#123;&#x2F;&#x2F;L此时为形参，函数内生成L头结点的副本，不过指向的内容仍然 Linklist q, p &#x3D; L-&gt;next, pre &#x3D; L; &#x2F;&#x2F;是L。可以实现对L的删除。 while (p) &#123; if (p-&gt;data &#x3D;&#x3D; x) &#123; q &#x3D; p; p &#x3D; p-&gt;next; L-&gt;next &#x3D; p; free(q); printf(&quot;. &quot;); &#125; else &#123; pre &#x3D; p; p &#x3D; p-&gt;next; &#125; &#125;&#125;### 尾插法，删除特定值void Linklist_del3(Linklist &amp;L, Elemtype x) &#123; Linklist q, p &#x3D; L-&gt;next, r &#x3D; L; while (p) &#123; if (p-&gt;data !&#x3D; x) &#123; r-&gt;next&#x3D;p; r &#x3D; p; p&#x3D; p-&gt;next; &#125; else &#123; q &#x3D; p; p &#x3D; p-&gt;next; free(q); printf(&quot;. &quot;); &#125; &#125; r-&gt;next &#x3D; NULL;&#125; /2-3-3L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值/ 12345void Linklist_reverse(Linklist L) &#123; if(L-&gt;next) Linklist_reverse(L-&gt;next); printf(&quot;%d &quot;, L-&gt;data); &#125; /2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）/void dellmin4(Linklist &amp;L) { LNode* pre = L, * p = L-&gt;next; LNode* tmp=p,tmppre=pre ; while (p != NULL) { if (tmp-&gt;data &gt; p-&gt;data) { tmp = p; tmppre = pre; } pre = p; p = p-&gt;next; } tmppre-&gt;next = tmp-&gt;next; free(tmp);}/*2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)///xxxxxvoid Linklist_reverse2(Linklist &amp;L) { LNode *pre = NULL, *p = L-&gt;next, * tmp = L; while (p != NULL) { tmp = p-&gt;next; p-&gt;next = pre; pre = p; p = tmp; } L-&gt;next=pre;} 2头插法，精妙！void Linklist_reverse2_2(Linklist&amp; L) { LNode * first = L, * p = L-&gt;next, * tmp = L; while (p != NULL) { tmp = p-&gt;next; first = L-&gt;next; L-&gt;next = p; p-&gt;next = first; first-&gt;next = tmp; } }/2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序///不应该使用选择排序，选择最小结点操作很麻烦void Linklist_increaseorder(Linklist &amp;L) { LNode * p = L-&gt;next,*prep=L; LNode * q = NULL, * preq = L; LNode * min = p, * premin = p; while (p != NULL) { premin = min = p; preq = premin; q = p; printf(“p:%d “, p-&gt;data); while (q != NULL) { printf(“ q:%d “, q-&gt;data); if (q-&gt;data &lt; min-&gt;data) { premin = preq; min = q; printf(“%d”, min-&gt;data); } preq = q; q = q-&gt;next; } if (min-&gt;next != NULL) premin-&gt;next = min-&gt;next; else premin-&gt;next = NULL;//少了这一句链表编程循环队列-_-,死循环！！！！ if (min == p) { printf(“no min \\n “); prep = p; p = p-&gt;next; } else { prep-&gt;next = min; prep = min; min-&gt;next = p; } } }/链表的插入排序///比较恶心,优点难度，注重细节void Linklist_increaseorder2(Linklist&amp; L) { LNode * r , * p = L-&gt;next,*pre=L; r = p-&gt;next; p-&gt;next = NULL; //!!!!这里没有想到 构造只含一个数据结点的有序表。少了这个会死循环 p = r; while (p != NULL) { r = p-&gt;next; pre = L; while (pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;datadata) pre = pre-&gt;next; p-&gt;next = pre-&gt;next; pre-&gt;next = p; p = r; }} Linklist L1, L2, L3;void printL(Linklist L) { Linklist p = L-&gt;next; while (p != NULL) { printf(“ %d”, p-&gt;data); p = p-&gt;next; }} int main() { int n,tmp; //scanf(“%d”, &amp;n); //L.length = n; //for (int i = 0; i &lt; n; i++) { //scanf(“%d”, &amp;tmp); //L.data[i] = tmp; //} //delet_x(L, 4); //delte_x_at(L, 0, 7, 4); //for (int i = 0; i &lt; L.length; i++) { //printf(“%d “, L.data[i]); //} //sqlrev(arr, 6, 4); //Linklist_init(L1); //Linklist_init2(&amp;L1); L2 = Linklist_init3(); //Linklist_reverse(L-&gt;next); //Linklist_delele(L, 1); //Linklist_del(L,0); //Linklist_del2(L, 2); //Linklist_del3(L, 2); //dellmin4(L); //Linklist_reverse2(L1); //Linklist_increaseorder(L2); Linklist_increaseorder2(L2); printL(L2); return 0;}","comments":true,"categories":[{"name":"习题","slug":"习题","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/%E4%B9%A0%E9%A2%98/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表的操作","slug":"线性表的操作","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"Pat1030 Dijkstra","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/pat1030 Dijkstra 堆优化/","text":"A traveler’s map gives the distances between cities along the highways,together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.Input Specification: Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: City1 City2 Distance Costwhere the numbers are all integers no more than 500, and are separated by a space.Output Specification: For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.Sample Input: 1234567894 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20Sample Output:0 2 3 3 40 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define MAX 501struct Edge &#123; int from, to; int weight; int dist; Edge(int a,int b, int c,int d) : from(a),to(b), weight(c),dist(d) &#123;&#125;;&#125;;struct Node &#123; int dist, Nv; Node(int a, int b) :dist(a), Nv(b) &#123;&#125;; bool operator &lt; (const Node &amp;rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;int Nv, Ne;vector&lt;Edge&gt; G[MAX];priority_queue&lt;Node&gt; q;int collected[MAX];int dist[MAX],pre[MAX],cost[MAX];void init() &#123; memset(pre, -1, sizeof(pre)); memset(collected, 0, sizeof(collected)); memset(dist, INF, sizeof(dist));&#125;void dijkstra(int s,int dir) &#123; q.push(Node&#123; 0,s &#125;); dist[s] &#x3D; 0; q.push(Node&#123; 0,s &#125;); while (!q.empty()) &#123; Node front &#x3D; q.top(); q.pop(); int v &#x3D; front.Nv; if (v &#x3D;&#x3D; dir)break; for (Edge &amp;e:G[v]) &#123; int w &#x3D; e.to; if (collected[w]!&#x3D;false) continue; if (dist[v] + e.dist&lt;dist[w]) &#123; dist[w] &#x3D; e.dist + dist[v]; pre[w] &#x3D; v; cost[w] &#x3D; cost[v] + e.weight; q.push(Node&#123; dist[w],w&#125;); &#x2F;&#x2F;cout &lt;&lt; v&lt;&lt;&quot; &quot;&lt;&lt;w &lt;&lt; endl; &#125; else if (dist[v] + e.dist &#x3D;&#x3D; dist[w]) &#123; if (cost[v] + e.weight &lt; cost[w]) &#123; pre[w] &#x3D; v; cost[w] &#x3D; cost[v] + e.weight; &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); int N, M, C1, C2; cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2; for (int i &#x3D; 0, v, w, d, c; i &lt; M; i++) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; d &gt;&gt; c; G[v].push_back(Edge(v,w,c, d)); G[w].push_back(Edge(w,v,c, d)); &#125; dijkstra(C1,C2); vector&lt;int&gt; path; for (int i &#x3D; C2; i!&#x3D;-1;i&#x3D;pre[i]) &#123; path.push_back(i); &#125; for (int i &#x3D; path.size()-1; i &gt;&#x3D; 0; i--) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; cout &lt;&lt;dist[C2]&lt;&lt;&quot; &quot;&lt;&lt; cost[C2]; return 0;&#125; 笔记 堆优化 堆优化的主要思想就是使用一个优先队列（就是每次弹出的元素一定是整个队列中最小的元素）来代替最近距离的查找，用邻接表代替邻接矩阵，这样可以大幅度节约时间开销。","comments":true,"categories":[{"name":"pat","slug":"pat","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/pat/"}],"tags":[{"name":"Dijkstra堆优化","slug":"Dijkstra堆优化","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96/"},{"name":"优先队列","slug":"优先队列","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}]},{"title":"Pat1076 BFS","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/pat1076 BFS/","text":"Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format: M[i] user_list[i] where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K is given, followed by K UserID’s for query.Output Specification: For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.Sample Input: 1234567891011127 33 2 3 402 5 62 3 12 3 41 41 52 2 6Sample Output:45 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define MAX 1001struct Edge &#123; int from, to; Edge(int a, int b) :from(a), to(b) &#123;&#125;;&#125;;struct Node &#123; int nv,level;&#x2F;&#x2F;在结构体中添加路径层数 Node(int a, int b) :nv(a), level(b) &#123;&#125;;&#125;;vector&lt;Edge&gt; G[MAX];int visited[MAX],num[MAX],pre[MAX];void init() &#123; memset(visited, 0, sizeof(visited));&#125;void BFS(int s,int len) &#123; queue&lt;Node&gt; q; q.push(Node&#123;s,0&#125;); while (!q.empty()) &#123; Node node &#x3D; q.front(); q.pop(); int v &#x3D; node.nv; int level &#x3D; node.level; if (level &#x3D;&#x3D; len)break; &#x2F;&#x2F;cout &lt;&lt; v; visited[v] &#x3D; 1; for (Edge&amp; e : G[v]) &#123; int w &#x3D; e.to; if (visited[w])continue; visited[w] &#x3D; 1; num[s]++; q.push(Node(w,level+1)); &#x2F;&#x2F; cout &lt;&lt; &quot;--&quot;&lt;&lt; w&lt;&lt;&quot; &quot;; &#125; &#x2F;&#x2F;cout &lt;&lt; endl; &#125;&#125;int main()&#123; memset(G, 0, sizeof(G)); int M, L,tmp; cin &gt;&gt; M &gt;&gt; L; for (int i &#x3D; 1; i &lt;&#x3D; M; i++) &#123; cin &gt;&gt; tmp; for (int j &#x3D; 1; j &lt;&#x3D; tmp; j++) &#123; int x; cin &gt;&gt; x; G[x].push_back(Edge&#123; x,i &#125;); &#125; &#125; cin &gt;&gt; tmp; for (int i &#x3D; 0; i &lt; tmp; i++) &#123; int a; cin &gt;&gt; a; init(); BFS(a, L); cout &lt;&lt; num[a]; if (i !&#x3D; tmp - 1)cout &lt;&lt; endl; &#125; return 0;&#125; 心得这道题是单向无权图–&gt;BFS 题目编号从1-N；建图应该从1到N方便 记录BFS遍历图的层数，在结点结构体中添加层数信息。在BFS中更新。 BFS跟Dijkstra的区别：BFS只要访问到邻接点，邻接点就要被收录而不用再通过邻接点去做松弛操作更新它的邻接点的最小路径","comments":true,"categories":[{"name":"pat","slug":"pat","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/pat/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/BFS/"},{"name":"BFS如何记录层数","slug":"BFS如何记录层数","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/BFS%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E5%B1%82%E6%95%B0/"}]},{"title":"Markdown语法","date":"2020-02-24T04:21:50.588Z","path":"2020/02/24/markdown语法/","text":"12345678910111213141516&lt;div style&#x3D;&#39;display: none&#39;&gt;哈哈我是注释，不会在浏览器中显示。&lt;&#x2F;div&gt;- 标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 &lt;!--最多6级标题--&gt;- 任务列表- [ ] 任务一 未做任务 &#96;- + 空格 + [ ]&#96;- [x] 任务二 已做任务 &#96;- + 空格 + [x]&#96;- 哈哈我是注释，不会在浏览器中显示。 标题 一级标题二级标题三级标题四级标题五级标题六级标题 任务列表 任务一 未做任务 - + 空格 + [ ] 任务二 已做任务 - + 空格 + [x] 1234567【1】 &amp;emsp;或&amp;#8195; &#x2F;&#x2F;全角【2】 &amp;ensp;或&amp;#8194; &#x2F;&#x2F;半角【3】 &amp;nbsp;或&amp;#160; &#x2F;&#x2F;半角之半角&lt;center&gt;行中心对齐&lt;&#x2F;center&gt;&lt;p align&#x3D;&quot;left&quot;&gt;行左对齐&lt;&#x2F;p&gt;&lt;p align&#x3D;&quot;right&quot;&gt;行右对齐&lt;&#x2F;p&gt; 【1】 &emsp;或&#8195; //全角【2】 &ensp;或&#8194; //半角【3】 &nbsp;或&#160; //半角之半角 行中心对齐 行左对齐 行右对齐 1234567891011&gt;*斜体*或_斜体_&gt;**粗体**&gt;***加粗斜体***&gt;~~删除线~~&gt;++下划线++&gt;&#x3D;&#x3D;背景高亮&#x3D;&#x3D; 斜体或斜体 粗体 加粗斜体 删除线 ++下划线++ ==背景高亮== 123456&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;&lt;font color&#x3D;#0099ff size&#x3D;12 face&#x3D;&quot;黑体&quot;&gt;黑体&lt;&#x2F;font&gt;&lt;font color&#x3D;gray size&#x3D;5&gt;gray&lt;&#x2F;font&gt;&lt;font color&#x3D;#00ffff size&#x3D;3&gt;null&lt;&#x2F;font&gt; 我是黑体字我是微软雅黑我是华文彩云黑体graynull 123456* 无序列表项 一+ 无序列表项 二- 无序列表项 三1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 无序列表项 一 无序列表项 二 无序列表项 三 有序列表项 一 有序列表项 二 有序列表项 三 123456789101112131415161718192021222324252627&lt;center&gt; &lt;!--开始居中对齐--&gt;![GitHub set up](http:&#x2F;&#x2F;zh.mweb.im&#x2F;asset&#x2F;img&#x2F;set-up-git.gif &quot;图片Title&quot;)![图片Alt](图片地址 &quot;图片Title&quot;)&lt;&#x2F;center&gt; &lt;!--结束居中对齐--&gt;&gt;- 超链接&gt;欢迎阅读 [择势勤](https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;16d77399d3a7 &quot;择势勤&quot;)&gt;网站[Google][1]、[Leanote][2]。[1]:http:&#x2F;&#x2F;www.google.com [2]:http:&#x2F;&#x2F;www.leanote.com- 注脚使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言- 在段落填写[TOC]以显示全文内容的目录结构[TOC] 超链接 欢迎阅读 择势勤 网站Google、Leanote。 注脚使用 Markdown^1可以效率的书写文档, 直接转换成 HTML[^2]。 [^2]:HyperText Markup Language 超文本标记语言 在段落填写[TOC]以显示全文内容的目录结构[TOC] 12345include &lt;stdio.h&gt;int main(void)&#123;printf(&quot;Hello world\\n&quot;);&#125; 学号 姓名 序号 小明明 男 5 小红 女 79 小陆 男 192 摘自 简书","comments":true,"categories":[{"name":"basic","slug":"basic","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/basic/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/markdown/"}]},{"title":"Samba服务器","date":"2020-02-09T16:00:00.000Z","path":"2020/02/10/SAMBA服务器/","text":"samba的功能 共享文件和打印机服务 身份认证，提供不同身份用户的个别数据 进行window网络上的主机名解析 可以进行设备的共享 samba常见的应用 1利用软件直接剪辑www主机上面的网页数据 做成可以直接连接的文件服务器 打印机服务器 samba使用的NetBIOS通信协议 samba使用的daemons nmbd 这个daemon用来管理工作组，NetBIOS Name 等解析。主要利用UDP协议开启port137，138来负责名称解析的任务 smbd 这个daemon主要功能用来管理samba主机共享的目录，文件与打印机等。利用可靠的TCP协议来传输数据，开放的端口139及445 连接模式（Peer/Peer（对等模式），Domain model（主控模式））","comments":true,"categories":[{"name":"网络","slug":"网络","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"萌新","slug":"萌新","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E8%90%8C%E6%96%B0/"}]},{"title":"Hello World","date":"2020-01-31T16:00:00.000Z","path":"2020/02/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"萌新","slug":"萌新","permalink":"https://blog-1e57ca-1302405762.tcloudbaseapp.com/tags/%E8%90%8C%E6%96%B0/"}]}]}