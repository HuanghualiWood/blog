{"meta":{"title":"Hexo","subtitle":"","description":"","author":"minhao","url":"https://github.com/HuanghualiWood/blog","root":"/blog/"},"pages":[{}],"posts":[{"title":"FFT","date":"2020-06-18T12:03:27.000Z","path":"2020/06/18/FFT/","text":"快速傅里叶变换摘自 对于N点序列,它的离散傅立叶变换为(DFT)为： X[k]=\\sum_{n=0}^{N-1}e^{-j\\frac{2\\pi}{N}{nk}}x[n]其中k=0,1,….,N-1,上面的式子展开一下： X[k]=\\sum_{n=0}^{N-1}x[n]\\cdot[cos(\\frac{2\\pi}{N}kn)-jsin(\\frac{2\\pi}{N}kn)] 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192939495969798#include &lt;assert.h&gt;#include &lt;math.h&gt;#include &lt;stdio.h&gt;#include &lt;stdlib.h&gt;#define q 8 /* 2^q 点，256 */#define N (1&lt;&lt;q) /* N点 FFT, iFFT */typedef float real;typedef struct&#123; real Re; real Im;&#125; complex;#ifndef PI# define PI 3.14159265358979323846264338327950288#endif/*为了更好说明分治思想，这里采用递归实现，结束条件为N&lt;=1*/void fft( complex *v, int n, complex *tmp )&#123; if(n&gt;1) &#123; /* N如小于1，直接返回*/ int k,m; complex z, w, *vo, *ve; ve = tmp; vo = tmp+n/2; for(k=0; k&lt;n/2; k++) &#123; ve[k] = v[2*k]; vo[k] = v[2*k+1]; &#125; fft( ve, n/2, v ); /* FFT 偶数序列 v[] */ fft( vo, n/2, v ); /* FFT 偶数序列 v[] */ for(m=0; m&lt;n/2; m++) &#123; w.Re = cos(2*PI*m/(double)n); w.Im = -sin(2*PI*m/(double)n); z.Re = w.Re*vo[m].Re - w.Im*vo[m].Im; /* Re(w*vo[m]) */ z.Im = w.Re*vo[m].Im + w.Im*vo[m].Re; /* Im(w*vo[m]) */ v[ m ].Re = ve[m].Re + z.Re; v[ m ].Im = ve[m].Im + z.Im; v[m+n/2].Re = ve[m].Re - z.Re; v[m+n/2].Im = ve[m].Im - z.Im; &#125; &#125; return;&#125;/*为了更好说明分治思想，这里采用递归实现，结束条件为N&lt;=1*/void ifft( complex *v, int n, complex *tmp )&#123; if(n&gt;1) &#123; int k,m; complex z, w, *vo, *ve; ve = tmp; vo = tmp+n/2; for(k=0; k&lt;n/2; k++) &#123; ve[k] = v[2*k]; vo[k] = v[2*k+1]; &#125; ifft( ve, n/2, v ); /* FFT 偶数序列 v[] */ ifft( vo, n/2, v ); /* FFT 奇数序列 v[] */ for(m=0; m&lt;n/2; m++) &#123; w.Re = cos(2*PI*m/(double)n); w.Im = sin(2*PI*m/(double)n); z.Re = w.Re*vo[m].Re - w.Im*vo[m].Im; /* Re(w*vo[m]) */ z.Im = w.Re*vo[m].Im + w.Im*vo[m].Re; /* Im(w*vo[m]) */ v[ m ].Re = ve[m].Re + z.Re; v[ m ].Im = ve[m].Im + z.Im; v[m+n/2].Re = ve[m].Re - z.Re; v[m+n/2].Im = ve[m].Im - z.Im; &#125; &#125; return;&#125;#define SAMPLE_RATE (10000.0f)int main(void)&#123; complex v[N], scratch[N]; float amp[N]; int k; /*模拟一个采样系统，采样率为10KHz，有两个信号：500Hz/2kHz*/ for(k=0; k&lt;N; k++) &#123; v[k].Re = 1*sin(2*PI*500*k/SAMPLE_RATE)+0.5*sin(2*PI*2000*k/SAMPLE_RATE); v[k].Im = 0;//实际信号处理时，虚部常为0 &#125; /*输出模拟信号*/ for(int i=0;i&lt;N;i++) &#123; printf(\"%f,\",v[i].Re); &#125; printf(\"\\n\"); fft( v, N, scratch ); for( int i=0;i&lt;N;i++) &#123; printf(\"%f,\",sqrt(v[i].Re*v[i].Re+v[i].Im*v[i].Im)); &#125; printf(\"\\n\"); while(1);&#125;","comments":true,"categories":[],"tags":[]},{"title":"VScode launch.json Expected a Declaration","date":"2020-06-18T11:19:46.000Z","path":"2020/06/18/VScode-launch-json-expected-a-declaration/","text":"VScode launch.json expected a declaration今天想在VScode调试cpp，发现了一个问题弄了好久😭，每次设置完debug，自动生成的launch.json文件都会报错 经过摸索，发现这个错误其实并无卵用。偶然点了波浪线下面的那个灯泡，写着错误修复，内容是Disable error squiggles，然后错误久消失了，debug可以用了。 一直以为是json里面有格式问题或者是路径没配置好，发现都不是。。。","comments":true,"categories":[],"tags":[{"name":"VScode","slug":"VScode","permalink":"https://github.com/HuanghualiWood/blog/tags/VScode/"}]},{"title":"传感器","date":"2020-06-18T05:25:45.000Z","path":"2020/06/18/传感器/","text":"灵敏度 灵敏度输出的变化量 $\\delta$y与引起该变化量的输入变化量$\\delta$x之比即为静态灵敏度 k=\\frac{\\Delta y}{\\Delta x} 静态误差 求取方法：把全部校准数据与拟合直线上对应的残差看成随机分布，求标出其标准偏差$\\sigma$ \\sigma=\\sqrt{\\frac{1}{n-1}\\sum_{i=1}^{n}({\\Delta y_i}^2)}$\\Delta y_i$—各测试点的残差 动态响应两种分析： 1线性常系数微分方程 2拉氏变换 较一般的激励函数，当函数或其导数具有不连续间断点时 传递函数 G(s)=\\frac{Y(s)}{X(s)}=\\frac{b_ms^m+b_{m-1}s^{m-1}+...+b_1s+b_0}{a_ms^m+a_{m-1}s^{m-1}+...+a_1s+a_0}将传递函数的分子分母多项式写成因子乘积的形式 G(s)=\\frac{b_m(s+B_1)(s+B_2)...(s+B_m)}{a_n(s+A_1)(s+A_2)...(s+A_m)}瞬态响应的分析方法 建立网络的传递函数G(s) 求激励的拉氏变换,即输入的象函数X(s)s $Y(s)=G(s)·X(s)$ $y(t)=L^{-1}[G(s)·X(S)]$ 应变式电阻传感器电阻应变片的工作原理基于电阻应变效应，在导体产生机械变形时，它的电阻值相应发生变化 R=\\rho\\frac{l}{s}电阻丝在外力F作用下，引起电阻变化$\\Delta R$ 有$\\frac{\\Delta R}{R} = \\frac{\\Delta l}{l}-\\frac{\\Delta S}{S}+\\frac{\\Delta \\rho}{\\rho}$ 令电阻丝的轴向效 $\\varepsilon=\\frac{\\Delta l}{l}$ ，径向应变$\\frac{\\Delta r}{r}$ \\frac{\\Delta r}{r}=-\\mu(\\frac{\\Delta l}{l})=-\\mu\\varepsilon $\\mu$称为电阻材料的泊松系数 \\frac{\\Delta R}{R}=(1+2\\mu)-\\frac{\\Delta \\rho}{\\rho} k_0=\\frac{\\frac{\\Delta R}{R}}{\\varepsilon}=(1+2\\mu)-\\frac{\\frac{\\Delta \\rho}{\\rho}}{\\varepsilon}$\\frac{\\Delta \\rho/\\rho}{\\varepsilon}$表示由材料电阻率变化所引起的。对于金属材料，$\\frac{\\Delta \\rho/\\rho}{\\varepsilon}$的值要比$(1+2\\mu)$小很多，可以忽略。故$k_0=1+2\\mu$ $k_0=1.7$~$3.6$ 式（7）可写成 \\frac{\\Delta R}{R}≈k_0\\varepsilon应变式电阻测量电路 直流电桥 电桥平衡条件：$\\frac{R_1}{R_2}=\\frac{R_2}{R_4}$ R_1R_4=R_2R_3 K_u=\\frac{U}{4}· \\frac{\\Delta R_1}{R_1}==重要公式== \\textcolor{red}{\\varepsilon=\\frac{\\Delta l}{l}=\\frac {\\sigma}{E}=\\frac{F}{SE}}$\\sigma:应力$ $\\varepsilon:轴向应变$ $E:弹性模量$ U_o=\\frac{U}{4}(\\frac{\\Delta R_1}{R_1}-\\frac{\\Delta R_2}{R_2}+\\frac{\\Delta R_3}{R_3}-\\frac{\\Delta R_4}{R_4}) U_o=\\frac{U}{4}K(\\varepsilon_1-\\varepsilon_2+\\varepsilon_3-\\varepsilon_4)相邻桥臂电阻（应变）变化，同号相 减，异号相加；相对桥臂电阻（应变）变化，同号相加，异号相减。 电容式传感器 双T型充放电网络 U_o\\approx\\frac{R(R+2R_L)}{R+R_L}·R_L·U·f·(C_1-C_2) K=\\frac{R(R+2R_L)}{R+R_L} U_o\\approx K·U·f·(C_1-C_2)特点（重点在于寄生电容产生原因及消除办法，边缘效应消除办法 寄生电容产生原因：连接传感器和电子线路的引线电容、电子线路的杂散电容以及传感器内极板与其周围导体构成的电容。降低了传感器的灵敏度，而且由于其随机变化影响测量精度。 寄生电容解决方法：（采用屏蔽性好、自身分布电容小的高频电线作为引线，且引线粗而短，要保证仪器的杂散电容小而稳定等等。）1、增加原始电容值可减小寄生电容的影响2、注意传感器的接地和屏蔽3、将传感器与电子线路的前置级(集成化)装在一个壳体内，省去传感器至前置级的电缆。4、采用“驱动电缆”技术(也称“双层屏蔽等位传输”技术)5、采用运算放大器6、整体屏蔽法 边缘效应消除办法：1、适当减小极间距，使极径与间距比更大，可减少边缘效应，但易产生击穿并有可能限制测量范围。2、可以采用上述电极放得极薄使与间距相比很小的方法来减少边缘电场的影响。 3、等位环 压电式传感器压电元件收到力F作用时，就在相应的表面产生面电荷Q，存在如下关系 Q=dF$d—-压电系数$ q=d_{ij}\\sigmaq—-电荷面密度 $\\sigma—-单位面积上的作用力$ $d_{ij}$ 等效电路 电压等效 电荷等效 C_a=\\frac{\\epsilon_r\\epsilon_0S}{d}电压灵敏度和电荷灵敏度的关系 K_u=\\frac{K_q}{C_a}测量电路-电压放大$C=C_i+C_c+C_a$ $q=d_33F$ i=\\frac{dq}{dt}=\\frac{d(d_33·F_m·sin\\omega t)}{dt}=\\omega d_{33}F_mcos\\omega t \\dot{U}_i=d_{33}\\dot{F}·\\frac{j\\omega R}{1+j\\omega RC} U_{im}=\\frac{d_{33}F_m\\omega R}{\\sqrt{ {1+(\\omega RC)^2}}} \\phi=\\frac{\\pi}{2}-arctan(\\omega RC) 幅值 k_m=\\frac{U_{im}}{U_m}=\\frac{\\frac{\\omega}{\\omega _1}}{\\sqrt{1+（{\\frac{\\omega}{\\omega _1})^2}}} 灵敏度K_u=\\frac{d_{33}}{\\sqrt{\\frac{1}{(\\omega RC)^2}+C^2}} 当\\omega R>>1时 K_u=\\frac{d_{33}}{C_c+C_i+C_a}热电式传感器西拜克效应（热电效应） E_{AB}(T)=\\frac{kT}{e}ln\\frac{N_A}{N_B}$k:玻尔兹曼常数1.38*10^{-6}$ T:接触处的绝对温度 热电偶的补偿方法 热电动势补偿法 调整一起起始点补偿法 热电偶补偿法 电桥补偿法 冷端延长线法","comments":true,"categories":[{"name":"期末考试","slug":"期末考试","permalink":"https://github.com/HuanghualiWood/blog/categories/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"}],"tags":[{"name":"传感器","slug":"传感器","permalink":"https://github.com/HuanghualiWood/blog/tags/%E4%BC%A0%E6%84%9F%E5%99%A8/"}]},{"title":"C和C++字符串处理","date":"2020-06-18T05:19:51.000Z","path":"2020/06/18/C字符串处理/","text":"刷题的时候经常遇到处理字符串的，每次都会有所遗忘，特此总结一个模板 %s格式字符串bai会从给定的内存空间du开始向后逐个输出字zhi符，直到遇到\\0结束。格式dao字符串为%s时，后面的参数应该为一个内存地址(指针)，如果给出的是一个字符变量，那么会将字符变量中的值认作地址，例如字符变量ch中保存的是字符’a’，那么printf会将’a’对应的ASCII码97作为内存地址 ==为什么数组中的元素不能是引用？== c++中，引用可以说只是某个变量的别名，所谓别名，是和指针类型区分开的：指针类型也可以指向某个变量，但指针类型本身也是一个变量，而引用实际上不是一个变量。更本质来说，可以理解为引用没有自身的地址，不占用内存空间（这里为了简化问题可以这样考虑）。因此，声明引用数组没有办法分配空间，因为根本就没有空间可以分配给引用。所以不能声明和定义引用数组 ==主要解决char*复制到char[]数组不同位置的问题== 12345678910111213141516171819202122232425#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstdio&gt;using namespace std;char * s ;int cont_str(char* s)&#123; int i = 0; while (s[i++]!= '\\0'); return i-1;&#125;int converttochar(char *c,char arrc[],int len)&#123;//把char*的元素复制到char[1] arrc[0] = '-'; char* p = &amp;arrc[1]; strncpy(p, c, len); //char*类型转char[] 类型 return 0;&#125;int main(void) &#123; s = (char*)malloc(sizeof(char*) * 100); cin.get(s,100); char arrc[100] = &#123;-1&#125;; converttochar(s, arrc,(int)strlen(s)); return 1;&#125;","comments":true,"categories":[{"name":"语法","slug":"语法","permalink":"https://github.com/HuanghualiWood/blog/categories/%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"字符串","slug":"字符串","permalink":"https://github.com/HuanghualiWood/blog/tags/%E5%AD%97%E7%AC%A6%E4%B8%B2/"}]},{"title":"C++队列堆栈stl","date":"2020-06-13T01:54:03.000Z","path":"2020/06/13/c++队列堆栈stl/","text":"添加库queue1234#include &lt;iostream&gt;#include &lt;queue&gt;#include &lt;string&gt;using namespace std;五个操作q.push()q.pop()q.front()q.back()q.empty() 2.bool empty() const 判断队列是否为空 c.empty(); 3.size_type size() const 返回队列中元素个数 c.size() 4.value_type&amp; front(); const value_type&amp; front() const; 返回队列中第一个元素,即最后插入到队列中的那个元素 c.front(); 5.value_type&amp; back(); const value_type&amp; back() const; 返回队列中最后一个元素，即最先入队的那个元素 c.back(); 6.void push (const value_type&amp; val) 插入一个新元素在队尾 c.push(value) 7.void emplace(Args&amp;&amp; args) 插入一个新的元素在队尾 c.emplace(args); 8.void pop() 移除队首元素 c.pop(); 9.void swap(queue&amp; x) 交换两个队列的内容 c.swap(d); 10.与stack和vector一样，重载了几个运算符:== != &lt; &lt;= &gt; &gt;=","comments":true,"categories":[],"tags":[{"name":"队列堆栈stl","slug":"队列堆栈stl","permalink":"https://github.com/HuanghualiWood/blog/tags/%E9%98%9F%E5%88%97%E5%A0%86%E6%A0%88stl/"}]},{"title":"数电","date":"2020-06-11T16:41:57.000Z","path":"2020/06/12/数电/","text":"# 数电笔记","comments":true,"categories":[{"name":"电子","slug":"电子","permalink":"https://github.com/HuanghualiWood/blog/categories/%E7%94%B5%E5%AD%90/"}],"tags":[{"name":"数电","slug":"数电","permalink":"https://github.com/HuanghualiWood/blog/tags/%E6%95%B0%E7%94%B5/"},{"name":"期末考试","slug":"期末考试","permalink":"https://github.com/HuanghualiWood/blog/tags/%E6%9C%9F%E6%9C%AB%E8%80%83%E8%AF%95/"}]},{"title":"PT2262解码原理","date":"2020-06-09T16:00:00.000Z","path":"2020/06/10/test/","text":"# PT2262解码原理","comments":true,"categories":[{"name":"单片机","slug":"单片机","permalink":"https://github.com/HuanghualiWood/blog/categories/%E5%8D%95%E7%89%87%E6%9C%BA/"}],"tags":[{"name":"解码","slug":"解码","permalink":"https://github.com/HuanghualiWood/blog/tags/%E8%A7%A3%E7%A0%81/"}]},{"title":"线性表习题","date":"2020-06-09T16:00:00.000Z","path":"2020/06/10/线性表习题/","text":"线性表习题123456789/*2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素*//*2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）*//*2-2-8 将数组中两个顺序表的位置置换*//*2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点*//*2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间*//*2-3-3 L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值*//*2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）*//*2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)*//*2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序*/ 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include&lt;cstdio&gt;#define Elemtype int//顺序存储结构typedef struct &#123; Elemtype data[50] = &#123; 4, 3, 3, 4, 2, 4, 5, 6, 6, 6 &#125;; Elemtype length;&#125;Sqlist;Sqlist L;//链式存储结构typedef struct LNode &#123; Elemtype data; struct LNode* next;&#125;LNode,*Linklist;/*------------建立链表，注意双指针以及辅助指针的使用-------------*///指针的引用void Linklist_init(Linklist &amp;L) &#123; L = (Linklist)malloc(sizeof(LNode)); LNode* tmp, * r = L;//必须要一个辅助指针*r L-&gt;data = -1; L-&gt;next = NULL; for (int i = 0; i &lt; 10; i++) &#123; tmp = (LNode*)malloc(sizeof(LNode)); if (tmp != NULL) &#123; tmp-&gt;data = i ; r-&gt;next = tmp; r = tmp; &#125; &#125; r-&gt;next = NULL;&#125;//二级指针，传入实参地址void Linklist_init2(LNode ** L) &#123; *L = (LNode*)malloc(sizeof(LNode)); LNode* tmp, * r = *L; r-&gt;data = -1; r-&gt;next = NULL; for (int i = 0; i &lt; 20; i++) &#123; tmp = (LNode*)malloc(sizeof(LNode)); if (tmp != NULL) &#123; tmp-&gt;data = i % 5; r-&gt;next = tmp; r = tmp; &#125; &#125; r-&gt;next = NULL;&#125;//return返回Linklist Linklist_init3(void) &#123; Linklist L = (Linklist)malloc(sizeof(LNode)); LNode* tmp, * r = L; r-&gt;data = -1; r-&gt;next = NULL; for (int i = 0; i &lt; 10; i++) &#123; tmp = (LNode*)malloc(sizeof(LNode)); if (tmp != NULL) &#123; tmp-&gt;data = i % 6; r-&gt;next = tmp; r = tmp; &#125; &#125; r-&gt;next = NULL; return L;&#125; /2-2-3编写一个时间复杂度为O（n）,空间复杂度为O（1）的算法，删除顺序表中所有值为x的元素/123456789101112131415161718void delet_x(Sqlist &amp;L, int value) &#123; int i=0, k=0, j=0; int length = L.length; j = 0; while (i&lt;L.length) &#123; if (k != 0) &#123; L.data[i-k] = L.data[i]; &#125; if (L.data[i] == value) &#123; k++; length--; &#125; i++; &#125; for (i = length; i &lt; L.length; i++) L.data[i] = 0; L.length = length;&#125; /2-2-4从有序顺序表中删除其值在给定范围s与t之间，包含s和t的所有元素，如果t或s不合理，显示错误信息）///理解错误，做成了，删除线性表范围在s和t之间的值为x的元素 123456789101112131415161718bool delte_x_at(Sqlist &amp;L, int s, int t, int value) &#123; if (s &gt;= t)return false; if (L.length &lt;= 0)return false; int i=0, j=0,k=0; for (i = s+1; i &lt; t; i++) &#123; if (L.data[i] != value) &#123; L.data[k+s+1] = L.data[i]; k++; &#125; &#125; j = t - s - 1 - k; for (i = t; i &lt; L.length; i++) L.data[i - j] = L.data[i]; for (i =0; i &lt;j; i++) L.data[L.length - 1 - i] = 0; L.length = L.length - (t - s - 1) + k; return true;&#125; /2-2-8 将数组中两个顺序表的位置置换/123456789101112131415161718### 逆置算法int arr[10] = &#123; 1,2,3,4,5,6,1,2,3,4 &#125;;bool reverse(int arr[], int left, int right) &#123; if (left &gt; right)return false; int mid = (left+right) / 2; for (int i = 0; i &lt;= mid - left; i++) &#123; int tmp = arr[i+left]; arr[i + left] = arr[right - i]; arr[right - i] = tmp; &#125; return true;&#125;bool Sqlist_rev(int arr[],int m, int n) &#123; reverse(arr, 0, m + n - 1); reverse(arr,0, n - 1); reverse(arr, n, m+n - 1); return true;&#125; /2-3-1设计一个递归算法，删除不带头结点的单链表L中所有的值为x的结点/1234567891011bool Linklist_delele(Linklist&amp; L, int x) &#123; if (!L)return false; if (L-&gt;data &#x3D;&#x3D; x) &#123; LNode *q &#x3D; L; L &#x3D; L-&gt;next; free(q); Linklist_delele(L, x); &#125; Linklist_delele(L-&gt;next, x); return true;&#125;/2-3-2在带头结点的单链表L中删除所有值为x的结点，并释放其空间/12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152//------------------------------------------------------void Linklist_del(Linklist &amp;L, Elemtype x) &#123; LNode *q, *p = L-&gt;next, *pre = L; while (p) &#123; if (p-&gt;data == x) &#123; q = p; p = p-&gt;next;//p还要往前移一个，和L的位置重合 pre-&gt;next = p; free(q); printf(\". \"); &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125;&#125;//删除也可以传入一级指针,无需指针的引用void Linklist_del2(Linklist L, Elemtype x) &#123;//L此时为形参，函数内生成L头结点的副本，不过指向的内容仍然 Linklist q, p = L-&gt;next, pre = L; //是L。可以实现对L的删除。 while (p) &#123; if (p-&gt;data == x) &#123; q = p; p = p-&gt;next; L-&gt;next = p; free(q); printf(\". \"); &#125; else &#123; pre = p; p = p-&gt;next; &#125; &#125;&#125;### 尾插法，删除特定值void Linklist_del3(Linklist &amp;L, Elemtype x) &#123; Linklist q, p = L-&gt;next, r = L; while (p) &#123; if (p-&gt;data != x) &#123; r-&gt;next=p; r = p; p= p-&gt;next; &#125; else &#123; q = p; p = p-&gt;next; free(q); printf(\". \"); &#125; &#125; r-&gt;next = NULL;&#125; /2-3-3L为带头节点的单链表，编写算法实现从尾到头反向输出每个结点的值/12345void Linklist_reverse(Linklist L) &#123; if(L-&gt;next) Linklist_reverse(L-&gt;next); printf(\"%d \", L-&gt;data); &#125;/2-3-4 试编写在带头结点的单链表L中删除一个最小值结点的高效算法（假设最小结点是唯一的）/ 1234567891011121314void dellmin4(Linklist &amp;L) &#123; LNode* pre = L, * p = L-&gt;next; LNode* tmp=p,*tmppre=pre ; while (p != NULL) &#123; if (tmp-&gt;data &gt; p-&gt;data) &#123; tmp = p; tmppre = pre; &#125; pre = p; p = p-&gt;next; &#125; tmppre-&gt;next = tmp-&gt;next; free(tmp);&#125; /2-3-5试编写算法将带头结点的单链表就地逆置，辅助空间复杂度为O(1)///xxxxx12345678910void Linklist_reverse2(Linklist &amp;L) &#123; LNode *pre = NULL, *p = L-&gt;next, * tmp = L; while (p != NULL) &#123; tmp = p-&gt;next; p-&gt;next = pre; pre = p; p = tmp; &#125; L-&gt;next=pre;&#125; 2头插法，精妙！void Linklist_reverse2_2(Linklist&amp; L) { LNode first = L, p = L-&gt;next, * tmp = L; while (p != NULL) { tmp = p-&gt;next; first = L-&gt;next; L-&gt;next = p; p-&gt;next = first; first-&gt;next = tmp; } }/2-3-6有一个带头结点的单链表L，设计一个算法使其元素递增有序///不应该使用选择排序，选择最小结点操作很麻烦12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091929394959697void Linklist_increaseorder(Linklist &amp;L) &#123; LNode * p = L-&gt;next,*prep=L; LNode * q = NULL, * preq = L; LNode * min = p, * premin = p; while (p != NULL) &#123; premin = min = p; preq = premin; q = p; printf(\"p:%d \", p-&gt;data); while (q != NULL) &#123; printf(\" q:%d \", q-&gt;data); if (q-&gt;data &lt; min-&gt;data) &#123; premin = preq; min = q; printf(\"%d\", min-&gt;data); &#125; preq = q; q = q-&gt;next; &#125; if (min-&gt;next != NULL) premin-&gt;next = min-&gt;next; else premin-&gt;next = NULL;//少了这一句链表编程循环队列-_-,死循环！！！！ if (min == p) &#123; printf(\"no min \\n \"); prep = p; p = p-&gt;next; &#125; else &#123; prep-&gt;next = min; prep = min; min-&gt;next = p; &#125; &#125; &#125;/*链表的插入排序*///比较恶心,优点难度，注重细节void Linklist_increaseorder2(Linklist&amp; L) &#123; LNode * r , * p = L-&gt;next,*pre=L; r = p-&gt;next; p-&gt;next = NULL; //!!!!这里没有想到 构造只含一个数据结点的有序表。少了这个会死循环 p = r; while (p != NULL) &#123; r = p-&gt;next; pre = L; while (pre-&gt;next!=NULL&amp;&amp;pre-&gt;next-&gt;data&lt;p-&gt;data) pre = pre-&gt;next; p-&gt;next = pre-&gt;next; pre-&gt;next = p; p = r; &#125;&#125;Linklist L1, L2, L3;void printL(Linklist L) &#123; Linklist p = L-&gt;next; while (p != NULL) &#123; printf(\" %d\", p-&gt;data); p = p-&gt;next; &#125;&#125;int main() &#123; int n,tmp; //scanf(\"%d\", &amp;n); //L.length = n; //for (int i = 0; i &lt; n; i++) &#123; //scanf(\"%d\", &amp;tmp); //L.data[i] = tmp; //&#125; //delet_x(L, 4); //delte_x_at(L, 0, 7, 4); //for (int i = 0; i &lt; L.length; i++) &#123; //printf(\"%d \", L.data[i]); //&#125; //sqlrev(arr, 6, 4); //Linklist_init(L1); //Linklist_init2(&amp;L1); L2 = Linklist_init3(); //Linklist_reverse(L-&gt;next); //Linklist_delele(L, 1); //Linklist_del(L,0); //Linklist_del2(L, 2); //Linklist_del3(L, 2); //dellmin4(L); //Linklist_reverse2(L1); //Linklist_increaseorder(L2); Linklist_increaseorder2(L2); printL(L2); return 0;&#125;","comments":true,"categories":[{"name":"数据结构刷题","slug":"数据结构刷题","permalink":"https://github.com/HuanghualiWood/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%88%B7%E9%A2%98/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/HuanghualiWood/blog/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"},{"name":"线性表的操作","slug":"线性表的操作","permalink":"https://github.com/HuanghualiWood/blog/tags/%E7%BA%BF%E6%80%A7%E8%A1%A8%E7%9A%84%E6%93%8D%E4%BD%9C/"}]},{"title":"图的遍历/最短路径","date":"2020-04-30T01:54:03.000Z","path":"2020/04/30/图的遍历&最短路径/","text":"一.DFS DFS求连通分量的个数 什么是连通分量？ 连通分量个数就是使用DFS的次数 二.BFS 宽度优先搜索算法（又称广度优先搜索）是最简便的图的搜索算法之一，这一算法也是很多重要的图的算法的原型。Dijkstra单源最短路径算法和Prim最小生成树算法都采用了和宽度优先搜索类似的思想。其别名又叫BFS，属于一种盲目搜寻法，目的是系统地展开并检查图中的所有节点，以找寻结果。换句话说，它并不考虑结果的可能位置，彻底地搜索整张图，直到找到结果为止。 松弛函数(算法导论里的东西) 对边集合 E 中任意边，以 w(u,v) 表示顶点 u 出发到顶点 v 的边的权值，以 d[v] 表示当前从起点 s 到顶点 v 的路径权值 若存在边 w(u,v)，使得： 所以松弛函数的作用，就是判断是否经过某个顶点，或者说经过某条边，可以缩短起点到终点的路径权值。 为什么将缩短距离的操作称之为“松弛”，不妨理解为，选择某种方式后，到达目的的总代价降低了。什么名字无关紧要，不必纠结。 堆优化优化Dijkstra","comments":true,"categories":[{"name":"数据结构","slug":"数据结构","permalink":"https://github.com/HuanghualiWood/blog/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"}],"tags":[{"name":"图","slug":"图","permalink":"https://github.com/HuanghualiWood/blog/tags/%E5%9B%BE/"}]},{"title":"Pat1030 Dijkstra","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/pat1030 Dijkstra 堆优化/","text":"A traveler’s map gives the distances between cities along the highways,together with the cost of each highway. Now you are supposed to write a program to help a traveler to decide the shortest path between his/her starting city and the destination. If such a shortest path is not unique, you are supposed to output the one with the minimum cost, which is guaranteed to be unique.Input Specification: Each input file contains one test case. Each case starts with a line containing 4 positive integers N, M, S, and D, where N (≤500) is the number of cities (and hence the cities are numbered from 0 to N−1); M is the number of highways; S and D are the starting and the destination cities, respectively. Then M lines follow, each provides the information of a highway, in the format: City1 City2 Distance Cost where the numbers are all integers no more than 500, and are separated by a space.Output Specification: For each test case, print in one line the cities along the shortest path from the starting point to the destination, followed by the total distance and the total cost of the path. The numbers must be separated by a space and there must be no extra space at the end of output.Sample Input: 1234567894 5 0 30 1 1 201 3 2 300 3 4 100 2 2 202 3 1 20Sample Output:0 2 3 3 4012345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;cstdio&gt;#include &lt;cmath&gt;#include &lt;algorithm&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define MAX 501struct Edge &#123; int from, to; int weight; int dist; Edge(int a,int b, int c,int d) : from(a),to(b), weight(c),dist(d) &#123;&#125;;&#125;;struct Node &#123; int dist, Nv; Node(int a, int b) :dist(a), Nv(b) &#123;&#125;; bool operator &lt; (const Node &amp;rhs) const &#123; return dist &gt; rhs.dist; &#125;&#125;;int Nv, Ne;vector&lt;Edge&gt; G[MAX];priority_queue&lt;Node&gt; q;int collected[MAX];int dist[MAX],pre[MAX],cost[MAX];void init() &#123; memset(pre, -1, sizeof(pre)); memset(collected, 0, sizeof(collected)); memset(dist, INF, sizeof(dist));&#125;void dijkstra(int s,int dir) &#123; q.push(Node&#123; 0,s &#125;); dist[s] &#x3D; 0; q.push(Node&#123; 0,s &#125;); while (!q.empty()) &#123; Node front &#x3D; q.top(); q.pop(); int v &#x3D; front.Nv; if (v &#x3D;&#x3D; dir)break; for (Edge &amp;e:G[v]) &#123; int w &#x3D; e.to; if (collected[w]!&#x3D;false) continue; if (dist[v] + e.dist&lt;dist[w]) &#123; dist[w] &#x3D; e.dist + dist[v]; pre[w] &#x3D; v; cost[w] &#x3D; cost[v] + e.weight; q.push(Node&#123; dist[w],w&#125;); &#x2F;&#x2F;cout &lt;&lt; v&lt;&lt;&quot; &quot;&lt;&lt;w &lt;&lt; endl; &#125; else if (dist[v] + e.dist &#x3D;&#x3D; dist[w]) &#123; if (cost[v] + e.weight &lt; cost[w]) &#123; pre[w] &#x3D; v; cost[w] &#x3D; cost[v] + e.weight; &#125; &#125; &#125; &#125;&#125;int main()&#123; init(); int N, M, C1, C2; cin &gt;&gt; N &gt;&gt; M &gt;&gt; C1 &gt;&gt; C2; for (int i &#x3D; 0, v, w, d, c; i &lt; M; i++) &#123; cin &gt;&gt; v &gt;&gt; w &gt;&gt; d &gt;&gt; c; G[v].push_back(Edge(v,w,c, d)); G[w].push_back(Edge(w,v,c, d)); &#125; dijkstra(C1,C2); vector&lt;int&gt; path; for (int i &#x3D; C2; i!&#x3D;-1;i&#x3D;pre[i]) &#123; path.push_back(i); &#125; for (int i &#x3D; path.size()-1; i &gt;&#x3D; 0; i--) cout &lt;&lt; path[i] &lt;&lt; &quot; &quot;; cout &lt;&lt;dist[C2]&lt;&lt;&quot; &quot;&lt;&lt; cost[C2]; return 0;&#125; 笔记 堆优化 堆优化的主要思想就是使用一个优先队列（就是每次弹出的元素一定是整个队列中最小的元素）来代替最近距离的查找，用邻接表代替邻接矩阵，这样可以大幅度节约时间开销。","comments":true,"categories":[{"name":"pat","slug":"pat","permalink":"https://github.com/HuanghualiWood/blog/categories/pat/"}],"tags":[{"name":"Dijkstra堆优化","slug":"Dijkstra堆优化","permalink":"https://github.com/HuanghualiWood/blog/tags/Dijkstra%E5%A0%86%E4%BC%98%E5%8C%96/"},{"name":"优先队列","slug":"优先队列","permalink":"https://github.com/HuanghualiWood/blog/tags/%E4%BC%98%E5%85%88%E9%98%9F%E5%88%97/"}]},{"title":"Pat1076 BFS","date":"2020-02-24T16:00:00.000Z","path":"2020/02/25/pat1076 BFS/","text":"Weibo is known as the Chinese version of Twitter. One user on Weibo may have many followers, and may follow many other users as well. Hence a social network is formed with followers relations. When a user makes a post on Weibo, all his/her followers can view and forward his/her post, which can then be forwarded again by their followers. Now given a social network, you are supposed to calculate the maximum potential amount of forwards for any specific user, assuming that only L levels of indirect followers are counted.Input Specification: Each input file contains one test case. For each case, the first line contains 2 positive integers: N (≤1000), the number of users; and L (≤6), the number of levels of indirect followers that are counted. Hence it is assumed that all the users are numbered from 1 to N. Then N lines follow, each in the format: M[i] user_list[i] where M[i] (≤100) is the total number of people that user[i] follows; and user_list[i] is a list of the M[i] users that followed by user[i]. It is guaranteed that no one can follow oneself. All the numbers are separated by a space. Then finally a positive K is given, followed by K UserID’s for query.Output Specification: For each UserID, you are supposed to print in one line the maximum potential amount of forwards this user can trigger, assuming that everyone who can view the initial post will forward it once, and that only L levels of indirect followers are counted.Sample Input: 1234567891011127 33 2 3 402 5 62 3 12 3 41 41 52 2 6Sample Output:45 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071#include &lt;iostream&gt;#include &lt;string&gt;#include &lt;cstring&gt;#include &lt;stdio.h&gt;#include &lt;queue&gt;#include &lt;vector&gt;using namespace std;#define MAX 1001struct Edge &#123; int from, to; Edge(int a, int b) :from(a), to(b) &#123;&#125;;&#125;;struct Node &#123; int nv,level;&#x2F;&#x2F;在结构体中添加路径层数 Node(int a, int b) :nv(a), level(b) &#123;&#125;;&#125;;vector&lt;Edge&gt; G[MAX];int visited[MAX],num[MAX],pre[MAX];void init() &#123; memset(visited, 0, sizeof(visited));&#125;void BFS(int s,int len) &#123; queue&lt;Node&gt; q; q.push(Node&#123;s,0&#125;); while (!q.empty()) &#123; Node node &#x3D; q.front(); q.pop(); int v &#x3D; node.nv; int level &#x3D; node.level; if (level &#x3D;&#x3D; len)break; &#x2F;&#x2F;cout &lt;&lt; v; visited[v] &#x3D; 1; for (Edge&amp; e : G[v]) &#123; int w &#x3D; e.to; if (visited[w])continue; visited[w] &#x3D; 1; num[s]++; q.push(Node(w,level+1)); &#x2F;&#x2F; cout &lt;&lt; &quot;--&quot;&lt;&lt; w&lt;&lt;&quot; &quot;; &#125; &#x2F;&#x2F;cout &lt;&lt; endl; &#125;&#125;int main()&#123; memset(G, 0, sizeof(G)); int M, L,tmp; cin &gt;&gt; M &gt;&gt; L; for (int i &#x3D; 1; i &lt;&#x3D; M; i++) &#123; cin &gt;&gt; tmp; for (int j &#x3D; 1; j &lt;&#x3D; tmp; j++) &#123; int x; cin &gt;&gt; x; G[x].push_back(Edge&#123; x,i &#125;); &#125; &#125; cin &gt;&gt; tmp; for (int i &#x3D; 0; i &lt; tmp; i++) &#123; int a; cin &gt;&gt; a; init(); BFS(a, L); cout &lt;&lt; num[a]; if (i !&#x3D; tmp - 1)cout &lt;&lt; endl; &#125; return 0;&#125; 心得这道题是单向无权图—&gt;BFS 题目编号从1-N；建图应该从1到N方便 记录BFS遍历图的层数，在结点结构体中添加层数信息。在BFS中更新。 BFS跟Dijkstra的区别：BFS只要访问到邻接点，邻接点就要被收录而不用再通过邻接点去做松弛操作更新它的邻接点的最小路径","comments":true,"categories":[{"name":"pat","slug":"pat","permalink":"https://github.com/HuanghualiWood/blog/categories/pat/"}],"tags":[{"name":"BFS","slug":"BFS","permalink":"https://github.com/HuanghualiWood/blog/tags/BFS/"},{"name":"BFS如何记录层数","slug":"BFS如何记录层数","permalink":"https://github.com/HuanghualiWood/blog/tags/BFS%E5%A6%82%E4%BD%95%E8%AE%B0%E5%BD%95%E5%B1%82%E6%95%B0/"}]},{"title":"Samba服务器","date":"2019-02-09T16:00:00.000Z","path":"2019/02/10/SAMBA服务器/","text":"samba的功能 共享文件和打印机服务 身份认证，提供不同身份用户的个别数据 进行window网络上的主机名解析 可以进行设备的共享 samba常见的应用 1利用软件直接剪辑www主机上面的网页数据 做成可以直接连接的文件服务器 打印机服务器 samba使用的NetBIOS通信协议 samba使用的daemons nmbd 这个daemon用来管理工作组，NetBIOS Name 等解析。主要利用UDP协议开启port137，138来负责名称解析的任务 smbd 这个daemon主要功能用来管理samba主机共享的目录，文件与打印机等。利用可靠的TCP协议来传输数据，开放的端口139及445 连接模式（Peer/Peer（对等模式），Domain model（主控模式））","comments":true,"categories":[{"name":"网络","slug":"网络","permalink":"https://github.com/HuanghualiWood/blog/categories/%E7%BD%91%E7%BB%9C/"}],"tags":[{"name":"萌新","slug":"萌新","permalink":"https://github.com/HuanghualiWood/blog/tags/%E8%90%8C%E6%96%B0/"}]},{"title":"C Base","date":"2018-07-08T08:12:24.000Z","path":"2018/07/08/c语言学习/","text":"7/9/2018 4:12:24 PM [TOC] 二.数据和C1.e（数学科学记数法用指数表示法显示数字，以 E+n 替换部分数字，其中 E（代表指数）表示将前面的数字乘以 10 的 n 次幂。例如，用 2 位小数的“科学记数”格式表示 12345678901，结果为 1.23E+10，即 1.23 乘以 10 的 10 次幂。您可以指定要使用的小数位数。 2.浮点数（浮点数网站详解）: 浮点数:是指小数点在数据中的位置可以左右移动的数据。它通常被表示成： N = M* RE 这里的M(Mantissa)被称为浮点数的尾数，R(Radix)被称为阶码的基数，E(Exponent)被称为阶的阶码。 1.2345 × 102，其中 1.2345 为尾数，10为基数，2 为指数 尾数实际上是有 >>尾数有时也称为有效数字（Significand） 为什单精度实际的指数表达范围在-127~127之间? 其中单精度数为 8 位，双精度数为 11 位。以单精度数为例，8 位的指数为可以表达 0 到 255 之间的 255 个指数值。但是，指数可以为正数，也可以为负数。为了处理负指数的情况，实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值，单精度数的偏差值为 127，而双精度数的偏差值为 1023。比如，单精度的实际指数值 0 在指数域中将保存为 127；而保存在指数域中的 64 则表示实际的指数值 -63。偏差的引入使得对于单精度数，实际可以表达的指数值的范围就变成-127 到128 之间（包含两端）。我们不久还将看到，实际的指数值-127（保存为全 0）以及 +128（保存为全 1）保留用作特殊值的处理。这样，实际可以表达的有效指数范围就在 -127 和 127 之间。在本文中，最小指数和最大指数分别用 emin 和 emax 来表达 计算机中一般规定R为2、8或16、是一个确定的常数，不需要在浮点数中明确表示出来。因此，要表示浮点数，一是要给出尾数M的值，通常用定点小数形式表示，它决定了浮点数的表示精度，即可以给出的有效数字的位数。二是要给出阶码，通常用整数形式表示，它指出的是小数点在数据中的位置，决定了浮点数的表示范围。浮点数也要有符号位。 - floating-point 差不多可以和数学中的实数概念相对应 浮点数和整数的区别： ![浮点数](https://s4.51cto.com/oss/201711/09/1afceb11e5df90996dddd0060587c3cd.jpg) |浮点数|符号位|阶码|尾数|总位数| |-|-|-|-|-| |短浮点数 |1|8|23|32| |长浮点数 |1|11|52|64| |临时浮点数 |1|15|64|80| 对短浮点数和长浮点数，当其尾数不为0值时，其最高一位必定为1，在将这样的浮点数写入内存或磁盘时，不必给出该位，可左移一位去掉它，这种处理技术称为隐藏位技术，目的是用同样多位的尾数能多保存一位二进制位。在将浮点数取回运算器执行运算时，再恢复该隐藏位的值。对临时浮点数，不使用隐藏位技术。 浮点数的运算法则[百度](https://baike.baidu.com/item/%E7%A7%BB%E7%A0%81/10165919?fr=aladdin) ## [补充补码，反码,移码](https://www.cnblogs.com/sunfan1988/p/3850242.html)【详细】 源码、反码、补码、移码在计算机中是怎么运算的？ 数值有正负之分,计算机就用一个数的最高位存放符号(0为正,1为负).这就是机器数的原码了.假设机器能处理的位数为8.即字长为1byte,原码能表示数值的范围为 127~（-127） 另外，我们需要知道，在计算机中都是以补码的储存负数的（正数的补码等于他本身，所以也可以理解为计算机储存的是补码），那么我们从源码->>>反码的过程其实是为了计算补码的一个计算的过程。 运算过程：原码->反码->补码->移码 原码 :二进制（开头第一个表示符号0正1负） 反码 ：在原码的基础上，符号位不动，其他位取反 ---注意，任何正数的源码=反码=补码，而负数都是通过补码表示的。 补码 ：在反码的基础上，运算+1 ---注意，任何正数的源码=反码=补码，而负数都是通过补码表示的。 用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。 引入移码的目的：用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。而实际上这个数是无限接近于零的。那么我们就需要取出其中的 \"-0\" 值作为机器零。 公式：两数补码的和==两数和的补码。 移码 ：在补码的基础上，符号位取反 负数的存储：c语言中，负数以整数的补码存储 101011（二进制）--> 原码 00101011 --> 反码 01010100 --> 补码 01010101--> 移码 11010101 二进制运算 逢二进一，结果写0 例题1用补码计算2-9 - # 三.数据类型 ![c语言数据类型](https://blog.csdn.net/wfreehorse/article/details/60589326.jpg) ![类型](http://c.biancheng.net/cpp/uploads/allimg/120205/1-120205162A4H8.jpg) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081#include &lt;stdlib.h&gt;#include &lt;inttypes.h&gt;void main()&#123; &#x2F;*int x &#x3D;2; printf(&quot;dec&#x3D;%d;octal&#x3D;%o;hex&#x3D;%x\\n&quot;,x,x,x);&#x2F;&#x2F;显示八进制十六进制 printf(&quot;dec&#x3D;%d;octal&#x3D;%#o;hex&#x3D;%#x\\n&quot;,x,x,x);&#x2F;&#x2F;%o %x &#x2F;*****整数溢出******* int i&#x3D;2147483647; unsigned int j&#x3D;4294967295; printf(&quot;%d;%d;%d\\n&quot;,i,i+1,i+2); printf(&quot;%u;%u;%u\\n\\n\\n&quot;,j,j+1,j+2);&#x2F;&#x2F;无符号整型达到最大值时，将溢出到起始点；而int型的起始点是-2147483647 &#x2F;*******打印short long,longlong,和unsigned类型数********* &#x2F;&#x2F;使用修饰符h可以显示一个较长的整数被截成short类型的样子 &#x2F;&#x2F;在传递参数数时，c会自动将short类型的值转换为int类型。int类型被认为是计算机处理起来最方便有效的的整数类型 unsigned int un &#x3D;3000000000; short end&#x3D;200; long big&#x3D;65537; long long verybig&#x3D;12345678908642; printf(&quot;un&#x3D;%u and not un&#x3D;%d\\n&quot;,un,un); printf(&quot;end&#x3D;%hd and not %d\\n&quot;,end,end); printf(&quot;big&#x3D;%ld and not %hd\\n&quot;,big,big); printf(&quot;verybig&#x3D;%lld and not %ld\\n&quot;,verybig,verybig); &#x2F;****非打印字符*** &#x2F;&#x2F;一些动作描述是打印不出来的例如退格，换行，走纸让终端铃响。一，使用ASCⅡ码二，使用转义序列（escape sequence） char beep&#x3D;&#39;\\007&#39;; printf(&quot;hello\\a\\n&quot;);&#x2F;&#x2F;发出警报声 &#x2F;***可移植的指数类型inttypes.h*** &#x2F;&#x2F;C99标准提供了一些串宏来打印这些可移植类型例如inttype.h头文件将定义串PRId16表示打印16位有符号值 int16_t me16; me16&#x3D;4593; printf(&quot;me16&#x3D;%hd\\n&quot;,me16); printf(&quot;me16&#x3D;%&quot;PRId16&quot;\\n&quot;,me16); &#x2F;***float double 和longdouble型***&#x2F; &#x2F;&#x2F;浮点常量：使用f或F后缀使编译器把浮点常量当作float型比如2.3f和9.11E9F &#x2F;&#x2F;*用%e打印指数计数法的数字 float double型都用%f，%e，%a说明符打印* float aboat &#x3D;32000.0; double abet &#x3D;2.14e9; long double dip &#x3D;5.32e-5; printf(&quot;%f %e\\n&quot;,aboat,aboat); printf(&quot;%f %e\\n&quot;,abet,abet); printf(&quot;%f %e\\n&quot;,dip,dip);&#x2F;&#x2F;??? &#x2F;&#x2F;*浮点值的上溢和下溢 float toobig&#x3D;3.4e38*100.0f; printf(&quot;%e&quot;,toobig); &#x2F;&#x2F;练习2,输入一个ascⅡ码，然后输出相应的字符 int a; char ch; printf(&quot;输入一个整数\\n&quot;); scanf(&quot;%d&quot;,&amp;a); ch&#x3D;a; printf(&quot;%c\\n&quot;,ch); &#x2F;&#x2F;练习3，输入一个字母，输出其ascⅡ码 getchar(); int b; char fi; printf(&quot;输入一个小写字母&quot;); scanf(&quot;%c&quot;,&amp;fi); b&#x3D;fi-32; printf(&quot;ascⅡ为%d&quot;,b); getchar(); *&#x2F; &#x2F;&#x2F;练习3读入一个浮点数，分别以小数形式和指数形式输出 float c; scanf(&quot;%f\\n&quot;,&amp;c); printf(&quot;%e\\n%0.1f\\n&quot;,c,c); return 0;&#125; # 四.字符串和格式化输入/输出 - strlen() - const - print() 和 scanf() - 使用c预处理器#define指令和ANSIC的const修饰符创建符号常量 使用%s的scanf()只会把第一个字符串读入 C使用读取输入函数 （例如gets（））来处理一般的字符串 常量和C预处理器 格式：#define 其次常量一般大写 >4.3.1 **const修饰符** >C90新增了一种创建符号常量的第二种方法。使用const把一个变量声明转换成常量 const int MONTHS=12; >4.3.2**系统定义的明显常量** 头文件limits.h和float.h 1.sizeof()运算符:以字节为单位给出数据的大小 2.strlen（）函数：以字符为单位给出字符串的长度 string.h提供函数原型 printf函数 ## printf格式说明符p71 说明符 | 功能 - | :-: | %d|有符号十进制整形 %f|单精度浮点数，小数点后保留6位 %lf|双浮点精度 %c|输出一个字符 %s|按实际输出字符串 %e|按指数格式输出 %g|按输出较小原则，自动按%f或%e原则输出浮点数 %o|八进制数 %x|十进制数 %p|输出指针的地址 printf()说明修饰符 修饰符 | 功能 - |:-:| -|左对齐 :%-20s: +|显示正负号 :%+6.2f 空格|有符号的值若为正，则显示是带前导空格（不现实正号），若为扶，则显示符号 \\#|显示数据格式 0|用前导零而不是空格填充字段宽度，如果出现-标志或者指定了精度，则忽略该标志:%010d %08.3f .digits|精度 ：%5.2f（字段宽度为五个字符，五位有效数字，保留2位小数） （易混）ll|unsigned long long int %8llu t|和整数转换说明符一起使用，表示一个ptrdiff_t值（与两个指针之间的差相对应的类型）%td %12ti z|和整数说明符一起使用，表示一个size_t值（sizeof返回的类型）%zd %12zx >printf()分割字符串（字符串较长时）的三种方法 >1.多个printf（）语句 >2.使用反斜杠\\和回车键组合来结束第一行 >3.采用字符串连接的方法 ## scanf()函数 转换说明符和转换修饰符与printf（）类似p79 **scanf()的返回值**（后面讲到） 如果它没有读取任何项目（当它期望一个数字而你却键入了一个非数字字符串时就会发生这种情况），scanf()会返回值0.当它检测到“文件结尾”（end of file），它返回EOF（EOF是stdio.h中定义的特殊值） 【重点】 ## 4.4.6printf()和scanf()的*的修饰符 printf()用法：使用代替数字，使用可变参数确定字段宽度的值scanf()*的作用：使函数跳过相应的输入项目 如果程序需要读取一个文件中某个特定的列（该文件的数据以统一的列排列），那么该功能将非常有用 123456789101112131415161718192021222324252627282930313233343536373839&#x2F;&#x2F;第四章练习#include&lt;stdlib.h&gt;#include&lt;string.h&gt;#include&lt;float.h&gt;int main(void)&#123; &#x2F;* &#x2F;&#x2F;2.4输入名字，在比名字宽三个字符发字段内打印它 char ming[40],xing[40]; printf(&quot;输入名字&quot;); scanf(&quot;%s&quot;,&amp;ming); int a&#x3D;strlen(ming); printf(&quot;\\&quot;%s\\&quot;\\n&quot;,ming); printf(&quot;\\&quot;%20s\\&quot;\\n&quot;,ming); printf(&quot;\\&quot;%*s\\&quot;\\n&quot;,a+3,ming);&#x2F;&#x2F;程序清单4.16使用可变宽度的输出字段 &#x2F;&#x2F;3. float a&#x3D;21.3; printf(&quot;The input %0.1f is%0.1e\\n&quot;,a,a); &#x2F;&#x2F;5 输入名字，在第一行打印输入的姓名，在下一行打印每个名字中字母的个数，把字母个数与相应名字的结尾对齐 char xing[40],name[40]; printf(&quot;分别输入姓氏名字\\n&quot;); scanf(&quot;%s&quot;,&amp;xing); getchar(); scanf(&quot;%s&quot;,&amp;name); printf(&quot;%s\\t&quot;,xing); printf(&quot;%s\\n&quot;,name); printf(&quot;%*d\\t%*d\\n&quot;,strlen(xing),strlen(xing),strlen(name),strlen(name)); *&#x2F; &#x2F;&#x2F;6. double num1&#x3D;1.0&#x2F;3.0; float num2&#x3D;1.0&#x2F;3.0; printf(&quot;%.4f,%.12f,%.16f\\n&quot;,num1,num1,num1); printf(&quot;%.4f,%.12f,%.16f\\n&quot;,num2,num2,num2); printf(&quot;%d %d\\n&quot;,FLT_DIG,DBL_DIG); return 0;&#125; 五.运算符，表达式和语句 如何编写带有参数的函数 typedef 复合语句，自动类型和类型指派 1.基本运算符：=+-*/2.其它运算符： sizeof运算符和size_t类型 取模运算符%：modulus operater用于整数运算。该运算计算出用它右边的整数去除它左边的整数得到的余数。如果第一个操作数为负数，那么得到的模也为负数 增量运算符和减量运算符:++ —前缀q=++a：a先自增1然后赋值给q后缀q=a++:a先赋值给q然后再自增1 //先使用n然后将它的值增加 优先级() ++ — 5.4副作用和顺序点 副作用：是对数据对象或文件的修改 例如states=50的副作用是将变量的的值设置为50.跟赋值运算符一样，增量减量运算符也有副作用，它们主要由于副作用而被应用顺序点：是程序执行中的一点，在该点处，所有副作用都在进入下一步前被计算 表达式是运算符和操作数的组合语句分为简单语句和复合语句或代码块block 5.5类型转换 程序清单5.14 指派运算符：作用避免自动类型转换，避免降级 int mice; mice=1.6+1.7; mice=(int)1.6+(int)1.7 5.6带有参数的函数 123456789101112131415161718#include&lt;stdio.h&gt;void pound(int n); &#x2F;&#x2F;ANSI风格的原型int main(void)&#123; int times&#x3D;5; char ch&#x3D;&#39;!&#39;; float f&#x3D;6.0; pound(times); pound(ch); pound((int)f); return 0;&#125;void pound(int n)&#123; while(n--&gt;0) printf(&quot;#&quot;); printf(&quot;\\n&quot;);&#125; ## 形参和实参 - 形参：全称为“形式参数”是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。 - 实参：可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263#include&lt;stdlib.h&gt;const float f&#x3D;1.8 , b&#x3D;32.0;void pfh(int n);void temp(float a);pfh(int n) &#123; int a; a&#x3D;n*n; printf(&quot;%d\\n&quot;,a); &#125; temp(a) &#123; float t&#x3D;f*a+b; float k&#x3D;t+273.16; printf(&quot;Celsius&#x3D;%.2f\\n&quot;,t); printf(&quot;kelvin&#x3D;%.2f\\n&quot;,k); &#125; int main(void) &#123; &#x2F;*int num&#x3D;1; while(num&lt;10) &#123; printf(&quot;%4d %6d\\n&quot;,num,num*num); num&#x3D;num+1; &#125; &#x2F;&#x2F;sizeof.c int n&#x3D;1111; size_t intsize; intsize&#x3D;sizeof(n); printf(&quot;n&#x3D;%d,n has %lubytes;all ints have%lu bytes.\\n&quot;,n,sizeof n,intsize); &#x2F;&#x2F;取模运算符% &#x2F;&#x2F;把秒转换为分 int min,sec,left; printf(&quot;输入秒钟&quot;); scanf(&quot;%d&quot;,&amp;sec); min&#x3D;sec&#x2F;60; left&#x3D;sec%60; printf(&quot;%d seconds is %dminutes,%dseconds&quot;,sec,min,left); &#x2F;&#x2F;数据类型自动转换 char ch; int i; float f1; f1&#x3D;i&#x3D;ch&#x3D;&#39;C&#39;; printf(&quot;ch &#x3D;%c,i&#x3D;%d,f1&#x3D;%f\\n&quot;,ch,i,f1); ch&#x3D;ch+1; i&#x3D;f1+2*ch; f1&#x3D;2.0*ch+i; printf(&quot;ch &#x3D;%c,i&#x3D;%d,f1&#x3D;%f\\n&quot;,ch,i,f1); ch&#x3D;70.17; printf(&quot;ch&#x3D;%c&quot;,ch); *&#x2F; &#x2F;&#x2F;练习5计算平方和 int n; printf(&quot;输入一个整数\\n&quot;); scanf(&quot;%d&quot;,&amp;n); pfh(n); &#x2F;&#x2F;练习8 温度转换 float t; printf(&quot;输入温度\\n&quot;); scanf(&quot;%.2f&quot;,&amp;t); temp(t); return 0;&#125; # 六.C控制语句：循环 >==== >**** >- for >- while >- do while >- 运算符+= /= %= >- 循环中常用的数组 >- 编写具有返回值的函数 >**** >fabs()函数：math.h头文件中 可以方便的进行浮点判断，返回一个浮点值的绝对值 >程序员最常用while(goats) ==while(!=goats) >6.3.4新的_Bool类型 >运算符优先级 >![3](https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg) >for循环p131 >>**** >>- 用字符代替数字来进行计数 >>- 不仅可以限制循环次数还可以限制立方的大小 >for（num=1;num*num*num可以让一个或多个表达式为空 >第一个表达式不必初始化一个变量，它也可以是某种类型的printf（）语句 >第一个表达式只在执行其它循环部分之前被求值；或被执行一次 >更多赋值运算符 >>*** · | 说明 -|:-:| += | a+=2 == a=a+2 -=|a-=2 == a=a-2 *=| \\=| %=| >逗号运算符：扩展了for循环的灵活性，可以在一个for循环中使用多个初始化或更新表达式 > >#include >int main(void) >{ >const int FIRST_OZ=37; >const int NEXT_OZ=23; >int ounces,cost; >printf(\"ounces cost\\n\"); >for(ounces=1,cost=FIRST_OZ;ouncesprintf(\"%5d $%4.2f\\n\",ounces,cost/100.0); >return 0; >} >do while:循环必须被执行一次 >6.1嵌套循环 通常用来按行按列来显示数据 >嵌套变化 > >*** # 七.章分支和跳转 >=== >7.2.1 getchar()和putchar(): >>>在文件有定义 专门为面向字符I/O设计的c函数 > >系列字符函数 > > 函数名 | 为如下参数时，返回值为真 -|:-:| - isalnum() | 字母数字 - isalpha | 字母 - isblank | 一个标准的空白字符 - iscntrl | 控制符 - isdigit|阿拉伯数字 - isgraph|除空格之外的所有可打印字符 - islower|小写字母 - isprint|可打印字符 - ispunct|标点符号 - isspace|空白字符：空格，换行，走纸，回车 - isupper|大写字母 - isxdigit|十六进制数字字符 >> - | 字符映射函数 -|:-:| -tolower|如果参数是大写字母，返回相应的小写字母否则，返回原始参数 -toupper|如果参数是小写字母，返回相应的大写字母 >**** >isalpha（）函数的参数是个字母，则它返回一个非零值 > 映射函数并不改变原始的参数,它们只会返回改变后的值 >tolower(ch) >ch=tolower(ch)//把ch转换为小写 > >7.1 if 语句 >判断一个数是不是素数. >/* divisors.c -- 使用嵌套if显示一个数的约数*/ >#include >#include >int main(void) { unsigned long num; // 要检查的数 unsigned long div; // 可能的约数 bool isPrime; // 素数的标志 printf(\"Please enter an integer for analysis: \"); printf(\"Enter q to quit/\\n\"); while (scanf(\"%lu\",&num)==1) { for (div = 2, isPrime = true; (div*div)","comments":true,"categories":[{"name":"菜鸟语法","slug":"菜鸟语法","permalink":"https://github.com/HuanghualiWood/blog/categories/%E8%8F%9C%E9%B8%9F%E8%AF%AD%E6%B3%95/"}],"tags":[{"name":"c base","slug":"c-base","permalink":"https://github.com/HuanghualiWood/blog/tags/c-base/"}]},{"title":"Ps","date":"2018-06-13T02:01:11.000Z","path":"2018/06/13/ps/","text":"ps素描方法:1去色，查找边缘，成角的线条，图册混合模式，颜色减淡2去色，反相，最小值，混合选项，创建空白图层，选区羽化，添加蒙版，添加杂色，填充rgb240x3的图层蒙版：图层蒙版 剪贴蒙版 Crtl+Shift+G矢量蒙版快速蒙版通道：颜色通道:存储颜色专色通道 增强画质第一，先打开原图，双击解锁。第二，CTRL+J创建副本养成好习惯。对副本模式选择“亮度”第三，选择“滤镜”菜单下的“锐化—USM锐化”命令，在设置窗口中适当调节一下锐化参数，根据你原图模糊的情况来调节，第四，经过第三步，为照片清晰大致做了个基础。接着选择“图像”菜单下“模式—LAB颜色”命令，在弹出的窗口中选择“拼合”图层确定。在LAB模式下，再创建副本。第六， 在“通道”面板中看到图层通道上有了“明度”通道，选定这个通道，再使用“滤镜”菜单的“锐化—USM锐化”命令，设置好锐化参数将这个通道锐化处第七，返回图层面板，把副本图层的模式修改为“柔光”，调节透明度为30%。看看此时的图像不仅画面更清晰，色彩也更加绚丽了。（这部可根据自己的照片情况增删）","comments":true,"categories":[],"tags":[{"name":"ps note","slug":"ps-note","permalink":"https://github.com/HuanghualiWood/blog/tags/ps-note/"}]},{"title":"Hello World","date":"2018-01-31T16:00:00.000Z","path":"2018/02/01/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","comments":true,"categories":[],"tags":[{"name":"萌新","slug":"萌新","permalink":"https://github.com/HuanghualiWood/blog/tags/%E8%90%8C%E6%96%B0/"}]},{"title":"Markdown语法","date":"2018-01-31T16:00:00.000Z","path":"2018/02/01/markdown语法/","text":"12345678910111213141516&lt;div style&#x3D;&#39;display: none&#39;&gt;哈哈我是注释，不会在浏览器中显示。&lt;&#x2F;div&gt;- 标题# 一级标题## 二级标题### 三级标题#### 四级标题##### 五级标题###### 六级标题 &lt;!--最多6级标题--&gt;- 任务列表- [ ] 任务一 未做任务 &#96;- + 空格 + [ ]&#96;- [x] 任务二 已做任务 &#96;- + 空格 + [x]&#96;- 哈哈我是注释，不会在浏览器中显示。 标题 一级标题二级标题三级标题四级标题五级标题六级标题 任务列表 [ ] 任务一 未做任务 - + 空格 + [ ] [x] 任务二 已做任务 - + 空格 + [x] 1234567【1】 &amp;emsp;或&amp;#8195; &#x2F;&#x2F;全角【2】 &amp;ensp;或&amp;#8194; &#x2F;&#x2F;半角【3】 &amp;nbsp;或&amp;#160; &#x2F;&#x2F;半角之半角&lt;center&gt;行中心对齐&lt;&#x2F;center&gt;&lt;p align&#x3D;&quot;left&quot;&gt;行左对齐&lt;&#x2F;p&gt;&lt;p align&#x3D;&quot;right&quot;&gt;行右对齐&lt;&#x2F;p&gt; 【1】 &emsp;或&#8195; //全角【2】 &ensp;或&#8194; //半角【3】 &nbsp;或&#160; //半角之半角 行中心对齐 行左对齐 行右对齐 1234567891011&gt;*斜体*或_斜体_&gt;**粗体**&gt;***加粗斜体***&gt;~~删除线~~&gt;++下划线++&gt;&#x3D;&#x3D;背景高亮&#x3D;&#x3D; 斜体或_斜体_ 粗体 加粗斜体 删除线 ++下划线++ ==背景高亮==123456&lt;font face&#x3D;&quot;黑体&quot;&gt;我是黑体字&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;微软雅黑&quot;&gt;我是微软雅黑&lt;&#x2F;font&gt;&lt;font face&#x3D;&quot;STCAIYUN&quot;&gt;我是华文彩云&lt;&#x2F;font&gt;&lt;font color&#x3D;#0099ff size&#x3D;12 face&#x3D;&quot;黑体&quot;&gt;黑体&lt;&#x2F;font&gt;&lt;font color&#x3D;gray size&#x3D;5&gt;gray&lt;&#x2F;font&gt;&lt;font color&#x3D;#00ffff size&#x3D;3&gt;null&lt;&#x2F;font&gt; 我是黑体字 我是微软雅黑 我是华文彩云 黑体 gray null 123456* 无序列表项 一+ 无序列表项 二- 无序列表项 三1. 有序列表项 一2. 有序列表项 二3. 有序列表项 三 无序列表项 一 无序列表项 二 无序列表项 三 有序列表项 一 有序列表项 二 有序列表项 三 123456789101112131415161718192021222324252627&lt;center&gt; &lt;!--开始居中对齐--&gt;![GitHub set up](http:&#x2F;&#x2F;zh.mweb.im&#x2F;asset&#x2F;img&#x2F;set-up-git.gif &quot;图片Title&quot;)![图片Alt](图片地址 &quot;图片Title&quot;)&lt;&#x2F;center&gt; &lt;!--结束居中对齐--&gt;&gt;- 超链接&gt;欢迎阅读 [择势勤](https:&#x2F;&#x2F;www.jianshu.com&#x2F;u&#x2F;16d77399d3a7 &quot;择势勤&quot;)&gt;网站[Google][1]、[Leanote][2]。[1]:http:&#x2F;&#x2F;www.google.com [2]:http:&#x2F;&#x2F;www.leanote.com- 注脚使用 Markdown[^1]可以效率的书写文档, 直接转换成 HTML[^2]。[^1]:Markdown是一种纯文本标记语言[^2]:HyperText Markup Language 超文本标记语言- 在段落填写[TOC]以显示全文内容的目录结构[TOC] &lt;/center&gt; 超链接 欢迎阅读 择势勤 网站Google、Leanote。 注脚使用 Markdown1可以效率的书写文档, 直接转换成 HTML2。 2:HyperText Markup Language 超文本标记语言 在段落填写[TOC]以显示全文内容的目录结构[TOC] 12345include &lt;stdio.h&gt;int main(void)&#123;printf(&quot;Hello world\\n&quot;);&#125; 学号 姓名 序号 小明明 男 5 小红 女 79 小陆 男 192 摘自 简书","comments":true,"categories":[{"name":"basic","slug":"basic","permalink":"https://github.com/HuanghualiWood/blog/categories/basic/"}],"tags":[{"name":"markdown","slug":"markdown","permalink":"https://github.com/HuanghualiWood/blog/tags/markdown/"}]}]}