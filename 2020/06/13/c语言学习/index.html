<!DOCTYPE html>
<html lang="cn">
    <!-- title -->




<!-- keywords -->




<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no" >
    <meta name="author" content="minhao">
    <meta name="renderer" content="webkit">
    <meta name="copyright" content="minhao">
    
    <meta name="keywords" content="hexo,hexo-theme,hexo-blog,huanghualiwood">
    
    <meta name="description" content="">
    <meta http-equiv="Cache-control" content="no-cache">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1"/>
    <title>Hello World · huanghualiwood</title>
    <style type="text/css">
    @font-face {
        font-family: 'Oswald-Regular';
        src: url("/blog/font/Oswald-Regular.ttf");
    }

    body {
        margin: 0;
    }

    header,
    footer,
    .back-top,
    .sidebar,
    .container,
    .site-intro-meta,
    .toc-wrapper {
        display: none;
    }

    .site-intro {
        position: relative;
        z-index: -2;
        width: 100%;
        height: 50vh; 
        overflow: hidden;
    }

    .site-intro-placeholder {
        position: absolute;
        z-index: -2;
        top: 0;
        left: 0;
        width: calc(100% + 300px);
        height: 100%;
        background: repeating-linear-gradient(-45deg, #444 0, #444 80px, #333 80px, #333 160px);
        background-position: center center;
        transform: translate3d(-226px, 0, 0);
        animation: gradient-move 2.5s ease-out 0s infinite;
    }

    @keyframes gradient-move {
        0% {
            transform: translate3d(-226px, 0, 0);
        }
        100% {
            transform: translate3d(0, 0, 0);
        }
    }

</style>

    <link rel="preload" href= "/blog/css/style.css?v=20180824" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    <link rel="stylesheet" href= "/blog/css/mobile.css?v=20180824" media="(max-width: 980px)">
    
    <link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.css" as="style" onload="this.onload=null;this.rel='stylesheet'" />
    
    <!-- /*! loadCSS. [c]2017 Filament Group, Inc. MIT License */
/* This file is meant as a standalone workflow for
- testing support for link[rel=preload]
- enabling async CSS loading in browsers that do not support rel=preload
- applying rel preload css once loaded, whether supported or not.
*/ -->
<script>
(function( w ){
	"use strict";
	// rel=preload support test
	if( !w.loadCSS ){
		w.loadCSS = function(){};
	}
	// define on the loadCSS obj
	var rp = loadCSS.relpreload = {};
	// rel=preload feature support test
	// runs once and returns a function for compat purposes
	rp.support = (function(){
		var ret;
		try {
			ret = w.document.createElement( "link" ).relList.supports( "preload" );
		} catch (e) {
			ret = false;
		}
		return function(){
			return ret;
		};
	})();

	// if preload isn't supported, get an asynchronous load by using a non-matching media attribute
	// then change that media back to its intended value on load
	rp.bindMediaToggle = function( link ){
		// remember existing media attr for ultimate state, or default to 'all'
		var finalMedia = link.media || "all";

		function enableStylesheet(){
			link.media = finalMedia;
		}

		// bind load handlers to enable media
		if( link.addEventListener ){
			link.addEventListener( "load", enableStylesheet );
		} else if( link.attachEvent ){
			link.attachEvent( "onload", enableStylesheet );
		}

		// Set rel and non-applicable media type to start an async request
		// note: timeout allows this to happen async to let rendering continue in IE
		setTimeout(function(){
			link.rel = "stylesheet";
			link.media = "only x";
		});
		// also enable media after 3 seconds,
		// which will catch very old browsers (android 2.x, old firefox) that don't support onload on link
		setTimeout( enableStylesheet, 3000 );
	};

	// loop through link elements in DOM
	rp.poly = function(){
		// double check this to prevent external calls from running
		if( rp.support() ){
			return;
		}
		var links = w.document.getElementsByTagName( "link" );
		for( var i = 0; i < links.length; i++ ){
			var link = links[ i ];
			// qualify links to those with rel=preload and as=style attrs
			if( link.rel === "preload" && link.getAttribute( "as" ) === "style" && !link.getAttribute( "data-loadcss" ) ){
				// prevent rerunning on link
				link.setAttribute( "data-loadcss", true );
				// bind listeners to toggle media back
				rp.bindMediaToggle( link );
			}
		}
	};

	// if unsupported, run the polyfill
	if( !rp.support() ){
		// run once at least
		rp.poly();

		// rerun poly on an interval until onload
		var run = w.setInterval( rp.poly, 500 );
		if( w.addEventListener ){
			w.addEventListener( "load", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		} else if( w.attachEvent ){
			w.attachEvent( "onload", function(){
				rp.poly();
				w.clearInterval( run );
			} );
		}
	}


	// commonjs
	if( typeof exports !== "undefined" ){
		exports.loadCSS = loadCSS;
	}
	else {
		w.loadCSS = loadCSS;
	}
}( typeof global !== "undefined" ? global : this ) );
</script>

    <link rel="icon" href= "/blog/assets/favicon.ico" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js" as="script" />
    <link rel="preload" href="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js" as="script" />
    <link rel="preload" href="/blog/scripts/main.js" as="script" />
    <link rel="preload" as="font" href="/blog/font/Oswald-Regular.ttf" crossorigin>
    <link rel="preload" as="font" href="https://at.alicdn.com/t/font_327081_1dta1rlogw17zaor.woff" crossorigin>
    
    <!-- fancybox -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.2.5/jquery.fancybox.min.js" defer></script>
    <!-- 百度统计  -->
    
    <!-- 谷歌统计  -->
    
</head>

    
        <body class="post-body">
    
    
<header class="header">

    <div class="read-progress"></div>
    <div class="header-sidebar-menu">&#xe775;</div>
    <!-- post页的toggle banner  -->
    
    <div class="banner">
            <div class="blog-title">
                <a href="/blog/" >minhao的BLOG</a>
            </div>
            <div class="post-title">
                <a href="#" class="post-name">Hello World</a>
            </div>
    </div>
    
    <a class="home-link" href=/blog/>minhao的BLOG</a>
</header>
    <div class="wrapper">
        <div class="site-intro" style="







height:70vh;
">
    
    <!-- 主页  -->
    
    
    <!-- 404页  -->
            
    <div class="site-intro-placeholder"></div>
    <div class="site-intro-img" style="background-image: url(/blog/intro/post-bg.jpg)"></div>
    <div class="site-intro-meta">
        <!-- 标题  -->
        <h1 class="intro-title">
            <!-- 主页  -->
            
            Hello World
            <!-- 404 -->
            
        </h1>
        <!-- 副标题 -->
        <p class="intro-subtitle">
            <!-- 主页副标题  -->
            
            
            <!-- 404 -->
            
        </p>
        <!-- 文章页meta -->
        
            <div class="post-intros">
                <!-- 文章页标签  -->
                
                    <div class= post-intro-tags >
    
        <a class="post-tag" href="javascript:void(0);" data-tags = "c base">c base</a>
    
</div>
                
                
                    <div class="post-intro-read">
                        <span>字数统计: <span class="post-count word-count">5.4k</span>阅读时长: <span class="post-count reading-time">21 min</span></span>
                    </div>
                
                <div class="post-intro-meta">
                    <span class="post-intro-calander iconfont-archer">&#xe676;</span>
                    <span class="post-intro-time">2020/06/13</span>
                    
                    <span id="busuanzi_container_page_pv" class="busuanzi-pv">
                        <span class="iconfont-archer">&#xe602;</span>
                        <span id="busuanzi_value_page_pv"></span>
                    </span>
                    
                    <span class="shareWrapper">
                        <span class="iconfont-archer shareIcon">&#xe71d;</span>
                        <span class="shareText">Share</span>
                        <ul class="shareList">
                            <li class="iconfont-archer share-qr" data-type="qr">&#xe75b;
                                <div class="share-qrcode"></div>
                            </li>
                            <li class="iconfont-archer" data-type="weibo">&#xe619;</li>
                            <li class="iconfont-archer" data-type="qzone">&#xe62e;</li>
                            <li class="iconfont-archer" data-type="twitter">&#xe634;</li>
                            <li class="iconfont-archer" data-type="facebook">&#xe67a;</li>
                        </ul>
                    </span>
                </div>
            </div>
        
    </div>
</div>
        <script>
 
  // get user agent
  var browser = {
    versions: function () {
      var u = window.navigator.userAgent;
      return {
        userAgent: u,
        trident: u.indexOf('Trident') > -1, //IE内核
        presto: u.indexOf('Presto') > -1, //opera内核
        webKit: u.indexOf('AppleWebKit') > -1, //苹果、谷歌内核
        gecko: u.indexOf('Gecko') > -1 && u.indexOf('KHTML') == -1, //火狐内核
        mobile: !!u.match(/AppleWebKit.*Mobile.*/), //是否为移动终端
        ios: !!u.match(/\(i[^;]+;( U;)? CPU.+Mac OS X/), //ios终端
        android: u.indexOf('Android') > -1 || u.indexOf('Linux') > -1, //android终端或者uc浏览器
        iPhone: u.indexOf('iPhone') > -1 || u.indexOf('Mac') > -1, //是否为iPhone或者安卓QQ浏览器
        iPad: u.indexOf('iPad') > -1, //是否为iPad
        webApp: u.indexOf('Safari') == -1, //是否为web应用程序，没有头部与底部
        weixin: u.indexOf('MicroMessenger') == -1, //是否为微信浏览器
        uc: u.indexOf('UCBrowser') > -1 //是否为android下的UC浏览器
      };
    }()
  }
  console.log("userAgent:" + browser.versions.userAgent);

  // callback
  function fontLoaded() {
    console.log('font loaded');
    if (document.getElementsByClassName('site-intro-meta')) {
      document.getElementsByClassName('intro-title')[0].classList.add('intro-fade-in');
      document.getElementsByClassName('intro-subtitle')[0].classList.add('intro-fade-in');
      var postIntros = document.getElementsByClassName('post-intros')[0]
      if (postIntros) {
        postIntros.classList.add('post-fade-in');
      }
    }
  }

  // UC不支持跨域，所以直接显示
  function asyncCb(){
    if (browser.versions.uc) {
      console.log("UCBrowser");
      fontLoaded();
    } else {
      WebFont.load({
        custom: {
          families: ['Oswald-Regular']
        },
        loading: function () {  //所有字体开始加载
          // console.log('loading');
        },
        active: function () {  //所有字体已渲染
          fontLoaded();
        },
        inactive: function () { //字体预加载失败，无效字体或浏览器不支持加载
          console.log('inactive: timeout');
          fontLoaded();
        },
        timeout: 5000 // Set the timeout to two seconds
      });
    }
  }

  function asyncErr(){
    console.warn('script load from CDN failed, will load local script')
  }

  // load webfont-loader async, and add callback function
  function async(u, cb, err) {
    var d = document, t = 'script',
      o = d.createElement(t),
      s = d.getElementsByTagName(t)[0];
    o.src = u;
    if (cb) { o.addEventListener('load', function (e) { cb(null, e); }, false); }
    if (err) { o.addEventListener('error', function (e) { err(null, e); }, false); }
    s.parentNode.insertBefore(o, s);
  }

  var asyncLoadWithFallBack = function(arr, success, reject) {
      var currReject = function(){
        reject()
        arr.shift()
        if(arr.length)
          async(arr[0], success, currReject)
        }

      async(arr[0], success, currReject)
  }

  asyncLoadWithFallBack([
    "https://cdn.jsdelivr.net/npm/webfontloader@1.6.28/webfontloader.min.js", 
    "https://cdn.bootcss.com/webfont/1.6.28/webfontloader.js",
    "/blog/lib/webfontloader.min.js"
  ], asyncCb, asyncErr)
</script>        
        <img class="loading" src="/blog/assets/loading.svg" style="display: block; margin: 6rem auto 0 auto; width: 6rem; height: 6rem;" />
        <div class="container container-unloaded">
            <main class="main post-page">
    <article class="article-entry">
        <font color=#1  face="微软雅黑">
<font size="10">c语言</font><br /> 
>======
>7/9/2018 4:12:24 PM 
>>***
>><font size="6"><p align="left">**第三章 数据和C** </font><br /> 
>>***
>>**1.**    <center>   **e （数学科学记数法）**<br />
><p align="left">用指数表示法显示数字，以 E+n 替换部分数字，其中 E（代表指数）表示将前面的数字乘以 10 的 n 次幂。例如，用 2 位小数的“科学记数”格式表示 12345678901，结果为 1.23E+10，即 1.23 乘以 10 的 10 次幂。您可以指定要使用的小数位数。
>><br />
>***
>>**2.**    <center>  **浮点数** <br>
>>[（浮点数网站详解）](https://blog.csdn.net/rjs123/article/details/7976499):
>>浮点数，是指小数点在数据中的位置可以左右移动的数据。它通常被表示成：
        N = M* RE <br />
    　　这里的M(Mantissa)被称为浮点数的尾数，R(Radix)被称为阶码的基数，E(Exponent)被称为阶的阶码。 1.2345 × 102，其中 1.2345 为尾数，10为基数，2 为指数
>><table><td bgcolor=#FF83FA>尾数实际上是有
>>尾数有时也称为有效数字（Significand）</td></table> <br />
>><table><td bgcolor=#FFFA><b />
>>**为什单精度实际的指数表达范围在-127~127之间**<br />其中单精度数为 8 位，双精度数为 11 位。以单精度数为例，8 位的指数为可以表达 0 到 255 之间的 255 个指数值。但是，指数可以为正数，也可以为负数。为了处理负指数的情况，实际的指数值按要求需要加上一个偏差（Bias）值作为保存在指数域中的值，单精度数的偏差值为 127，而双精度数的偏差值为 1023。比如，单精度的实际指数值 0 在指数域中将保存为 127；而保存在指数域中的 64 则表示实际的指数值 -63。偏差的引入使得对于单精度数，实际可以表达的指数值的范围就变成-127 到128 之间（包含两端）。我们不久还将看到，实际的指数值-127（保存为全 0）以及 +128（保存为全 1）保留用作特殊值的处理。这样，实际可以表达的有效指数范围就在 -127 和 127 之间。在本文中，最小指数和最大指数分别用 emin 和 emax 来表达</ td></table><br />
>>
>>计算机中一般规定R为2、8或16、是一个确定的常数，不需要在浮点数中明确表示出来。因此，要表示浮点数，一是要给出尾数M的值，通常用定点小数形式表示，它决定了浮点数的表示精度，即可以给出的有效数字的位数。二是要给出阶码，通常用整数形式表示，它指出的是小数点在数据中的位置，决定了浮点数的表示范围。浮点数也要有符号位。
>>floating-point 差不多可以和数学中的实数概念相对应
>>浮点数和整数的区别：<br />
>>![浮点数](https://s4.51cto.com/oss/201711/09/1afceb11e5df90996dddd0060587c3cd.jpg)
>>　符号位 　阶码 　尾数 　总位数
>>    　　短浮点数 　　1 　　　8 　　23 　　32
>>    　　长浮点数 　　1 　　 11 　　52 　　64
>>    　　临时浮点数 　1 　　 15　　 64 　　80
>><br>
对短浮点数和长浮点数，当其尾数不为0值时，其最高一位必定为1，在将这样的浮点数写入内存或磁盘时，不必给出该位，可左移一位去掉它，这种处理技术称为隐藏位技术，目的是用同样多位的尾数能多保存一位二进制位。在将浮点数取回运算器执行运算时，再恢复该隐藏位的值。对临时浮点数，不使用隐藏位技术。<br/>
>> **浮点数的运算法则**[百度](https://baike.baidu.com/item/%E7%A7%BB%E7%A0%81/10165919?fr=aladdin)<br/>
>> **[补充补码，反码,移码](https://www.cnblogs.com/sunfan1988/p/3850242.html)***【详细】
>><br>源码、反码、补码、移码在计算机中是怎么运算的？
数值有正负之分,计算机就用一个数的最高位存放符号(0为正,1为负).这就是机器数的原码了.假设机器能处理的位数为8.即字长为1byte,原码能表示数值的范围为 127~（-127）
另外，我们需要知道，在计算机中都是以补码的储存负数的（正数的补码等于他本身，所以也可以理解为计算机储存的是补码），那么我们从源码->>>反码的过程其实是为了计算补码的一个计算的过程。

<blockquote>
<blockquote>
<blockquote>
<p>运算过程：原码-&gt;反码-&gt;补码-&gt;移码</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>原码 :二进制（开头第一个表示符号0正1负）</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>反码 ：在原码的基础上，符号位不动，其他位取反 —注意，任何正数的源码=反码=补码，而负数都是通过补码表示的。<br>补码 ：在反码的基础上，运算+1  —注意，任何正数的源码=反码=补码，&lt;&gt;而负数都是通过补码表示的。 <br/><br>用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。<br>引入移码的目的：用补码表示阶码的时候，当阶码无限小，产生了下溢的时候，阶码变成了0，那么这个浮点数的值变为了1。而实际上这个数是无限接近于零的。那么我们就需要取出其中的 “-0” 值作为机器零。<br>      <br>公式：两数补码的和==两数和的补码。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>移码 ：在补码的基础上，符号位取反</p>
<table><td bgcolor=#FF83FA>负数的存储：c语言中，负数以整数的补码存储</table><br />
101011（二进制）--> 原码 00101011 --> 反码 01010100 --> 补码 01010101--> 移码 11010101
<br /><br />**二进制运算** 
<table><td bgcolor=#FF83FA>逢二进一，结果写0 </table><br />
        **例题1用补码计算2-9**<br><br><br><br>
</blockquote>
</blockquote>
<hr>
<ol start="3">
<li><strong><a href="https://blog.csdn.net/wfreehorse/article/details/60589326" target="_blank" rel="noopener">c语言数据类型</a></strong><blockquote>
<p><img src="http://c.biancheng.net/cpp/uploads/allimg/120205/1-120205162A4H8.jpg" alt="1"><br ><br>##</p>
</blockquote>
</li>
</ol>
</blockquote>
<pre>
#include <stdlib.h>
#include <inttypes.h>
void main()
{
    /*int x =2;
    printf("dec=%d;octal=%o;hex=%x\n",x,x,x);//显示八进制十六进制
    printf("dec=%d;octal=%#o;hex=%#x\n",x,x,x);//%o %x


    /*****整数溢出*******
    int i=2147483647;
    unsigned int j=4294967295;
    printf("%d;%d;%d\n",i,i+1,i+2);
    printf("%u;%u;%u\n\n\n",j,j+1,j+2);//无符号整型达到最大值时，将溢出到起始点；而int型的起始点是-2147483647

    /*******打印short long,longlong,和unsigned类型数*********
    //使用修饰符h可以显示一个较长的整数被截成short类型的样子
    //在传递参数数时，c会自动将short类型的值转换为int类型。int类型被认为是计算机处理起来最方便有效的的整数类型
    unsigned int un =3000000000;
    short end=200;
    long big=65537;
    long long verybig=12345678908642;
    printf("un=%u and not un=%d\n",un,un);
    printf("end=%hd and not %d\n",end,end);
    printf("big=%ld and not %hd\n",big,big);
    printf("verybig=%lld and not %ld\n",verybig,verybig);

    /****非打印字符***
    //一些动作描述是打印不出来的例如退格，换行，走纸让终端铃响。一，使用ASCⅡ码二，使用转义序列（escape sequence）
    char beep='\007';
    printf("hello\a\n");//发出警报声

    /***可移植的指数类型inttypes.h***
    //C99标准提供了一些串宏来打印这些可移植类型例如inttype.h头文件将定义串PRId16表示打印16位有符号值
    int16_t me16;
    me16=4593;
    printf("me16=%hd\n",me16);
    printf("me16=%"PRId16"\n",me16);


    /***float double 和longdouble型***/
    //浮点常量：使用f或F后缀使编译器把浮点常量当作float型比如2.3f和9.11E9F
    //*用%e打印指数计数法的数字
    float double型都用%f，%e，%a说明符打印*
    float aboat =32000.0;
    double abet =2.14e9;
    long double dip =5.32e-5;
    printf("%f %e\n",aboat,aboat);
    printf("%f %e\n",abet,abet);
    printf("%f %e\n",dip,dip);//???


    //*浮点值的上溢和下溢

     float toobig=3.4e38*100.0f;
     printf("%e",toobig);

    //练习2,输入一个ascⅡ码，然后输出相应的字符
    int a;
    char ch;
    printf("输入一个整数\n");
    scanf("%d",&a);
    ch=a;
    printf("%c\n",ch);
    //练习3，输入一个字母，输出其ascⅡ码
    getchar();

    int b;
    char fi;
    printf("输入一个小写字母");
    scanf("%c",&fi);
    b=fi-32;
    printf("ascⅡ为%d",b);
    getchar();
    */
    //练习3读入一个浮点数，分别以小数形式和指数形式输出
    float c;
    scanf("%f\n",&c);
    printf("%e\n%0.1f\n",c,c);
    return 0;
}

</pre>


<center>第四章字符串和格式化输入/输出
===
>***
>- strlen()
>-  const
>- print() 和 scanf()
>- 使用c预处理器#define指令和ANSIC的const修饰符创建符号常量

<blockquote>
<hr>
<p align="left">
使用%s的scanf()只会把第一个字符串读入<br><b>
C使用读取输入函数 （例如gets（））来处理一般的字符串

</blockquote>
<blockquote>
<hr>
<p>常量和C预处理器<br><br>格式：#define 其次常量一般大写<br><br /><br>4.3.1 <strong>const修饰符</strong> <br><br>C90新增了一种创建符号常量的第二种方法。使用const把一个变量声明转换成常量<br><br>const int MONTHS=12;</p>
<br>
4.3.2**系统定义的明显常量** 头文件limits.h和float.h
</p>
1.sizeof()运算符:以字节为单位给出数据的大小<br>
2.strlen（）函数：以字符为单位给出字符串的长度<br>/string.h/提供函数原型
</blockquote>
<hr>
<blockquote>
<h1 id="printf函数"><a href="#printf函数" class="headerlink" title="printf函数"></a>printf函数</h1></blockquote>
<p>printf格式说明符p71</p>
<blockquote>
<table>
<thead>
<tr>
<th>说明符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>%d</td>
<td align="center">有符号十进制整形</td>
</tr>
<tr>
<td>%f</td>
<td align="center">单精度浮点数，小数点后保留6位</td>
</tr>
<tr>
<td>%lf</td>
<td align="center">双浮点精度</td>
</tr>
<tr>
<td>%c</td>
<td align="center">输出一个字符</td>
</tr>
<tr>
<td>%s</td>
<td align="center">按实际输出字符串</td>
</tr>
<tr>
<td>%e</td>
<td align="center">按指数格式输出</td>
</tr>
<tr>
<td>%g</td>
<td align="center">按输出较小原则，自动按%f或%e原则输出浮点数</td>
</tr>
<tr>
<td>%o</td>
<td align="center">八进制数</td>
</tr>
<tr>
<td>%x</td>
<td align="center">十进制数</td>
</tr>
<tr>
<td>%p</td>
<td align="center">输出指针的地址</td>
</tr>
</tbody></table>
</blockquote>
<p>printf()说明修饰符</p>
<blockquote>
<table>
<thead>
<tr>
<th>修饰符</th>
<th align="center">功能</th>
</tr>
</thead>
<tbody><tr>
<td>-</td>
<td align="center">左对齐  :%-20s:</td>
</tr>
<tr>
<td>+</td>
<td align="center">显示正负号 :%+6.2f</td>
</tr>
<tr>
<td>空格</td>
<td align="center">有符号的值若为正，则显示是带前导空格（不现实正号），若为扶，则显示符号</td>
</tr>
<tr>
<td>#</td>
<td align="center">显示数据格式</td>
</tr>
<tr>
<td>0</td>
<td align="center">用前导零而不是空格填充字段宽度，如果出现-标志或者指定了精度，则忽略该标志:%010d %08.3f</td>
</tr>
<tr>
<td>.digits</td>
<td align="center">精度 ：%5.2f（字段宽度为五个字符，五位有效数字，保留2位小数）</td>
</tr>
<tr>
<td>（易混）ll</td>
<td align="center">unsigned long long int %8llu</td>
</tr>
<tr>
<td>t</td>
<td align="center">和整数转换说明符一起使用，表示一个ptrdiff_t值（与两个指针之间的差相对应的类型）%td  %12ti</td>
</tr>
<tr>
<td>z</td>
<td align="center">和整数说明符一起使用，表示一个size_t值（sizeof返回的类型）%zd %12zx</td>
</tr>
</tbody></table>
</blockquote>
<hr>
<blockquote>
<p>printf()分割字符串（字符串较长时）的三种方法<br></p>
</blockquote>
<blockquote>
<p>1.多个printf（）语句<br>2.使用反斜杠\和回车键组合来结束第一行<br>3.采用字符串连接的方法</p>
</blockquote>
<hr>
<blockquote>
<h1 id="scanf-函数"><a href="#scanf-函数" class="headerlink" title="scanf()函数"></a>scanf()函数</h1><p>转换说明符和转换修饰符与printf（）类似p79</p>
<p align="left"><br>**scanf()的返回值**（后面讲到）
如果它没有读取任何项目（当它期望一个数字而你却键入了一个非数字字符串时就会发生这种情况），scanf()会返回值0.当它检测到“文件结尾”（end of file），它返回EOF（EOF是stdio.h中定义的特殊值）
</blockquote>
<blockquote>
<p>【重点】</p>
<table><td bgcolor=#FF83FA>4.4.6printf()和scanf()的*的修饰符</table>
<br>
<p align="left">
printf()*用法：使用*代替数字，使用可变参数确定字段宽度的值
<p align="left">scanf()*的作用：使函数跳过相应的输入项目
如果程序需要读取一个文件中某个特定的列（该文件的数据以统一的列排列），那么该功能将非常有用
</blockquote>
<pre><p align="left">
//第四章练习
#include<stdlib.h>
#include<string.h>
#include<float.h>
int main(void)
{
    /*
    //2.4输入名字，在比名字宽三个字符发字段内打印它
    char ming[40],xing[40];
    printf("输入名字");
    scanf("%s",&ming);
    int a=strlen(ming);
    printf("\"%s\"\n",ming);
    printf("\"%20s\"\n",ming);
    printf("\"%*s\"\n",a+3,ming);//程序清单4.16使用可变宽度的输出字段


    //3.
    float a=21.3;
    printf("The input %0.1f is%0.1e\n",a,a);
    //5 输入名字，在第一行打印输入的姓名，在下一行打印每个名字中字母的个数，把字母个数与相应名字的结尾对齐

    char xing[40],name[40];
    printf("分别输入姓氏名字\n");
    scanf("%s",&xing);
    getchar();
    scanf("%s",&name);
    printf("%s\t",xing);
    printf("%s\n",name);
    printf("%*d\t%*d\n",strlen(xing),strlen(xing),strlen(name),strlen(name));
    */
    //6.
    double num1=1.0/3.0;
    float num2=1.0/3.0;
    printf("%.4f,%.12f,%.16f\n",num1,num1,num1);
    printf("%.4f,%.12f,%.16f\n",num2,num2,num2);
    printf("%d %d\n",FLT_DIG,DBL_DIG);
    return 0;
}
</pre>
<blockquote>
</blockquote>
<h1 id="第五章运算符，表达式和语句"><a href="#第五章运算符，表达式和语句" class="headerlink" title="第五章运算符，表达式和语句"></a>第五章运算符，表达式和语句</h1><blockquote>
<hr>
<ul>
<li>如何编写带有参数的函数</li>
<li>typedef</li>
</ul>
<ul>
<li>复合语句，自动类型和类型指派</li>
</ul>
</blockquote>
<blockquote>
<hr>
<p>1.基本运算符：=+-<em>/<br><br>2.其它运算符：<br>*</em></p>
<blockquote>
<ul>
<li>sizeof运算符和size_t类型</li>
<li><br>取模运算符%：modulus operater用于整数运算。该运算计算出用它右边的整数去除它左边的整数得到的余数。如果第一个操作数为负数，那么得到的模也为负数</li>
<li><br> 增量运算符和减量运算符:++ –<br><br>前缀q=++a：a先自增1然后赋值给q<br>后缀q=a++:a先赋值给q然后再自增1  //先使用n然后将它的值增加</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<p><br>优先级() ++ –<br>5.4副作用和顺序点</p>
<blockquote>
<p>副作用：是对数据对象或文件的修改 例如states=50的副作用是将变量的的值设置为50.跟赋值运算符一样，增量减量运算符也有副作用，它们主要由于副作用而被应用<br>顺序点：是程序执行中的一点，在该点处，所有副作用都在进入下一步前被计算<br>表达式是运算符和操作数的组合<br>语句分为简单语句和复合语句或代码块block<br><br>5.5类型转换<br>程序清单5.14</p>
</blockquote>
</blockquote>
<blockquote>
<p>指派运算符：作用避免自动类型转换，避免降级</p>
<pre>
int mice;
mice=1.6+1.7;
mice=(int)1.6+(int)1.7
</pre>
</blockquote>
<table><td bgcolor=#FF83FA>5.6带有参数的函数</table></td>

<pre>
#include<stdio.h>
void pound(int n); //ANSI风格的原型
int main(void)
{
int times=5;
char ch='!';
float f=6.0;
pound(times);
pound(ch);
pound((int)f);
return 0;
}
void pound(int n)
{
while(n-->0)
printf("#");
printf("\n");
}
</pre>
<blockquote>
<p>形式参数和实际参数<br><br>+ 形参：全称为“形式参数”是在定义函数名和函数体的时候使用的参数，目的是用来接收调用该函数时传递的参数。<br><br>+ 实参：可以是常量、变量、表达式、函数等， 无论实参是何种类型的量，在进行函数调用时，它们都必须具有确定的值， 以便把这些值传送给形参。 因此应预先用赋值，输入等办法使实参获得确定值。</p>
</blockquote>
<blockquote>
<pre>
#include<stdlib.h>
const float f=1.8 , b=32.0;
void pfh(int n);
void temp(float a);
pfh(int n)
  {
   int a;
   a=n*n;
   printf("%d\n",a);
   }
temp(a)
   {
   float t=f*a+b;
   float k=t+273.16;
   printf("Celsius=%.2f\n",t);
   printf("kelvin=%.2f\n",k);
   }
  int main(void)
    {
    /*int num=1;
    while(num<10)
    {
        printf("%4d %6d\n",num,num*num);
        num=num+1;
    }
    //sizeof.c
    int n=1111;
    size_t intsize;
    intsize=sizeof(n);
    printf("n=%d,n has %lubytes;all ints have%lu bytes.\n",n,sizeof n,intsize);
    //取模运算符%
    //把秒转换为分
    int min,sec,left;
    printf("输入秒钟");
    scanf("%d",&sec);
    min=sec/60;
    left=sec%60;
    printf("%d  seconds is %dminutes,%dseconds",sec,min,left);
    //数据类型自动转换
  char ch;
   int i;
   float f1;
   f1=i=ch='C';
   printf("ch =%c,i=%d,f1=%f\n",ch,i,f1);
   ch=ch+1;
   i=f1+2*ch;
   f1=2.0*ch+i;
   printf("ch =%c,i=%d,f1=%f\n",ch,i,f1);
   ch=70.17;
   printf("ch=%c",ch);
 */
   //练习5计算平方和
   int n;
   printf("输入一个整数\n");
   scanf("%d",&n);
   pfh(n);
  //练习8 温度转换
   float t;
   printf("输入温度\n");
   scanf("%.2f",&t);
   temp(t);
    return 0;
}
</pre>
</blockquote>
<blockquote>
<h1 id="第六章-C控制语句：循环"><a href="#第六章-C控制语句：循环" class="headerlink" title="第六章 C控制语句：循环"></a>第六章 C控制语句：循环</h1><hr>
<ul>
<li>for</li>
<li>while</li>
<li>do while</li>
<li>运算符+= /= %=</li>
<li>循环中常用的数组</li>
<li>编写具有返回值的函数</li>
</ul>
<hr>
<p>fabs()函数：math.h头文件中 可以方便的进行浮点判断，返回一个浮点值的绝对值<br>程序员最常用while(goats)  ==while(!=goats)<br><br >6.3.4新的_Bool类型&lt;stdbool.h&gt;<br>运算符优先级<br><br><img src="https://gss2.bdstatic.com/-fo3dSag_xI4khGkpoWK1HF6hhy/baike/c0%3Dbaike80%2C5%2C5%2C80%2C26/sign=59a3e1017d3e6709aa0d4dad5aaef458/63d9f2d3572c11df57c9a205612762d0f703c2f8.jpg" alt="3"><br><br>for循环p131</p>
<blockquote>
<hr>
<ul>
<li>用字符代替数字来进行计数<br><br>- 不仅可以限制循环次数还可以限制立方的大小<br>for（num=1;num<em>num</em>num&lt;216;num++）<br><br>可以让一个或多个表达式为空<br><br>第一个表达式不必初始化一个变量，它也可以是某种类型的printf（）语句<br>第一个表达式只在执行其它循环部分之前被求值；或被执行一次<br><br>更多赋值运算符</li>
</ul>
<hr>
<table>
<thead>
<tr>
<th>·</th>
<th align="center">说明</th>
</tr>
</thead>
<tbody><tr>
<td>+=</td>
<td align="center">a+=2   ==   a=a+2</td>
</tr>
<tr>
<td>-=</td>
<td align="center">a-=2      ==  a=a-2</td>
</tr>
<tr>
<td>*=</td>
<td align="center"></td>
</tr>
<tr>
<td>=</td>
<td align="center"></td>
</tr>
<tr>
<td>%=</td>
<td align="center"></td>
</tr>
</tbody></table>
</blockquote>
</blockquote>
<blockquote>
<p><br>逗号运算符：扩展了for循环的灵活性，可以在一个for循环中使用多个初始化或更新表达式</p>
<pre>
#include<stdio.h>
int main(void)
{
const int FIRST_OZ=37;
const int NEXT_OZ=23;
int ounces,cost;
printf("ounces cost\n");
for(ounces=1,cost=FIRST_OZ;ounces<=16;ounces++,cost+=NEXT_OZ);
   printf("%5d $%4.2f\n",ounces,cost/100.0);
return 0;
}<></pre>
<p>do while:循环必须被执行一次<br><br >6.1嵌套循环     通常用来按行按列来显示数据<br><br>嵌套变化</p>
<hr>
</blockquote>
<blockquote>
<h1 id="第七章分支和跳转"><a href="#第七章分支和跳转" class="headerlink" title="第七章分支和跳转"></a>第七章分支和跳转</h1><p>7.2.1 getchar()和putchar():</p>
<blockquote>
<blockquote>
<p><br>在&lt;stdio.h&gt;文件有定义     专门为面向字符I/O设计的c函数</p>
</blockquote>
</blockquote>
<p><br>&lt;ctype.h&gt;系列字符函数</p>
</blockquote>
<table>
<thead>
<tr>
<th>函数名</th>
<th align="center">为如下参数时，返回值为真</th>
</tr>
</thead>
<tbody><tr>
<td>- isalnum()</td>
<td align="center">字母数字</td>
</tr>
<tr>
<td>- isalpha</td>
<td align="center">字母</td>
</tr>
<tr>
<td>- isblank</td>
<td align="center">一个标准的空白字符</td>
</tr>
<tr>
<td>- iscntrl</td>
<td align="center">控制符</td>
</tr>
<tr>
<td>- isdigit</td>
<td align="center">阿拉伯数字</td>
</tr>
<tr>
<td>- isgraph</td>
<td align="center">除空格之外的所有可打印字符</td>
</tr>
<tr>
<td>- islower</td>
<td align="center">小写字母</td>
</tr>
<tr>
<td>- isprint</td>
<td align="center">可打印字符</td>
</tr>
<tr>
<td>- ispunct</td>
<td align="center">标点符号</td>
</tr>
<tr>
<td>- isspace</td>
<td align="center">空白字符：空格，换行，走纸，回车</td>
</tr>
<tr>
<td>- isupper</td>
<td align="center">大写字母</td>
</tr>
<tr>
<td>- isxdigit</td>
<td align="center">十六进制数字字符</td>
</tr>
</tbody></table>
<blockquote>
<blockquote>
</blockquote>
</blockquote>
<table>
<thead>
<tr>
<th>-</th>
<th align="center">字符映射函数</th>
</tr>
</thead>
<tbody><tr>
<td>-tolower</td>
<td align="center">如果参数是大写字母，返回相应的小写字母否则，返回原始参数</td>
</tr>
<tr>
<td>-toupper</td>
<td align="center">如果参数是小写字母，返回相应的大写字母</td>
</tr>
<tr>
<td>&gt;****</td>
<td align="center"></td>
</tr>
<tr>
<td>&gt;<br>isalpha（）函数的参数是个字母，则它返回一个非零值</td>
<td align="center"></td>
</tr>
<tr>
<td>&gt; 映射函数并不改变原始的参数,它们只会返回改变后的值</td>
<td align="center"></td>
</tr>
<tr>
<td>&gt;<br>tolower(ch)</td>
<td align="center"></td>
</tr>
<tr>
<td>&gt;<br>ch=tolower(ch)//把ch转换为小写</td>
<td align="center"></td>
</tr>
<tr>
<td>&gt;<pre></td>
<td align="center"></td>
</tr>
<tr>
<td>>7.1 if 语句</td>
<td align="center"></td>
</tr>
<tr>
<td>>判断一个数是不是素数.</td>
<td align="center"></td>
</tr>
<tr>
<td>>/* divisors.c -- 使用嵌套if显示一个数的约数*/</td>
<td align="center"></td>
</tr>
<tr>
<td>>#include<stdio.h></td>
<td align="center"></td>
</tr>
<tr>
<td>>#include<stdbool.h></td>
<td align="center"></td>
</tr>
<tr>
<td>>int main(void) {</td>
<td align="center"></td>
</tr>
<tr>
<td>unsigned long num;    // 要检查的数</td>
<td align="center"></td>
</tr>
<tr>
<td>unsigned long div; // 可能的约数</td>
<td align="center"></td>
</tr>
<tr>
<td>bool isPrime;    // 素数的标志</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("Please enter an integer for analysis: ");</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("Enter q to quit/\n");</td>
<td align="center"></td>
</tr>
<tr>
<td>while (scanf("%lu",&num)==1)</td>
<td align="center"></td>
</tr>
<tr>
<td>{</td>
<td align="center"></td>
</tr>
<tr>
<td>for (div = 2, isPrime = true; (div*div) <= num; div++) {</td>
<td align="center"></td>
</tr>
<tr>
<td>if (num%div == 0) {</td>
<td align="center"></td>
</tr>
<tr>
<td>if ((div*div) != num)</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("%lu is divisble by %lu and %lu.\n",</td>
<td align="center"></td>
</tr>
<tr>
<td>num, div, num / div);</td>
<td align="center"></td>
</tr>
<tr>
<td>else</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("%lu is divisble by %lu.\n", num, div);</td>
<td align="center"></td>
</tr>
<tr>
<td>isPrime = false;// 不是一个素数</td>
<td align="center"></td>
</tr>
<tr>
<td>}</td>
<td align="center"></td>
</tr>
<tr>
<td>}</td>
<td align="center"></td>
</tr>
<tr>
<td>if (isPrime)</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("%lu is prime.\n", num);</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("Please enter another integer for analysis:");</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("Enter q to quit.\n");</td>
<td align="center"></td>
</tr>
<tr>
<td>}</td>
<td align="center"></td>
</tr>
<tr>
<td>printf("Bye.\n");</td>
<td align="center"></td>
</tr>
<tr>
<td>getchar();</td>
<td align="center"></td>
</tr>
<tr>
<td>getchar();</td>
<td align="center"></td>
</tr>
<tr>
<td>return(0);</td>
<td align="center"></td>
</tr>
<tr>
<td>}</td>
<td align="center"></td>
</tr>
<tr>
<td>></pre></td>
<td align="center"></td>
</tr>
<tr>
<td>&gt;逻辑运算符&amp;&amp;</td>
<td align="center"></td>
</tr>
<tr>
<td>&gt;<br>!(4&gt;7) 为真 :4不大于7</td>
<td align="center"></td>
</tr>
</tbody></table>
<blockquote>
<pre>
#include<stdio.h>
#include<ctype.h>    // 为isspace()提供函数原型
#include<stdbool.h> // 为bool\true和false提供定义
#define STOP '|'
int main(void) {
    char c; // 读入字符
    char prev;    // 前一个读入字符
    long n_chars = 0L; // 字符数
    int n_lines = 0; // 行数
    int n_words = 0;  // 单词数
    int p_lines = 0; // 不完整的行数
    bool inword = false; // 如果C在一个单词中，则inword 等于true
    printf("Enter text to be analyzed(| to terminate):\n");
    prev = '\n'; // 用于识别完整的行
    // while ((c = getchar()!= STOP))  // 不正确，只读到一个word,并且编译没有错误.
    while ((c = getchar())!= STOP)  
    {
        n_chars++; // 统计字符
        if (c == '\n')
            n_lines++; //统计行数
        if (!isspace(c) && !inword)
        {
            inword = true; // 开始一个新单词
            n_words++; // 统计单词
        }
        if (isspace(c) && inword)
            inword = false; // 到达单词尾部
        prev = c; // 保存字符值
    }
    if (prev != '\n')
        p_lines = 1;
    printf("characters = %ld, words = %d, lines = %d， ",
        n_chars, n_words, n_lines);
    printf("partial lines = %d\n", p_lines);
        getchar();
    getchar();
    return(0);
    }
</pre>
<blockquote>
<p>条件运算符<br>x=(y&lt;0)? -y;y;<br>如果y小于0，那么x=-y，否则x=y<br>循环辅助手段：continue 和break</p>
</blockquote>
</blockquote>
<hr>
<blockquote>
<pre>
    #include<stdlib.h>
    #include<stdio.h>
    #include<ctype.h>
    #include<stdbool.h>
    int main(void)
    {
    /*const int FIRST_OZ=37;
    const int NEXT_OZ=23;
    int ounces,cost;
    printf("ounces cost\n");
     for(ounces=1,cost=FIRST_OZ;ounces<=16;ounces++,cost+=NEXT_OZ);
      printf("%5d $%4.2f\n",ounces,cost/100.0);
</blockquote>
<pre><code>const int ROWS =6;
const int  CHARS = 6;
int row;
char ch;
for(row=0;row&lt;ROWS;row++)
{
for(ch=(&apos;A&apos;+row);ch&lt;(&apos;A&apos;+CHARS);ch++)
printf(&quot;%c&quot;,ch);
printf(&quot;\n&quot;);

//练习1
char al[27];
int i=0;
for(al[0]=&apos;a&apos;;i&lt;&apos;z&apos;-&apos;a&apos;+1;i++)
{
    //if(i&gt;25)break;
    al[i]=&apos;a&apos;+i;

    printf(&quot;%c&quot;,al[i]);

}
printf(&quot;\na=%d z=%d\n&quot;,al[0],&apos;z&apos;);
 int  j;
 //$
 //$$
 //$$$
 //$$$$
 //$$$$$
//练习2使用嵌套循环显示图案
for( i=0;i&lt;5;i++)
{
 for( j=i+1;j&gt;0;j--)
 {
     printf(&quot;$&quot;);
 }
 printf(&quot;\n&quot;);
}

//练习三
//F
//FE
//FED
//FEDC
 int row=6;
 int  chars=6;
 int a=&apos;F&apos;;
for(row=0;row&lt;7;row++)
{
    for(chars=0;chars&lt;row;chars++)
    {
        printf(&quot;%c&quot;,a-chars);
    }
    printf(&quot;\n&quot;);
}

 //4 金字塔图案
 //    A
 //   ABA
 //  ABCBA
 // ABCDCBA
 char zimu;
 const int num=10;
 int x,y,z,t;
 printf(&quot;\n输入一个字符\n&quot;);
 scanf(&quot;%c&quot;,&amp;zimu);
 int o=(int)zimu;//！！！n很关键
 for(x=0;x&lt;num;x++)
    {
        for(y=0;y&lt;num-x;y++)
        {
            printf(&quot; &quot;);
        }
        for(z=0;z&lt;x;z++)
        {
            printf(&quot;%c&quot;,o+z);
        }
        for(t=x-1;t&gt;0;t--)
        {
            printf(&quot;%c&quot;,o+t);
        }
          printf(&quot;\n&quot;);

    }

    //方法二
    for(x=0;x&lt;num;x++)
    {
        for(y=num-x;y&gt;0;y--)printf(&quot; &quot;);
        for(z=0;z&lt;x;z++)printf(&quot;%c&quot;,o+z);
        for(t=x-1;t&gt;0;t--)printf(&quot;%c&quot;,o+t);
        printf(&quot;\n&quot;);
    }
      //第七章

      //7.12 练习1

      unsigned char ch;
      int n_lines=0,n_char=0,n_blankspace=0;
      while((ch=getchar())!=&apos;#&apos;)
      {
      if(ch==&apos;\n&apos;) n_lines++;
      else if(!isgraph(ch)) n_blankspace++;
      else if(isgraph(ch))  n_char++;
      }
      printf(&quot;lines : %d blankspace :%d  char :%d&quot;,n_lines,n_blankspace,n_char);


     //7.2打印每个输入字符以及它的十进制ASCⅡ码
     unsigned char ch;
     char shuzu[100];
     int words=0,i=0;
     while((ch=getchar())!=&apos;#&apos;)
           {
            if(ch==&apos;\n&apos;)continue;
            if(!(ch&lt;&apos;a&apos;||ch&gt;&apos;z&apos;))
            shuzu[i]=ch;
            words++;
            i++;
            if(i&gt;100)break;
           }
           for(i=0;i&lt;words;i++)
           {
            if(i%8==0)printf(&quot;\n&quot;);
            printf(&quot;%3d &quot;,shuzu[i]);
           }
           */
      //7.3 读取整数，知道输入0.输入终止后，
      //分别报告输入偶数奇数的总个数，偶数的平均值
      bool flag=false;//判断c的位置，真为在数字中
      int ch=0;
      int number=0,nums=0,n_even=0,n_odd=0,n_even_num=0;
      //方法一
      scanf(&quot;%d&quot;,&amp;ch);//很重要！
      while(ch!=0)
      {
          scanf(&quot;%d&quot;,&amp;ch);
          if(!flag)
          {
              flag=false;
              nums++;
              if(ch%2==0)
              {
              n_even+=ch;
              n_even_num++;
              }
              else
              {
               n_odd+=ch;
              }
           }
           else if(isspace(ch)&amp;&amp;flag)
            {
             flag=true;
            }
      }
      //方法二
     /* while(ch!=0)
      {
          scanf(&quot;%d&quot;,&amp;ch);
          while(isspace(ch))continue;
           nums++;
              if(ch%2==0)
              {
                  n_even+=ch;
                  n_even_num++;
              }
              else
              {
                  n_odd+=ch;
              }

      }

      printf(&quot;总个数： %d \n偶数个数： %d 奇数个数： %d\n&quot;,nums,n_even_num,nums-n_even_num);
      if(nums!=0) printf(&quot;偶数均值: %d  奇数均值： %d&quot;,n_even/n_even_num,n_odd/(nums-n_even_num));
      */
      //7.6计算字符串中ei出现的次数
      char former=0,present=0;
      int count=0;
      while((present=getchar())!=&apos;#&apos;)
      {
          if(former==&apos;e&apos;&amp;&amp;present==&apos;i&apos;)count++; //一个传一个
          former=present;
      }
      printf(&quot;The chars have %d ei&quot;,count);

      return 0;
     }</code></pre><p></pre></p>
<blockquote>
<hr>
<h1 id="第八章字符输入输出"><a href="#第八章字符输入输出" class="headerlink" title="第八章字符输入输出"></a>第八章字符输入输出</h1></blockquote>
<pre>
<font size=5 color=red>[补]为什么给字符串赋值要用strcpy? 

字符串拷贝用strcpy,字符用=就可以了,因为=拷贝字符串时候只会

拷贝首地址(第一个字符),而strcpy是把字符串里每个字符一个一个

拷贝过去
</pre>
<blockquote>
<blockquote>
<p>完全缓冲和行缓冲:<br><br>数据流:<br><br>文件结尾:1.使用Crtl+Z字符标志 2.返回值EOF<br><br>重定向:</p>
<blockquote>
<p><br>输入重定向： &amp; echo_eof &lt;words<br><br>输出重定向：  echo_eof &gt;mywords<br><br>组合重定向： - 重定向运算符只将一个可执行的程序与一个数据文件连接起来不能文件连文件和程序连程序</p>
</blockquote>
</blockquote>
<blockquote>
<p><br>混合输入数字和字符</p>
<blockquote>
<p>getchar()和scanf()的区别</p>
</blockquote>
</blockquote>
<pre>
    #include<stdio.h>
    #include<ctype.h>
    #include<stdbool.h>
    int main(void)
    {
    //8.1统计输入到文件结尾为止的字符数
    /*
    int ch;
    int count=0;
    while((ch=getchar())!=EOF)
    {
        count++;
    }
    printf("您输入的%d个字符。\n",count);
</blockquote>
<pre><code>//8.2 把输入作为字符流读取，直到遇到EOF/令该程序打印每个输入字符及其ascⅡ编码的十进制值
 int ch;
int count=0;
while((ch=getchar())!=EOF)
{
    if(count%10==0)
    {
        putchar(&apos;\n&apos;);
    }
    if(ch&lt;&apos; &apos;)
    {
        if(ch!=&apos;\n&apos;&amp;&amp;ch!=&apos;\t&apos;)
        {
            putchar(&apos;^&apos;);
            putchar(ch+64);
            count+=2;
        }
        if(ch==&apos;\t&apos;) //\t跳格
        {
            putchar(ch);
            count++;
        }
        if(ch==&apos;\n&apos;)
        {
            putchar(ch);
            count=0;
        }
    }
    else
    {
        putchar(ch);
        printf(&quot;%d &quot;,ch);
        count++;
    }
}

//8.3  报告输入的大写字母的个数和小写字母的个数
char ch;
int b_num=0,s_num=0;
while((ch=getchar())!=EOF)
{
    if(isupper(ch))
    {
        b_num++;
    }
    else if(islower(ch))
    {
        s_num++;
    }
    else  continue;
    }


printf(&quot;大写字母：%d  小写字母：%d&quot;,b_num,s_num);
 */
 //8.4报告每个单词的平均字母数
 char ch;
 bool state=true;
 int words=0,num=0;
 while((ch=getchar())!=EOF)
 {
     if(isalpha(ch))
     {
     if(isalpha(ch))
     {
         num++;
         state=false;
     }
     else if(!state&amp;&amp;ch==&apos; &apos;)
     {
         words++;
         state=true;
     }
     }
     //else if(ch==&apos;\n&apos;||ispunct(ch))continue;
 }
 printf(&quot;Average alpha  %0.2f \n&quot;,(float)num/(words+1));
return 0;
}</code></pre><blockquote>
</p>
****

<h1 id="第九章函数"><a href="#第九章函数" class="headerlink" title="第九章函数"></a>第九章函数</h1><p>void starbar(void);  第一个给void声明函数类型，意思是该函数没有返回值<br>第二个void声明该函数不接受任何参数</p>
<blockquote>
<h1 id="9-3递归p225"><a href="#9-3递归p225" class="headerlink" title="9.3递归p225"></a>9.3递归p225</h1><p><br>C允许一个函数调用其本身，这种调用过程被称作递归。<br><br>递归一般可以代替循环语句使用，有些情况下使用循环语句比较好，而有些时候使用递归更有效。递归方法虽然是程序结构优美，但其执行效率却没有循环语句高<br><br>尾递归：把递归调用语句放在函数结尾<br><br>9.3.4递归和反向计算</p>
<blockquote>
<p>使用递归处理反序的问题比使用循环简单</p>
</blockquote>
</blockquote>
<pre>
void to_binary(unsigned long n)
{
    int r;
    r=n%2;
    if(n>=2)
        to_binary(n/2);
    putchar('0'+r);
    return;
}
></pre>
<blockquote>
<p>9.6改变调用函数中的变量  :排序交换变量<br><br>temp=a;//错误的交换变量<br><br>a=b;<br><br>b=temp</p>
</blockquote>
<hr>
<h1 id="指针"><a href="#指针" class="headerlink" title="指针"></a><br>指针</h1><ul>
<li>void interchange(int * , int*)</li>
<li>地址运算符： &amp; 当后跟一个变量名，给出地址</li>
<li>间接运算符： *   当后跟一个指针名或地址时，给出存储在被指向地址中的数值,优先级和++一样，结合时是<table><td bgcolor=#FF83FA>从左向右结合的</table></li>
<li>变量：名称，地址，数值         一个变量一般有两张属性：变量名和数值。程序被编译和加载后，同一个变量在计算机中的两个属性是地址和数值。变量的地址可以被看作是计算机中变量的名称</li>
<li>数值传递：参数用于把调用函数中的数值传给被调函数。   当需要在某函数中直接操作其调用函数的变量时，可以使用指针作为参数。同时，指数参数也可以用来把多个数值返回到调用函数中（return只能返回一个）；</li>
<li>*p理解：*p是指向的地址中的值，而p本身是指向类型的指针，p的值是一个地址</li>
</ul>
</blockquote>
<blockquote>
<p>break函数是指提前结束循环、接着执行循环下面的语句，不能用于循环语句和switch语句之外的任何其他语句中。</p>
</blockquote>
</font>
>***
>第十章数组和指针
>===
>[C语言中指针\*p[N]   ,( \*P)[N])    及\**p的区别](https://www.cnblogs.com/kuangsyx/p/7496454.html)




<blockquote>
<p><font color=red>创建数组的几种方法 </font></p>
<blockquote>
<p>1.预估最大数据个数，按此数值定义数组空间，完成数据输入<br>    #define MAX_NUM 1000<br>    int a[MAX_NUM];  这种方法定义数组，方便，安全。缺陷是数组空间大小受系统限制，数据太多了，就不能这样定义了。</p>
</blockquote>
</blockquote>
<blockquote>
<p>运行时，确定输入数据个数，采用指针动态定义数组，或C99提供的动态数组的方法实现</p>
</blockquote>
<blockquote>
<p>int *p;</p>
</blockquote>
<blockquote>
<p>int n;  printf (“input n: “); scanf(“%d”, &amp;n); //输入数据个数</p>
</blockquote>
<blockquote>
<p>（1）p=(int <em>)malloc(n</em>sizeof(int) ); //动态分配空间    不用了记得要释放free(p)</p>
</blockquote>
<blockquote>
<p>或  </p>
</blockquote>
<blockquote>
<p><font color=red size=5> （2）int pa[n] ;  //C99支持的动态数组，按n值动态定义数组</font></p>
</blockquote>
<blockquote>
<p>还可以采用指针动态扩充数组方法：先分配一定的大小，当数组不够&gt;用时，再重新分配空间。</p>
</blockquote>
<blockquote>
<p>#define INIT_LEN 100        预分配空间</p>
</blockquote>
<blockquote>
<p>#define INCE_LEN 10         每次扩充空间</p>
</blockquote>
<blockquote>
<p>int *p=（int *) malloc(INIT_LEN *sizeof(int) );</p>
</blockquote>
<blockquote>
<p>int length=INIT_LEN ;</p>
</blockquote>
<blockquote>
<p>不足时， length+=INCE_LEN ;  p=(int *)realloc( p, length) ; //扩充空间</p>
</blockquote>
<blockquote>
<ul>
<li>数组与指针的差别p286：<blockquote>
<p>1.两者都可以使用数组符号<br>2.都可以使用指针加法<br>3.<table><td bgcolor=#qwe1>只有指针可以使用增量运算</table></p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>字符串数组(下一章笔记整理到这)：<blockquote>
<p>char *mytal[LIM]={“  “,”  “,”  “}<br>char mytal2[LIM][LINLIM]; </p>
</blockquote>
</li>
</ul>
<blockquote>
<p><font color=red>指针数组建立的是一个不规则的数组，每一行的长度由初始化字符串决定</font></p>
</blockquote>
<blockquote>
<p>这两个数组的类型也不同，mytal是一个指向char的指针的数组，而mytal2是一个char数组的数组</p>
</blockquote>
</blockquote>
<pre>
#include <stdio.h>
int main(int argc, char* argv[])
    {
    int i, j;
    int (*p1)[3], *p2[3], **p3;
    int b[3][3];

    for(i=0; i<3; i++ )
        for(j=0; j< 3; j++)
            b[i][j] = 2*i + j;
    p1 = b;
    for(i=0; i< 3; i++)
        p2[i] = b[i];

    p3 = malloc(3 * sizeof(*p3));
    for(i=0; i< 3; i++)
        *(p3+i) =b[i]; 
    printf("the matrix is :\n");
    for(i=0; i< 3; i++)
    {    for(j=0; j< 3; j++)
            printf("%d\t", b[i][j]);
        printf("\n");
    }
    printf("%d\t%d\t%d\n", *(*(p1+1)+1), *(p2[1]+1), *(*(p3+1)+1));
    }
</pre>

<blockquote>
<blockquote>
<p><em>p[3]表示一个指针数组，可以理解为定义了三个指针*p1[0], *p1<br>[1], *p[2],在该例子中分别将b[0]的地址赋值给p[0],b[1]的地址赋值给p[2],…,因此</em>(p2[1]+1)表示的是*(b[1]+1)的值，也就是b[1][1].</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><em><em>p表示一个指向指针的指针，也可以理解为p存储的是一个地址的地址。比如在该例子中，{b[0], b[1], b[2]}可以认为是一个数组，里面的元素为一个地址，p存储的是该数组的初始地址，也就是说</em>p指向的是该数组的第一个元素（</em>(p+1)表示这个数组的第二个元素），但注意到这第一个元素还是一个地址，其相当数组b[0]的首地址，因此<em>(</em>(p3+1)+1)相当于*(b[1]+1),也就是b[1][1]</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>(<em>p)[3]改变了自然的运算符的优先级，相当于(int)((</em>p)[3])。一有指针就头疼，我们把指针先替换掉，就是int a[n]，是一个n维数组，数组首地址（也就是数组名）是a。那么，int (<em>p)[n]也是一个n维数组，但是这个数组的首地址是</em>p，也就是说，p指向的内容，是一个数组的首地址。那么，p就是指向一个数组的指针，这个数组中的元素都是int。实际上，p3相当于一个二重指针,这个和**p其实差不多。</p>
<blockquote>
<p>int  *p[N]表示指针数组，也就是说定义了N个不同指向int型的指针。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>int (*p)[N]表示定义一个指针，指向一个int[N]型的指针。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>int **p 表示定义一个指向指针的指针。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>注意[]的优先级要高于*。<br>常用排序算法总结<br>冒泡排序<br>=</p>
</blockquote>
</blockquote>
<blockquote>
<p>变长数组<br>长数组（VAL）:<br>在多维数组中，数组的行可以在函数调用时传递，但是数组的列一般在函数内部定义。<br>如下所示：</p>
<pre>

</blockquote>
<pre><code> #define COLS 4
int sum2dim ( int rows, int cols, int a[rows][cols] )
 {
    int r;
int c
int tol=0;
    for (r=0; c&lt;rows; r++)
       for (c=0; c&lt;cols; c++)
        tol+=ar[r][c];
       return tol;

    }</code></pre><blockquote>
<p></pre></p>
<pre>
    //10.12
    void bigarr(int rows,int cols)
    {
    int i,j,bigarr[rows][cols];
    int (*pz)[cols]=bigarr;
    printf("输入三个数集，每个数集包含五个int值\n");
    for(i=0;i<rows;i++)
    {
        for(j=0;j<cols;j++)
        scanf("%d",&bigarr[i][j]);
    }
    for(i=0;i<rows;i++)
    {
        for(j=0;j<cols;j++)
        printf("%4d ",bigarr[i][j]);
        printf("\n");
    }
    int acount[4];
    int sum=0,a;
</blockquote>
<pre><code>for(i=0;i&lt;rows;i++)
{
for(j=0;j&lt;cols;j++)
{
  a=pz[i][j];          //就是这里出问题啦！//这里卡了很久，第一个指针总是知道其它的值去
 //a+=bigarr[i][j];   //不能加等，这样首行地址的值加了类似偏移量的东西//用数组也不行
  acount[i]+=a; //！！！！！最后讨论出数组只能简单赋值被赋值
  sum+=a;
}
printf(&quot;%d行均值：%d \n&quot;,i+1,sum);
}
for(i=0;i&lt;3;i++)printf(&quot;acount%d: %d &quot;,i,acount[i]);
printf(&quot;\n\n均值：第一行%2d 第二行%2d 第三行%2d\n&quot;,\
       acount[0]/rows,acount[1]/rows,acount[2]/rows);
printf(&quot;%总和：3%d %d %d %d %d %d&quot;,sum,pz[0][0],pz[0][1],\
       pz[0][2],pz[0][3],pz[0][4]);
b_max(rows,cols,bigarr);

}

void b_max(int rows,int cols,const int arr[rows][cols])
{
int i,j,rows_index=0,cols_index=0,(*max)[cols];
max=arr;
for(i=0;i&lt;rows;i++)
{
    for(j=0;j&lt;cols;j++)
    {
        if(arr[i][j]&gt;**max)
            max=&amp;arr[i][j];
     }
}
for(i=0;i&lt;rows;i++)
{
 for(j=0;j&lt;cols;j++)
 {
  if(arr[i][j]==**max)
  {
    rows_index=i+1;
    cols_index=j+1;
  }
 }
}
 printf(&quot;\n最大值：%d  索引：%d %d\n&quot;,**max,rows_index,cols_index);
}

//10.9
void addarr(const int arr1[],const int arr2[],int size)
{
int i,addarr[size],*pa,*pb;
pa=arr1;
pb=arr2;
for(i=0;i&lt;size;i++)
{
 addarr[i]=*pa+*pb;
 pa++;pb++;
}
for(i=0;i&lt;size;i++)printf(&quot;%2d &quot;,addarr[i]);
}
//10.8
int valarr(int rows,int cols,int arr[rows][cols])
{
int i,j;
for(i=0;i&lt;rows;i++)
{
 for(j=0;j&lt;cols;j++)
 {
 printf(&quot;%2d &quot;,arr[i][j]);
 }
}
printf(&quot;\n&quot;);
}
//10.7
void copy_arr2(const int arr[],int size)
{
int a_num[3];
int *p1,*p2;
p1=arr;
p2=a_num;
 int i,x=0;
  for(i=0;i&lt;size;i++)
  {
   if(i==2||i==3||i==4)
   {
   *p2=*p1;
    p2++;
   }
   p1++;
 }
 for(i=0;i&lt;3;i++)printf(&quot;%d  &quot;,a_num[i]);

}

//10.4 10.5
void max(const int arr[],int size)
{
int i,max_index=0,min_index=0,*max,*min;
max=arr;min=arr;
for(i=0;i&lt;size;i++)
{
    if(arr[i]&gt;*max) max=&amp;arr[i];
    if(arr[i]&lt;*min) min=&amp;arr[i];
}
for(i=0;i&lt;size;i++)
{
 if(*(arr+i)==*max)max_index=i+1;
 if(*(arr+i)==*min)min_index=i+1;
}
printf(&quot;最大值：%d  索引：%d\n&quot;,*max,max_index);
printf(&quot;最小值：%d  索引：%d\n&quot;,*min,min_index);
printf(&quot;差值： % d\n&quot;,max_index-min_index);

}
 void copy_arr(double ar0[],double ar1[])
{
int i;
for(i=0;i&lt;5;i++)
{
ar1[i]=ar0[i];
}

}

void copy_ptr1(const double *p0,double *p2)
{
int i=0;
for(i=0;i&lt;5;i++)
{
 *p2=*p0;
p2++;
p0++;
}
}
 //这个不可以----我想明白啦！！！！
//之前错误的数字，是指针没有与两个数组进行联系
void copy_ptr2(double ar[],double ar3[])
{
double *p;
int i;
p=ar3;
for(i=0;i&lt;5;i++)
{
 *p++=ar[i];
}

}
//10.3递归显示数组
void ideal(int num[],int n)
{
if(n&gt;0)
{
  --n;
  ideal(num,n);

}
printf(&quot; %d &quot;,num[n]);
}
//**冒泡排序算法
void bubblesort(int arr[],int n)
{
int i,j;
for ( i = 0; i&lt;n - 1; i++)
    for ( j = 0; j &lt; n - i - 1; j++)
    {
        //如果前面的数比后面大，进行交换
        if (arr[j] &gt; arr[j + 1])
            {
            int temp = arr[j];
            arr[j] = arr[j + 1];
            arr[j + 1] = temp;
        }
    }

  }</code></pre><p></pre></p>
<blockquote>
<hr>
<h1 id="第十一章字符串和字符函数"><a href="#第十一章字符串和字符函数" class="headerlink" title="第十一章字符串和字符函数"></a>第十一章字符串和字符函数</h1></font>
</blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/lidabo/p/5225868.html" target="_blank" rel="noopener">c语言字符串操作大全</a></p>
</blockquote>
<blockquote>
<ul>
<li>函数gets(),puts(),strcat(),strncat(),strcmp(),strncmp(),strcpy(),strcpy(),sprintf(),strchr()</li>
<li>命令函参数</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>gets()函数的读取规则：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>1.只要gets遇到换行符，即便它是输入的第一个字符，gets也会停止读入并返回。如果输入的第一个字符就是换行符，则字符串将被置为空串。<br>2.由于gets函数读入再丢弃换行符，换行符将不会存储在字符串中。<br>gets的读取规则与getline是一样的。<br>gets函数的返回值：<br>1.正常读入（未遇到文件结尾）(注意，读入空串也是正常读入),则返回字符串，即返回字符串首地址，char*类型<br>2.遇到文件结尾，返回NULL<br>while (getchar()!=’\n’) ;</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>字符串是以空字符结尾的char数组</li>
<li>字符串常量：char greeting[59]=”hello”<blockquote>
<p>属于静态存储（static storage）类，静态存储是指如果一个函数中使用字符串常量，即使多次调用这个函数，该字符串在整个程序的运行过程中只存储一份。</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<p><font size=5 color=blue>函数名: strstr()        </font></font></p>
<p>函数原型：</p>
<p> char *strstr(char *str1, const char *str2);</p>
<p>语法：<br>* strstr(str1,str2)<br>str1: 被查找目标　string expression to search.</p>
<p>str2: 要查找对象　The string expression to find.</p>
</blockquote>
<p>返回值：若str2是str1的子串，则返回str2在str1的首次出现的地址；如果str2不是str1的子串，则返回NULL。</p>
<blockquote>
<hr>
<h1 id="第十二章存储类，链接和内存管理"><a href="#第十二章存储类，链接和内存管理" class="headerlink" title="第十二章存储类，链接和内存管理"></a>第十二章存储类，链接和内存管理</h1><p><a href="https://www.cnblogs.com/avril/archive/2010/03/22/1691477.html" target="_blank" rel="noopener">int main(int argc,char* argv[]详解</a></p>
</blockquote>
<blockquote>
<p>argc是命令行总的参数个数<br> argv[]是argc个参数，其中第0个参数是程序的全名，以后的参数<br>命令行后面跟的用户输入的参数</p>
<p>在C语言中，有5种不同的存储类型，即存储类。在介绍存储类之前，需要首先简单介绍几个术语。如下：</p>
</blockquote>
<blockquote>
<ul>
<li>作用域：描述程序中可以访问一个标识符的一个或多个区域。一个C变量的作用域可以是代码块作用域、函数原型作用域、或者文件作用域。代码块作用域是在代码块中定义的变量，该变量的作用范围从代码块中变量的定义开始到代码块结束；函数原型作用域从变量定义开始到原型声明的末尾，这就意味着编译器在处理一个函数原型的参数时，只是关心该参数的类型，所以声明一个函数int sum(int x,int y)和int sum(int,int)是一样的；而一个在所用函数之外定义的变量具有文件作用域，具有文件作用域的变量从他定义开始到包含该定义文件的结尾处都是可见的，也被称作全局变量。代码说话:</li>
</ul>
</blockquote>
<pre><code>1 #include&lt;stdio.h&gt;
2 
3 int x = 0;//x具有文件作用域,在这程序中结尾之前都是可见的
4 int sum(int m,int n);//m,n具有函数原型作用域,只在申明处可见
5 
6 int main(int argc, char* argv[])
7 {
8 int y = 1;//y具有代码块作用域,只在该代码块中可见
9 }</code></pre><blockquote>
<ul>
<li>存储时期：一个C变量有以下两种存储时期十一：静态存储时期和自动存储时期。所谓静态存储时期，就是一个变量在程序执行期间一直存在，上文所说的具有文件作用域的变量就属于静态存储；对于自动存储时期，则对应上述所说的具有代码块作用域的变量，当程序进入定义这些变量的代码块时，将自动为这些变量分配内存，退出这个代码块时，这些变量所占的内存将会自动被释放。</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>链接：链接分为外部链接，内部链接，以及空链接。具有代码块作用域或者函数原型的变量有空链接。具有文件作用域的变量可能有内部链接或者外部链接。区别内部链接和外部链接是由static决定。内部链接由static关键字修饰，表明该变量可以在一个文件的任何地方使用，外部链接没有static修饰，表明该链接可以在一个多文件程序的任何地方使用。</li>
</ul>
</blockquote>
<pre><code>1 int x = 10;  //文件作用域,外部链接
2 static int y = 11; //文件作用域,内部链接
3 
4 int main(){
5   ...
6 }</code></pre><blockquote>
<p>　　下面是5中存储类的对比表格：  </p>
</blockquote>
<blockquote>
<p><img src="https://images0.cnblogs.com/blog2015/592290/201505/162023172821182.png" alt="1"></p>
</blockquote>
<blockquote>
<p>&lt;补动态数组，文件输入输出&gt;malloc（）</p>
<p>函数:malloc()函数可以在程序运行时分配更多的内存。</p>
<p>它接受一个参数：所需内存字节数</p>
</blockquote>
<pre><code>ptr = (int *)malloc(20 * sizeof(int));
//类型指派(int *)在C中是可选的,但是在C++中是必须的</code></pre><blockquote>
<p>c语言关键字</p>
</blockquote>
<pre><code>（1） 数据类型关键字（12个）： 
(1) char ：声明字符型变量或函数 
(2) double ：声明双精度变量或函数 
(3) enum ：声明枚举类型 
(4) float：声明浮点型变量或函数 
(5) int： 声明整型变量或函数 
(6) long ：声明长整型变量或函数 
(7) short ：声明短整型变量或函数 
(8) signed：声明有符号类型变量或函数 
(9) struct：声明结构体变量或函数 
(10) union：声明联合数据类型 
(11) unsigned：声明无符号类型变量或函数 
(12) void ：声明函数无返回值或无参数，声明无类型指针（基本上就这三个作用） 

（2）控制语句关键字（12个）： 
a循环语句 
(1) for：一种循环语句(可意会不可言传） 
(2) do ：循环语句的循环体 
(3) while ：循环语句的循环条件 
(4) break：跳出当前循环 
(5) continue：结束当前循环，开始下一轮循环 
b条件语句 
(1)if: 条件语句 
(2)else ：条件语句否定分支（与 if 连用） 
(3)goto：无条件跳转语句 
c开关语句 
(1)switch :用于开关语句 
(2)case：开关语句分支 
(3)default：开关语句中的“其他”分支 

return ：子程序返回语句（可以带参数，也看不带参数） 

3 存储类型关键字（4个） 
(1)auto ：声明自动变量 一般不使用 
(2)extern：声明变量是在其他文件中声明（也可以看做是引用变量） 
(3)register：声明寄存器变量 
 //Register修饰符暗示编译程序相应的变量将将被频繁使用，如果可能的话，
 //应将其保存在CPU的寄存器中，以指加快其存取速度
 //因为register变量可能不存放在内存中，所以不能用取址符运算符“ &amp; ”来获取取
 //址符运算符“ &amp;” register变量的地址。如果你试图这样做，编译程序就会报告这是一个错误。

(4)static ：声明静态变量 

4 其它关键字（4个）： 
(1)const ：声明只读变量 
(2)sizeof：计算数据类型长度 
(3)typedef：用以给数据类型取别名（当然还有其他作用 
(4)volatile：说明变量在程序执行中可被隐含地改变</code></pre><blockquote>
<hr>
<h1 id="第十三章文件输入输出"><a href="#第十三章文件输入输出" class="headerlink" title="第十三章文件输入输出"></a><font color=red>第十三章文件输入输出</font></h1><ul>
<li>文件是什么：一个文件通常就是磁盘上的一段命名的存储区。c将文件看成连续的字节序列，其中每一个字节都可以单独地读取。</li>
<li>文件视图和二进制视图<blockquote>
<p>二进制视图中，文件中的每个字节都可以为程序所访问<br>文本试图中，读取文件时，将把行尾的本地环境表示法映射为C视图。如果c处理一个MA-DOS文本文件，在读取文件时它会将\r\n转换为\n，在写入文件时它会将\n转换成\r\n</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>exit()和return():exit()函数关闭所有打开的文件并终止程序如果main()在一个递归程序中，exit()仍然会终止程序，但return将控制权移交给递归的前一级</li>
<li>** fopen()函数**<blockquote>
<p>在&lt;stdio.h&gt;定义<br>fopen(文件名的地址,“模式字符串”)</p>
</blockquote>
</li>
</ul>
<p>模式字符串(文本模式)     |  </p>
<ul>
<li>|:-:|<br>“r   “    | 打开一个文本文件,可以读取文件(不可写入文件)<br>“w”       |打开一个文本文件,可以写入文件,如文件存在,先将文件长度截为0,如文件不存在,就创建文件(不可读取文件)<br>“a”    |打开一个文本文件,可以写入文件,写入的文件追加在原始文件尾部,如果文件不存在,就创建(不可读取文件)<br>“r+”    |打开一个文本文件,可以更新,即可读取和写入文件(可读写)<br>“w+”    |打开一个文本文件,可以更新,即可读取和写入文件,先将文件长度截为0,如果文件不存在,就创建文件(可读写)<br>“a+”    |打开一个文本文件,可以更新,即可读取和写入文件,可读取全部文件,但是只能追加到文件尾部,如果文件不存在,就创建文件。(可读写)<br>二进制模式(b)    |模式后面跟b,为二进制模式,如:rb,ab,wb,rb+,ab+,wb+<br>|注意：w/w+/wb模式会先将其文件清空在写入文件.</li>
<li>getc()函数和putc()函数<blockquote>
<p>和getchar和putchar类似，不同之处，在于需要告诉getc和putc函数它们要使用的文件<br>ch=getc(fp);<br>putc(ch,fpout);</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>13.2.4文件结尾<br>设计范例<blockquote>
<p><code>int ch; 
FILE *fp; fp=fopen&quot;wacky.txt&quot;,&quot;r&quot;);</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p><code>while((ch=getc(fp))!=EOF) //getc()会返回一个值</code></p>
</blockquote>
<blockquote>
<p><code>{</code></p>
</blockquote>
<blockquote>
<p><code>putchar(ch);</code></p>
</blockquote>
<blockquote>
<p><code>}</code></p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>fclose()函数<blockquote>
<p><code>if(fclose(fp)!=&#39;\0&#39;)</code><br><code>printf(&quot;Eorr in closing file %s\n&quot;,argv[1]);</code></p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>rewind()函数接受一个文件指针回到文件开始处</li>
</ul>
</blockquote>
<ul>
<li><p>fprintf()和fscanf():函数作用：格式化输出到一个流/文件中； </p>
<blockquote>
<p>第一个参数用来指定合适的文件</p>
</blockquote>
<blockquote>
<p><code>fprintf(stdout,&quot;    &quot;)</code></p>
</blockquote>
<blockquote>
<p><code>fscanf(fp,&quot;%s&quot;,words)</code></p>
</blockquote>
<blockquote>
<p>fscanf（）函数详解:功 能: 从一个流中执行格式化输入,fscanf遇到空格和换行时结束，注意空格时也结束。</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li>fgets()：接受三个参数，依次是地址，输入字符串最大长度，文件指针</li>
</ul>
<blockquote>
<p>fgets(buf,max,fp)</p>
</blockquote>
<blockquote>
<p>fgets()遇到EOF的时候返回<font color='red'>NULL</font>值，否则返回传给它的地址值</p>
<table><td bgcolor=#qwe1>13.10.5处理每行的方法使用到fgets()</table>
fgets()会丢到换行符\n
>fgets()将换行符读入到字符串,而puts()函数会在输出中追加一个换行符 
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/zjy1364503349/article/details/53858103" target="_blank" rel="noopener">fgets()网址</a></p>
</blockquote>
<p>/<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>****</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong><br> char <em>fgets(char *s, int n,  FILE *stream)<br>   {<br>     register int c;<br>     register char *cs;<br>     cs=s;<br>     while(–n&gt;0 &amp;&amp;(c = getc(stream))!=EOF)<br>     if ((</em>cs++=  c) ==’\n’)<br>           break;<br>     <em>cs =’\0’;<br>     return (c == EOF &amp;&amp; cs == s) ?NULL :s ;<br>    }<br>    /<strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong><strong>***</strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></strong></em>  </p>
</blockquote>
<pre><code>   在用fgets(..)读入数据时，先定义一个字符数组或字符指针，如果定义了字符指针 ，那么一定要初始化。

    example:

          char s[100]; //可以。

          char *s;  //不可以，因为只是声明了一个指针。但并没有为它分配内存缓冲区。

    所以，如果要用指针，则  char *s=(char *)malloc(100*sizeof(char)); 为其分配内存空间,c++中用char *s=new char [100];      如果为分配内存空间，编译时不会检查出问题，但运行时会出现未知错误。。

    fgets(...)读入文本行时的两种情况。

      1.如果n大于一行的字符串长度，那么当读到字符串末尾的换行符时，fgets(..)会返回。并且在s的最后插入字符串结束标志&apos;\0&apos;。 而s缓冲区剩余的位置不会再填充。

       example：

          123abc

          fgets(s,10,fp);

          此时，读入七个字符，123abc\n,实际上还有最后的&apos;\0&apos;,所以，strlen(s)=7; 如果要去除末尾的\n，s[strlen(s)-1]=&apos;\0&apos;;便可。

      2.如果n小于等于一行的字符串的长度，那么读入n-1个字符，此时并没有读入\n因为并没有到行尾 ，同样在最后会插入&apos;\0&apos;.

      example:

        123abc

        char  s[5];

        fgets(s,5,fp);

        这时读入4个字符，123a,并没有换行符，所以strlen(s)=4.

   fgets(...)读入整个文件内容

      通常用while()循环来使fges()读入文本全部内容，并按行读入。



[cpp] view plain copy

 在CODE上查看代码片派生到我的代码片
char s[1024];  
       while((fgets(s,1024,fp))!=NULL)  
        {  
              printf(s);  
        }  

     当然如果n小于每行的字符个数，也可以读，只不过读的次数要多。

      假设一行为 ： 123456789



[cpp] view plain copy

 在CODE上查看代码片派生到我的代码片
char s[2];  
      int  num=0;  
      while((fgets(s,2,fp))!=NULL)  
        {  
             printf(s);  
             n++;  
        }  

      每次读入一个字符， 最后也会读完一行，num=10，读了十次，所以，fgets若没遇到换行符，会接着从前一次的位置继续读入n-1个字符,只要是文本流没关闭。

     读入空行的情况：

        第一行   abcdef123

        第二行                       

        第三行  helloworld

        其中第二行为空，fget(..)会把第二行也读入，因为并未到文件结尾。

        有时我们并不需要空行，可以这样做。



[cpp] view plain copy

 在CODE上查看代码片派生到我的代码片
while((fgets(s,n,fp))!=NULL)  
         {  
              if(strlen(s)!=1)    //注意这儿是1不是0，因为尽管是空行，它也会读入换行符，strlen(s)=1;  
                  printf(s);  
         }  

     fgets(...)从标准设备读数据。

        用fgets(...)还也读入标准输入设备(一般为键盘)的信息

        原型  ：  fgets(s,n,stdin);

        假设在控制台下，我们可以用fgets(...)替代gets(),读入键盘输入的信息，fgets()是安全的，因为不会像gets()有溢出的可能。。

        比如 ：输入 abc

        fgets(s,n,stdin)也会读入n-1个字符。但是只是从stdin流读入</code></pre><blockquote>
<ul>
<li>fputs()函数：接受两个参数依次是一个字符串地址和一个文件指针。它把指针所指所指的字符串写入指定的文件</li>
</ul>
</blockquote>
<blockquote>
<ul>
<li><font color=red>随机存取：fseek()和ftell()</font></li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/wl_soft50/article/details/7787521" target="_blank" rel="noopener">函数fseek() 用法</a></p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p>功 能: 重定位流上的文件指针</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>用 法: int fseek(FILE *stream, long offset, int fromwhere);</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>描 述: 函数设置文件指针stream的位置。如果执行成功，stream将指向以fromwhere为基准，偏移offset个字     节的位置。如果执行失败(比如offset超过文件自身大小)，则不改变stream指向的位置。</p>
</blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<blockquote>
<p> 返回值: 成功，返回0，否则返回其他值。<br>  fseek position the file position pointer for the file referenced by stream to the byte location calculated by offset.<br>  程序例:</p>
</blockquote>
</blockquote>
</blockquote>
<pre>
#include <stdio.h>
  long filesize(FILE *stream);
  int main(void)
  {
    FILE *stream;
    stream = fopen("MYFILE.TXT", "w+");
    fprintf(stream, "This is a test");
    printf("Filesize of MYFILE.TXT is %ld bytes\n", filesize(stream));
    fclose(stream);
    return 0;
  }
  long filesize(FILE *stream)   //************
  {
    long curpos, length;
    curpos = ftell(stream);
    fseek(stream, 0L, SEEK_END);
    length = ftell(stream);
    fseek(stream, curpos, SEEK_SET);
    return length;
  }

</pre>

<blockquote>
<blockquote>
<p>fseek()的三个参数：指向文件指针，偏移量，模式</p>
</blockquote>
<blockquote>
<p>偏移量表示从起点开始要移动的距离，这个参数必须是long类型的值，正为前移，负为后移，零为不动</p>
</blockquote>
<blockquote>
<p>模式用来标识起点.</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SEEK_SET 文件开始 </p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SEEK_CUR 当前位置</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>SEEK_END 文件结尾</p>
</blockquote>
<pre>
fseek(fp, 0l,SEEK_SET);  //找到文件的开始处
fseek(fp,10l,SEEK_SET);//找到文件的第10个字节
fseek(fp,2l,SEEK_CUR);//从文件的当前位置向前移动2给字节
fseek(fp,0l,SEEK_END);//到达文件结尾处
fseek(fp,-10l,SEEK_END);//从文件结尾处退回10个字节
</pre>
<blockquote>
<ul>
<li>ftell()为long类型,返回文件的当前位置ftell()通过返回距文件开始处的字节数目来确定文件的位置<br>last=ftell(fp);把从文件开始到文件结尾的字节数目赋给last</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<pre>
   //程序清单13.4
    #include<stdio.h>
    #include<stdlib.h>
    #define CNTL_Z '\032'
    #define SLEN 50
    int main(coid)
    {
    char file[SLEN];
    char ch;
    FILE*fp;
    long count,last;
    puts("Enter the name of the file to be processed:");
    gets(file);
    if((fp=fopen(file,"rb"))==NULL)
    {
        printf("reverse cant open %s\n",file);
        exit(1);
    }
    fseek(fp,0l,SEEK_END);  //定位到文件结尾处
    last=ftell(fp);                           //返回总字节数
    for(count=1l; count<=last; count++)
    {
        fseek(fp,-count,SEEK_END);   //回退
        ch=getc(fp);
        if(ch!=CNTL_Z&&ch!='\r')
            putchar(ch);
        if(ch=='\r')
            putchar('\n');
        else
            putchar(ch);
    }
    putchar('\n');
    fclose(fp);
    return 0;
    }
</pre>
<ul>
<li>fgetpos()和fsetpos()函数<blockquote>
<p>fseek()和ftell()的一个潜在的问题是他们限制文件的大小只能在long类型的表示范围之类.ANSI C引入了两个来处理较大文件的新的定位函数.</p>
</blockquote>
</li>
</ul>
<blockquote>
<p>int fgetpos( FILE *stream, fpos_t *position );<br>fgetpos()函数保存给出的文件流(stream)的位置指针到给出的位置变量(position)中. position变量是fpos_t类型的(它在stdio.h中定义)并且是可以控制在FILE中每个可能的位置对象. fgetpos()执行成功时返回0,失败时返回一个非零值.</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>13.7其它标准i/o函数<blockquote>
<ul>
<li>int ungetc(int c,FILE* fp):将c指定的字符放回输入流中</li>
<li>int fflush(*fp) :可以将缓冲区中任何未写的数据发送到一个fp指定的输出文件中去,这个过程称为刷新缓冲区</li>
<li>int setvbuf():</li>
</ul>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>int setvbuf(FILE*restrict fp,char *restrict buf,int mode, size_t size)<br>setvbuf()函数建立了一个供标准i/o函数使用的替换缓冲区</p>
</blockquote>
</blockquote>
<blockquote>
<table><td bgcolor=#qwe123>13.7.4二进制I/O:fread()和fwrite()函数</table>
[fopen(),fwrite(),fread()学习网址](https://blog.csdn.net/yang2011079080010/article/details/52528261)
>所有的数据都是以二进制的方式进行存储的.如果文件中的全部数据都已字符编码的形式被解读,我们才称为文件包含文本数据

<pre>    
     //将一块256字节大小的数据块从缓冲   区写入到文件
    fwrite(buffer,256,1,fp);  
       //保存一个包含10个double值的数组.
    //将earnings数组中的数据写入文件,数据分成10块,每块都是double大小
    double earnings[10];
    fwrite(earnings,sizeof(double),10,fp);
</pre>
<blockquote>
<p>fwrite()函数返回成功写入的项目数,正常情况下与nmemb相等,不过如果写入错误,返回值就会小于nmemb</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>size_t fread()  – 类似</li>
</ul>
</blockquote>
<blockquote>
<p>原型: size_t fread(const void *restrict ptr(指针类型不是固定的),size_t  size,size_t nmemb,FILE *restrict fp);</p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li>13.7.7int feof(FILE *fp)和 int ferror(FILE *fp)函数<br>当标准输入函数返回EOF是,两种情况:1到达文件结尾2发生了读取错误<br>feof()和ferror()来区分两种可能性<blockquote>
<p>feof():检测到文件结尾.feof()返回一个非零值,否则返回零值</p>
</blockquote>
</li>
</ul>
</blockquote>
<blockquote>
<blockquote>
<p>ferror():发生读写错误,ferror()返回一个非零值,否则返回零值</p>
</blockquote>
<pre>
FILE * fopen(const char * path,const char * mode);
    -- path: 文件路径，如："F:\Visual Stdio 2012\test.txt"
    -- mode: 文件打开方式，例如：
             "r" 以只读方式打开文件，该文件必须存在。
             "w" 打开只写文件，若文件存在则文件长度清为0，即该文件内容会消失。若文件不存在则建立该文件。
            "w+" 打开可读写文件，若文件存在则文件长度清为零，即该文件内容会消失。若文件不存在则建立该文件。
             "a" 以附加的方式打开只写文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾，即文件原先的内容会被保留。（EOF符保留）
             "a+" 以附加方式打开可读写的文件。若文件不存在，则会建立该文件，如果文件存在，写入的数据会被加到文件尾后，即文件原先的内容会被保留。（原来的EOF符不保留）
            "wb" 只写打开或新建一个二进制文件，只允许写数据。
            "wb+" 读写打开或建立一个二进制文件，允许读和写。
             "ab" 追加打开一个二进制文件，并在文件末尾写数据。
             "ab+"读写打开一个二进制文件，允许读，或在文件末追加数据。   
    --返回值: 文件顺利打开后，指向该流的文件指针就会被返回。如果文件打开失败则返回NULL，并把错误代码存在errno中。        
</pre>
</blockquote>
<blockquote>
<blockquote>
<ul>
<li>size_t fwrite()函数</li>
</ul>
</blockquote>
<blockquote>
<p>原型: size_t fwrite(const void *restrict ptr(指针类型不是固定的),size_t  size,size_t nmemb,FILE *restrict fp);</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>size_t是sizeof运算符返回的类型,通常是unsigned int类型</p>
</blockquote>
<blockquote>
<p>ptr是要写入的数据块的地址,</p>
</blockquote>
<blockquote>
<p>size表示写入数据块的大小,nmem表示数据块的数目<br>注意：返回值随着调用格式的不同而不同：<br><font color="red"></p>
<blockquote>
<p> (1) 调用格式：fwrite(buf,sizeof(buf),1,fp);  成功写入返回值为1(即count)</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>(2)调用格式：fwrite(buf,1,sizeof(buf),fp);<br> 成功写入则返回实际写入的数据个数(单位为Byte)<br> </font></p>
</blockquote>
</blockquote>
<pre>
size_t fwrite(const void* buffer, size_t size, size_t count, FILE* stream);
    -- buffer:指向数据块的指针
    -- size:每个数据的大小，单位为Byte(例如：sizeof(int)就是4)
    -- count:数据个数
    -- stream:文件指针
</pre>
<p> 写完数据后要调用fclose()关闭流，不关闭流的情况下，每次读或写数据后，文件指针都会指向下一个待写或者读数据位置的指针。</p>
</blockquote>
<pre>
/* fread example: read a complete file 读取一个完整的文件 */
    #include <stdio.h>
    #include <stdlib.h>
int main()
{
    FILE* pFile;   //文件指针
    long lSize;   // 用于文件长度
    char* buffer; // 文件缓冲区指针
    size_t result;  // 返回值是读取的内容数量

    pFile = fopen("myfile.bin" , "rb");
    if (pFile == NULL) {fputs("File error", stderr); exit(1);}    // 如果文件错误，退出1

    // obtain file size:  获得文件大小
    fseek(pFile , 0 , SEEK_END); // 指针移到文件末位
    lSize = ftell(pFile);  // 获得文件长度
    rewind(pFile);  // 函数rewind()把文件指针移到由stream(流)指定的开始处, 同时清除和流相关的错误和EOF标记

    // allocate memory to contain the whole file: 为整个文件分配内存缓冲区
    buffer = (char*) malloc(sizeof(char) * lSize); // 分配缓冲区，按前面的 lSize
    if (buffer == NULL) {fputs("Memory error", stderr); exit(2);}  // 内存分配错误，退出2

    // copy the file into the buffer:  该文件复制到缓冲区
    result = fread(buffer, 1, lSize, pFile); // 返回值是读取的内容数量
    if (result != lSize) {fputs("Reading error", stderr); exit(3);} // 返回值如果不和文件大小，读错误

    /* the whole file is now loaded in the memory buffer. */ //现在整个文件载入内存缓冲区

    // 读到内存，看自己怎么使用了...............
    // ...........


    // terminate // 文件终止
    fclose(pFile);
    free(buffer);
    return 0;
}
</pre>


<blockquote>
<h1 id="第十四章结构和其它数据形式"><a href="#第十四章结构和其它数据形式" class="headerlink" title="第十四章结构和其它数据形式"></a>第十四章结构和其它数据形式</h1></blockquote>
<blockquote>
<ul>
<li>struct ,union,typedef</li>
<li>运算符 . -&gt;</li>
<li>如何创建结构模板和结构变量</li>
<li>如果访问结构成员，编写处理结构的函数</li>
<li>联合及指向函数的指针</li>
</ul>
<hr>
<p>14.2建立结构声明</p>
</blockquote>
<blockquote>
<p><code>struct bool{</code></p>
</blockquote>
<blockquote>
<p><code>char title[MAXTITL];</code></p>
</blockquote>
<blockquote>
<p><code>char author[MAXTITL];</code></p>
</blockquote>
<blockquote>
<p><code>float value;</code></p>
</blockquote>
<blockquote>
<p><code>};</code></p>
</blockquote>
<blockquote>
<p>14.3定义结构变量</p>
<pre>
struct book library;
是下面声明的简化：
stuct book{
char title[MAX];
char author[MAX];
float value;
}library;//在定义后面跟变量名
</blockquote>
<blockquote>
<p></pre></p>
</blockquote>
<blockquote>
<p>14.3.2访问结构成员<br>使用.运算符</p>
</blockquote>
<blockquote>
<p>gets(library.title);</p>
</blockquote>
<blockquote>
<p>14.3.3结构的指定初始化项目</p>
</blockquote>
<blockquote>
<p>C99支持</p>
</blockquote>
<blockquote>
<p>14.5嵌套结构</p>
<p>(fellow.handle).first:从左到右，先找到fellow的成员handle,进而找到handle的成员first</p>
</blockquote>
<blockquote>
<p>14.6指向结构的指针<br>使用指针访问成员</p>
<pre>
him==&barney
barney.income==(*him).income==him->income
</pre>
</blockquote>
<blockquote>
<p>14.7.4其它结构特性</p>
<p>现在的C允许把一个结构赋值给另一个结构，和数组不同的地方</p>
</blockquote>
<blockquote>
<p>双向通信</p>
</blockquote>
<blockquote>
<p>14.7.6在结构中使用字符数组还是字符指针</p>
</blockquote>
<blockquote>
<p>字符串常量存储在编译器存储字符串常量的任何地方。这个结构中存放的知识两个地址而已。系统中它总共占用8个字节。stuct pnames结构不为字符串分配任何存储空间。它只适用于在另外的地方已经为字符串分配了空间（例如字符串常量或数组中的字符串）</p>
<pre>
struct pnames{
char *first;
char *last;
};
struct names veep={"Talia","Summers"};
stuct pname treas={"Brad","Fallingjaw"};
</blockquote>
<blockquote>
<p>stuct names accountant;<br>puts(“”);<br>scanf(“%s”,accountant.last);/<em>潜在的问题，空指针</em>/<br></pre></p>
</blockquote>
<blockquote>
<p>14.7.7结构，指针和malloc()</p>
<p>类似于创建的数组的第三种方法</p>
<p>使用malloc（）分配内存，用指针来存放地址</p>
</blockquote>
<blockquote>
<pre>
void getinfo(stuct namect *pst)
{
chat temp[81];
prinf("Enter your first name\n");
gets(temp);
//分配用来存放名字的内存
pst->fname=(char *)malloc(strlen(temp)+1);
strcpy(pst->fname,temp);
printf("Enter your last name\n");
gets(temp);
>pst->lname=(char *)malloc(strlen(temp)+1);
strcpy(pst->lname,temp);
}
</pre>
</blockquote>
<blockquote>
<p><a href="https://blog.csdn.net/lemonrabbit1987/article/details/47803377" target="_blank" rel="noopener">结构，联合，枚举</a></p>
</blockquote>
<pre>
结构体是C语言中一种非常重要的数据结构。与数组不同，结构体类型的变量的成员变量
（数组称元素）可以具有不同的类型，并通过成员变量的名称获取指定成员。联合和结构
体相似，但联合类型的变量的所有成员都共享同一存储空间，每次只能存储一个成员。枚
举类型是一组命名了的整数值。结构体、联合、枚举和数组都是用于创建多种多样的、与基
本数据类型同样的用户自定义的数据类型。

结构体

结构体类型的声明

结构体类型的声明格式如下：

struct
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 变量1, 变量2;

变量1和变量2都是该结构体类型的变量，结构体类型的变量的成员变量按声明的顺序在
内存中依序存储。结构体为其所有成员设置了单独的命名空间，因此可以在结构体外存在
与结构体内成员同名的变量。

结构体类型变量的成员可以是数组类型的变量，数组变量的元素也可以是结构体类型的。

结构体类型的变量的初始化

结构体类型的变量的初始化是依次列出结构体类型的变量各成员的值，用,隔开，并用大括号
扩起来，形式如下

struct
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 变量1 = {成员变量1的初始值, 成员变量2的初始化值，...},
  变量2 = {成员变量1的初始值, 成员变量2的初始化值，...};

注意：初始化式中的初始化值必须按结构成员的声明顺序给出，且初始化式中的表达
式必须是常量表达式。

结构体类型的变量的操作

结构体类型的变量通过成员名称访问其内部的成员，其访问格式为：

结构体类型变量.成员变量
1
2
.是C语言的一个运算符，优先级和++和--相同，几乎高于所有其他的运算符。

结构体类型变量的成员是一个左值，可以看作一个变量使用。类型一致的结构体类型变量之间可以使用赋值运算符相互赋值。

使用结构体类型作为函数的参数和返回值时，实际上使用的都是结构体类型的变量的副本。
这样结构比较大的时候，会产生大量的开销，所以一般都使用结构体类型的变量的指针。

结构体类型

按照声明结构体类型时定义变量的方式要求变量必须在一个地方完全声明，否则当在新的地方用
同样的方式定义变量时，不仅造成代码的结构臃肿，更重要的是C语言会将这些变量看成是不同的
类型。为了解决这个问题，C语言利用结构标记来标识特定结构体类型的名字，这样就可以在别的
地方使用结构标记来声明属于同样结构体类型的变量了。结构标记的声明格式如下：

struct 结构标记
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 变量1, 变量2;
struct 结构标记 变量3;
struct 结构标记 变量4;

注意：使用结构标记时，不能省略标记前面的struct单词。

除了使用结构标记，还可以使用typedef来为定义结构体类型的别名，其使用形式为：

typedef struct
{
    类型 成员变量1;
    类型 成员变量2；
    ...
} 结构体类型;
结构体类型 变量1;
结构体类型 变量2;

注意：当命名结构体类型时，通常两者都可以使用，但用于链表时必须强制声明结构标记。
</pre>

<blockquote>
<blockquote>
<h1 id="联合："><a href="#联合：" class="headerlink" title="联合："></a>联合：</h1><p>联合这个类型的设计就是为了节省内存，联合内的元素共用一段存储空间，空间大小由最大的数<br>据元素决定。联合空间只有一个最新赋值的成员值有效。一句话总结：空间共享，后来为主。</p>
</blockquote>
</blockquote>
<pre>
联合和结构体一样，联合类型的变量可以由具有不同类型的一个或多个成员变量构成。但编
译器只为联合类型的变量分配最大的成员变量需要的内存空间。联合类型的变量的所有成员变量共
用这段内存空间，因此给一个成员赋予新值就会修改其他成员的值。

联合类型的声明方式和结构体类型的声明方式一样：

union
{
  类型 成员变量1;
  类型 成员变量2;
} 联合变量;

访问联合类型变量的成员的方法和访问结构体类型变量的成员的方法相同，且联合类型的变量的
成员也是左值可以像变量一样使用。同时可以类似于结构体类型为其声明联合标记和类型定义。
联合类型的变量也可以使用赋值运算符执行赋值操作，也可作为参数和返回值在函数中使用。
联合类型的变量初始化时，只有第一个成员可以获得初始值，其初始化的一般形式为：

union
{
  类型 成员变量1;
  类型 成员变量2;
} 变量 = {成员变量1的值};

注意：初始化式两边的大括号是不可以省略的。

联合主要包括以下常见的应用，一是通过在结构体类型中使用联合节省空间，二是使用
联合类型的变量作为数组元素构建含有不同类型的混合的数据结构。

为了解决无法知道联合类型的变量当前存放的是哪个成员的问题，可以把联合类型的变
量作为结构体类型变量的成员，且结构体类型提供另一个成员变量作为标记来提示当前
存储在联合类型变量中的是哪个成员。而这个标记成员使用枚举类型是非常合适的。
</pre>


<blockquote>
<blockquote>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1></blockquote>
<p>枚举类型也是一种用户自定义类型，它允许用户定义有限个常量(注意是常量！)，每个常量由用户自己的标识符来标示，这种类型更贴近处理实际问题，每个常量标识符都有确定的意义，增强代码的可读性。</p>
</blockquote>
<blockquote>
<blockquote>
<h1 id="typedef"><a href="#typedef" class="headerlink" title="typedef"></a><a href="https://blog.csdn.net/superhoy/article/details/53504472" target="_blank" rel="noopener">typedef</a></h1></blockquote>
</blockquote>
<pre>第一、四个用途

<font color=red size=4>用途一：</font>

定义一种类型的别名，而不只是简单的宏替换。可以用作同时声明指针型的多个对象。比如：
char* pa, pb; // 这多数不符合我们的意图，它只声明了一个指向字符变量的指针， 
// 和一个字符变量；
以下则可行：
typedef char* PCHAR; // 一般用大写
PCHAR pa, pb; // 可行，同时声明了两个指向字符变量的指针
虽然：
char *pa, *pb;
也可行，但相对来说没有用typedef的形式直观，尤其在需要大量指针的地方，typedef的方式
更省事。

<font color=red size=4>用途二：</font>

用在旧的C的代码中（具体多旧没有查），帮助struct。以前的代码中，声明struct新对象时，
必>须要带上struct，即形式为： struct 结构名 对象名，如：

[cpp] view plain copy
struct tagPOINT1  
{  
    int x;  
    int y;  
};  
struct tagPOINT1 p1;   
而在C++中，则可以直接写：结构名 对象名，即：

tagPOINT1 p1;

估计某人觉得经常多写一个struct太麻烦了，于是就发明了：

[cpp] view plain copy
typedef struct tagPOINT  
{  
    int x;  
    int y;  
}POINT;  
POINT p1; // 这样就比原来的方式少写了一个struct，比较省事，尤其在大量使用的时候  
或许，在C++中，typedef的这种用途二不是很大，但是理解了它，对掌握以前的旧代码
还是有帮助的，毕竟我们在项目中有可能会遇到较早些年代遗留下来的代码。

<font color=red size=4>用途三：</font>

用typedef来定义与平台无关的类型。
比如定义一个叫 REAL 的浮点类型，在目标平台一上，让它表示最高精度的类型为：
typedef long double REAL; 
在不支持 long double 的平台二上，改为：
typedef double REAL; 
在连 double 都不支持的平台三上，改为：
typedef float REAL; 
也就是说，当跨平台时，只要改下 typedef 本身就行，不用对其他源码做任何修改。
标准库就广泛使用了这个技巧，比如size_t。
另外，因为typedef是定义了一种类型的新别名，不是简单的字符串替换，所以它比宏来
得稳健（虽然用宏有时也可以完成以上的用途）。

<font color=red size=4>用途四：</font>

为复杂的声明定义一个新的简单的别名。方法是：在原来的声明里逐步用别名替换一部分
复杂声明，如此循环，把带变量名的部分留到最后替换，得到的就是原声明的最简化版。举例：

1. 原声明：int *(*a[5])(int, char*);
变量名为a，直接用一个新别名pFun替换a就可以了：
typedef int *(*pFun)(int, char*); 
原声明的最简化版：
pFun a[5];

2. 原声明：void (*b[10]) (void (*)());
变量名为b，先替换右边部分括号里的，pFunParam为别名一：
typedef void (*pFunParam)();
再替换左边的变量b，pFunx为别名二：
typedef void (*pFunx)(pFunParam);
原声明的最简化版：
pFunx b[10];

3. 原声明：doube(*)() (*e)[9]; 
变量名为e，先替换左边部分，pFuny为别名一：
typedef double(*pFuny)();
再替换右边的变量e，pFunParamy为别名二
typedef pFuny (*pFunParamy)[9];
原声明的最简化版：
pFunParamy e;

理解复杂声明可用的“右左法则”：
从变量名看起，先往右，再往左，碰到一个圆括号就调转阅读的方向；括号内分析完就跳
出括号，还是按先右后左的顺序，如此循环，直到整个声明分析完。举例：
int (*func)(int *p);
首 先找到变量名func，外面有一对圆括号，而且左边是一个*号，这说明func是一个指针；
然后跳出这个圆括号，先看右边，又遇到圆括号，这说明 (*func)是一个函数，所以func是
一个指向这类函数的指针，即函数指针，这类函数具有int*类型的形参，返回值类型是int。
int (*func[5])(int *);
func 右边是一个[]运算符，说明func是具有5个元素的数组；func的左边有一个*，说明
func的元素是指针（注意这里的*不是修饰func，而是修饰 func[5]的，原因是[]运算符
优先级比*高，func先跟[]结合）。跳出这个括号，看右边，又遇到圆括号，说明func数组
的元素是函数类型的指 针，它指向的函数具有int*类型的形参，返回值类型为int。

也可以记住2个模式：
type (*)(....)函数指针 
type (*)[]数组指针
</pre>


<pre>
第二、两大陷阱

陷阱一：

记住，typedef是定义了一种类型的新别名，不同于宏，它不是简单的字符串替换。比如：
先定义：
typedef char* PSTR;
然后：
int mystrcmp(const PSTR, const PSTR);

const PSTR实际上相当于const char*吗？不是的，它实际上相当于char* const。
原因在于const给予了整个指针本身以常量性，也就是形成了常量指针char* const。
简单来说，记住当const和typedef一起出现时，typedef不会是简单的字符串替换就行。

陷阱二：

typedef在语法上是一个存储类的关键字（如auto、extern、mutable、static、register等一样），虽然它并不真正影响对象的存储特性，如：
typedef static int INT2; //不可行
编译将失败，会提示“指定了一个以上的存储类”。


第三、typedef 与 #define的区别

案例一：

通常讲，typedef要比#define要好，特别是在有指针的场合。请看例子：

[cpp] view plain copy
typedef char *pStr1;  
#define pStr2 char *;  
pStr1 s1, s2;  
pStr2 s3, s4;  

在上述的变量定义中，s1、s2、s3都被定义为char *，而s4则定义成了char，不是我们
所预期的指针变量，根本原因就在于#define只是简单的字符串替换而typedef则是为
一个类型起新名字。

案例二：

下面的代码中编译器会报一个错误，你知道是哪个语句错了吗？

[cpp] view plain copy
typedef char * pStr;  
char string[4] = "abc";  
const char *p1 = string;  
const pStr p2 = string;  
p1++;  
p2++;  
是p2++出错了。这个问题再一次提醒我们：typedef和#define不同，它不是简单的
文本替换。上述代码中const pStr p2并不等于const char * p2。const pStr p2和
const long x本质上没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型
 是我们自己定义的而不是系统固有类型而已。因此，const pStr p2的含义是：限定数据类
型为char *的变量p2为只读，因此p2++错误。

</pre>

<pre>
第四部分资料：使用 typedef 抑制劣质代码




摘要： Typedef 声明有助于创建平台无关类型，甚至能隐藏复杂和难以理解的语法。
不管怎样，使用 typedef 能为代码带来意想不到的好处，通过本文你可以学习用 typedef
 避免缺欠，从而使代码更健壮。
typedef 声明，简称 typedef，为现有类型创建一个新的名字。比如人们常常使用 typedef 
来编写更美观和可读的代码。所谓美观，意指 typedef 能隐藏笨拙的语法构造以及平台相关
的数据类型，从而增强可移植性和以及未来的可维护性。本文下面将竭尽全力来揭示 typedef 
强大功能以及如何避免一些常见的陷阱。

Q：如何创建平台无关的数据类型，隐藏笨拙且难以理解的语法?

A： 使用 typedefs 为现有类型创建同义字。

定义易于记忆的类型名 
　　typedef 使用最多的地方是创建易于记忆的类型名，用它来归档程序员的意图。类型出现
在所声明的变量名字中，位于 ''typedef'' 关键字右边。例如：

typedef int size;
此声明定义了一个 int 的同义字，名字为 size。注意 typedef 并不创建新的类型。它仅仅为现
有类型添加一个同义字。你可以在任何需要 int 的上下文中使用 size：

void measure(size * psz); size array[4];size len = file.getlength();std::vector <size> vs; 
typedef 还可以掩饰符合类型，如指针和数组。例如，你不用象下面这样重复定义有 81 个字符
元素的数组：

char line[81];char text[81];
定义一个 typedef，每当要用到相同类型和大小的数组时，可以这样：

typedef char Line[81]; Line text, secondline;getline(text);
同样，可以象下面这样隐藏指针语法：

typedef char * pstr;int mystrcmp(pstr, pstr);
这里将带我们到达第一个 typedef 陷阱。标准函数 strcmp()有两个‘const char *’类型的参数。
因此，它可能会误导人们象下面这样声明 mystrcmp()：

int mystrcmp(const pstr, const pstr); 
这是错误的，按照顺序，‘const pstr’被解释为‘char * const’（一个指向 char 的常量指针），
而不是‘const char *’（指向常量 char 的指针）。这个问题很容易解决：

typedef const char * cpstr; int mystrcmp(cpstr, cpstr); // 现在是正确的
记住： 不管什么时候，只要为指针声明 typedef，那么都要在最终的 typedef 名称中加一个 
const，以使得该指针本身是常量，而不是对象。

代码简化 
　　上面讨论的 typedef 行为有点像 #define 宏，用其实际类型替代同义字。不同点是
 typedef 在编译时被解释，因此让编译器来应付超越预处理器能力的文本替换。例如：

typedef int (*PF) (const char *, const char *);
这个声明引入了 PF 类型作为函数指针的同义字，该函数有两个 const char * 类型的参数以及
一个 int 类型的返回值。如果要使用下列形式的函数声明，那么上述这个 typedef 是不可或缺
的：

PF Register(PF pf);
Register() 的参数是一个 PF 类型的回调函数，返回某个函数的地址，其署名与先前注册的名字
相同。做一次深呼吸。下面我展示一下如果不用 typedef，我们是如何实现这个声明的：

int (*Register (int (*pf)(const char *, const char *))) (const char *, const char *); 
很少有程序员理解它是什么意思，更不用说这种费解的代码所带来的出错风险了。显然，这里
使用 typedef 不是一种特权，而是一种必需。持怀疑态度的人可能会问：“OK，有人还会写这样
的代码吗？”，快速浏览一下揭示 signal()函数的头文件 <csinal>，一个有同样接口的函数。

typedef 和存储类关键字（storage class specifier） 
　　这种说法是不 是有点令人惊讶，typedef 就像 auto，extern，mutable，static，和 
register 一样，是一个存储类关键字。这并是说 typedef 会真正影响对象的存储特性；它只
是说在语句构成上，typedef 声明看起来象 static，extern 等类型的变量声明。下面将带到第二个陷阱：

typedef register int FAST_COUNTER; // 错误
编译通不过。问题出在你不能在声明中有多个存储类关键字。因为符号 typedef 已经占据了
存储类关键字的位置，在 typedef 声明中不能用 register（或任何其它存储类关键字）。

促进跨平台开发 
　　typedef 有另外一个重要的用途，那就是定义机器无关的类型，例如，你可以定义一个
叫 REAL 的浮点类型，在目标机器上它可以i获得最高的精度：

typedef long double REAL; 
在不支持 long double 的机器上，该 typedef 看起来会是下面这样：

typedef double REAL; 
并且，在连 double 都不支持的机器上，该 typedef 看起来会是这样： 、

typedef float REAL; 
你不用对源代码做任何修改，便可以在每一种平台上编译这个使用 REAL 类型的应用程序。
唯一要改的是 typedef 本身。在大多数情况下，甚至这个微小的变动完全都可以通过奇妙的
条件编译来自动实现。不是吗? 标准库广泛地使用 typedef 来创建这样的平台无关类型：size_t
，ptrdiff 和 fpos_t 就是其中的例子。此外，象 std::string 和 std::ofstream 这样的 typedef 
还隐藏了长长的，难以理解的模板特化语法，例如：basic_string<char, char_traits<char>，allocator<char>> 和 basic_ofstream<char, char_traits<char>>
 </pre>
<pre>
typedef & 结构的问题 
　　

（1）、typedef的最简单使用 
　　typedef long byte_4; 
　　给已知数据类型long起个新名字，叫byte_4。 
（2）、 typedef与结构结合使用 
　　typedef struct tagMyStruct 
　　{ 
　　int iNum; 
　　long lLength; 
　　} MyStruct; 
　　这语句实际上完成两个操作： 
1) 定义一个新的结构类型 
　　struct tagMyStruct 
　　{ 
　　int iNum; 
　　long lLength; 
　　}; 
　　分析：tagMyStruct称为“tag”，即“标签”，实际上是一个临时名字，struct 关键字和
tagMyStruct一起，构成了这个结构类型，不论是否有typedef，这个结构都存在。 
　　我们可以用struct tagMyStruct varName来定义变量，但要注意，使用
tagMyStruct varName来定义变量是不对的，因为struct 和tagMyStruct合在一起才
能表示一个结构类型。 
2) typedef为这个新的结构起了一个名字，叫MyStruct。 
　　typedef struct tagMyStruct MyStruct; 
　　因此，MyStruct实际上相当于struct tagMyStruct，我们可以使用MyStruct varName
来定义变量。 
3)、规范做法： 
　　struct tagNode 
　　{ 
　　char *pItem; 
　　struct tagNode *pNext; 
　　}; 
　　typedef struct tagNode *pNode; 
3. typedef & #define的问题 
　　有下面两种定义pStr数据类型的方法，两者有什么不同？哪一种更好一点？ 
　　typedef char* pStr; 
　　#define pStr char*; 
　　答案与分析： 
　　通常讲，typedef要比#define要好，特别是在有指针的场合。请看例子： 
　　typedef char* pStr1; 
　　#define pStr2 char * 
　　pStr1 s1, s2; 
　　pStr2 s3, s4; 
　　在上述的变量定义中，s1、s2、s3都被定义为char *，而s4则定义成了char，
不是我们所预期的指针变量，根本原因就在于#define只是简单的字符串替换而typedef
则是为一个类型起新名字。 
　　上例中define语句必须写成 pStr2 s3, *s4; 这这样才能正常执行。 
　　#define用法例子： 
　　#define f(x) x*x 
　　main( ) 
　　{ 
　　int a=6，b=2，c； 
　　c=f(a) / f(b)； 
　　printf("%d //n "，c)； 
　　} 
　　以下程序的输出结果是: 36。 
　　因为如此原因，在许多C语言编程规范中提到使用#define定义时，
如果定义中包含表达式，必须使用括号，则上述定义应该如下定义才对： 
　　#define f(x) (x*x) 
　　当然，如果你使用typedef就没有这样的问题。 
4. typedef & #define的另一例 
　　下面的代码中编译器会报一个错误，你知道是哪个语句错了吗？ 
　　typedef char * pStr; 
　　char string[4] = "abc"; 
　　const char *p1 = string; 
　　const pStr p2 = string; 
　　p1++; 
　　p2++; 
　　答案与分析： 
　 　  是p2++出错了。这个问题再一次提醒我们：typedef和#define不同，
它不是简单的文本替 换。上述代码中const pStr p2并不等于const char * p2。const pStr p2
和const long x本质 上  没有区别，都是对变量进行只读限制，只不过此处变量p2的数据类型
是我们自己定义的而不是系统固有类型而已。因此，const pStr p2的含义是：限定数据类型为
char *的变量p2为只读，因此p2++错误。 

　　<font color=red size=4>#define与typedef引申谈 


　　1) #define宏定义有一个特别的长处：可以使用 #ifdef ,#ifndef等来进行逻辑判断，
还可以使用#undef来取消定义。 

　　2) typedef也有一个特别的长处：它符合范围规则，使用typedef定义的变量类型其作用
范围限制在所定义的函数或者文件内（取决于此变量定义的位置），而宏定义则没有这种特性。
            </font>

5. typedef & 复杂的变量声明 
　　在编程实践中，尤其是看别人代码的时候，常常会遇到比较复杂的变量声明,
使用typedef作简化自有其价值，比如： 
　　下面是三个变量的声明，我想使用typdef分别给它们定义一个别名，请问该如何做？ 
　　>1：int *(*a[5])(int, char*); 
　　>2：void (*b[10]) (void (*)()); 
　　>3. double(*)() (*pa)[9]; 
　　答案与分析： 
　　对复杂变量建立一个类型别名的方法很简单，你只要在传统的变量声明表达式里
用类型名替代变量名，然后把关键字typedef加在该语句的开头就行了。 
　　>1：int *(*a[5])(int, char*); 
　　//pFun是我们建的一个类型别名 
　　typedef int *(*pFun)(int, char*); 
　　//使用定义的新类型来声明对象，等价于int* (*a[5])(int, char*); 
　　pFun a[5]; 
　　>2：void (*b[10]) (void (*)() ); // 此蓝色部分为个人理解，未找到原文出处 
　　//首先为上面表达式蓝色部分声明一个新类型 
　　typedef void (*pFunParam)(); 
　　//整体声明一个新类型 
　　typedef void (*pFun)(pFunParam); 
　　//使用定义的新类型来声明对象，等价于void (*b[10]) (void (*)()); 
　　pFun b[10]; 
　　>3. double(* (*pa)[9] )();  // 此蓝色部分为个人理解，未找到原文出处 
　　//首先为上面表达式蓝色部分声明一个新类型 
　　typedef double(*pFun)(); 
　　//整体声明一个新类型 
　　typedef pFun (*pFunParam)[9]; 
　　//使用定义的新类型来声明对象，等价于double(*(*pa)[9])(); 
　　pFunParam pa;


</pre>


<blockquote>
<blockquote>
<h1 id="14-13奇特的指针"><a href="#14-13奇特的指针" class="headerlink" title="14.13奇特的指针"></a>14.13奇特的指针</h1><p> |10章做过部分笔记 ，看括号优先级</p>
<ul>
<li>|:-:|<br>int board[][] |int数组的数组<br>int <em><em>ptr|指向int的指针的指针<br><font color=red>int *risks[10]|指针数组，10个元素，每个元素是一个指向int的指针<br>int(</em>rusks)[10]|数组指针，一个指针指向具有十个元素的数组<br>int</em> oof[3][4]|指针数组，二维<br>int (* uuf)[3][4]|二位数组指针<br>int(* uof[3]) [4]|具有4个元素的int数组的指针</li>
</ul>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>14.14函数指针</p>
</blockquote>
</blockquote>
<blockquote>
<p>函数具有可赋值给指针的物理内存地址，一个函数的函数名就是一个指针，它指向函数的代码。一个函数的地址是该函数的进入点，也是调用函数的地址。函数的调用可以通过函数名，也可以通过指向函数的指针来调用。函数指针还允许将函数作为变元传递给其他函数。</p>
</blockquote>
<blockquote>
<pre><code>不带括号和变量列表的函数名，这可以表示函数的地址，正如不带下标的数组名可以表示数组的首地址。</code></pre></blockquote>
<blockquote>
<p>定义形式：</p>
</blockquote>
<blockquote>
<p>类型 （*指针变量名）（参数列表）；</p>
<p>例如：<br>       int (*p)(int i,int j);</p>
</blockquote>
<pre>
<span style="font-family:KaiTi_GB2312;font-size:18px;">#include<iostream>
#include<cstdlib>
using namespace std;

int func()
{
    cout << "my name is zyh_helen" << endl;
    return 0;
}

int main()
{
    int(*p)() = func;   //函数指针初始化方式1
    int(*p1)() = &func; //函数指针初始化方式2

    func();//函数调用方式1
    (*p)();//函数调用方式2
    p();   //函数调用方式3

    system("pause");
    return 0;
}</span>

</pre>


<blockquote>
<h1 id="第16章C预处理和C库"><a href="#第16章C预处理和C库" class="headerlink" title="第16章C预处理和C库"></a>第16章C预处理和C库</h1></blockquote>
<blockquote>
<p><a href="https://www.cnblogs.com/xyqhello/p/3632198.html" target="_blank" rel="noopener">博客C预处理</a></p>
</blockquote>
<pre><code>编译程序之前，先由预处理器检查程序。根据程序中使用的预处理器指令，预处理器用符号缩略语所代表的内容
替换程序中的缩略语。

 1.编译器的处理步骤：

第一步：翻译处理：工作内容(1)把源代码中出现的字符映射到源字符集。
 (2)编译器查找反斜线后面紧跟换行符的实例并删除这些实例。将多个物理行替换为一个逻辑行。

(3)编译器将文本划分为预处理的语言符号（token）序列和空白字符及注释序列（编译器会将注释序列替换为一
个空格字符。所以注释序列可以出现在源代码的任何地方）。

第二步：预处理：   

预处理的格式：ANSI标准允许#符合前后有空格或制表符，还允许在#和指令的其余部分之间有空格。但是旧版
均不允许这些空格出现。预处理范围：预处理指令从#开始，到其后第一个换行符为止。所以预处理指令不允许换
行。所以可以使用反斜线和换行符组合使预处理指令跨越多行。
系统把宏的主体定义为语言符号（Token）类型字符串。而不是字符型字符串。Token是指由空格符隔开的单词。
“2*3”是一个Token,“2  *  3”是三个Token组成的字符串。

第三步：把源代码翻译为机器语言。第一步和第二步只是对源代码文件进行文本处理，进行字符串方面的替换。真
正的根据语义翻译为机器语言是在这步。

 2.预处理器(preprocessor)种类

预处理器可以使用反斜线和换行符组合可以横跨多个物理行，但是其最终只占用一个逻辑行。

第一部分：#define定义常量

#define ：格式：#define macro body
macro是被称为宏的缩略语，其是一个根据变量命名规则的命名的单词。
body被称为实体。可以是任何字符串。预处理器将程序中宏实例替换为实体。
#define使用参数：#define macro body 其中marco的格式类似函数.由name(args)组成。但是name和（之间不能
有空格。括号内部和body一样，可以有空格)注意在body中的参数和body都要用括号括起来。如

#define ADD(X, Y) X + Y //compiled rightly, but not safe enough
#define ADD(X, Y) ((X) + (Y)) //good #define ADD (X, Y) ((X) + (Y)) //error！ No spaces between ADD and (X, Y)</code></pre><font color=red>

<pre><code>#运算符：常量字符串中和参数相同的字符子串不会被替换为参数的
字符串形式。如果想在常量字符串中使用参数字符串，那么ANSI C允许
在body中使用#符号。如果x为参数名，那么#x就是相应的“x”。

  ##运算符：#是获取参数的字符串形式，而##是将两个Token拼接起
 来得到一个新的Token. </code></pre></font>

<pre><code> 如 #define NAME(N)   x   N  中x   N就是空格符隔开的两个token。但是如果#define NAME(N) x ## N
 就是将NAME(N)替换为xN.
总之，#用来拼接字符型字符串，##用来拼接语言符号型符号串。 可变宏：…和__VA_ARGS__
函数宏中参数列表的最后一个参数为省略号（…）。预定义宏__VA_ARGS__用在body中代表省略号代表什么。
在宏拓展中，将__VA_ARGS__替换为…位置实际上的参数。注意，省略号只能替代最后的宏参数。
总结：
1，宏的名字中macro名字部分不能有空格，但是在body替代字符串中可以使用空格。在参数列表中可以使用空格
2，在body部分，用圆括号括住每个参数，并括住宏的整体定义。</code></pre><blockquote>
<ul>
<li><a href="https://blog.csdn.net/qq_36955347/article/details/71511900" target="_blank" rel="noopener">C库</a></li>
</ul>
</blockquote>
<blockquote>
<p>16.9数学库</p>
</blockquote>
<p>   <code>|</code> |`</p>
<ul>
<li>|:-:| -:|-:|<br>int abs( int x)|求整数x的绝对值|计算结果|<br>double fabs(double x)|求双精度实数x的绝对值|计算结果<br>double acos(double x)|计算cos-1(x)的值|计算结果|x在-1～1范围内<br>double asin(double x)|计算sin-1(x)的值|计算结果|x在-1～1范围内<br>double atan(double x)|计算tan-1(x)的值|计算结果|<br>double atan2(double x)|计算tan-1(x/y)的值|计算结果<br>double cos(double x)|计算cos(x)的值|计算结果|x的单位为弧度<br>double cosh(double x)|计算双曲余弦cosh(x)的值|计算结果|<br>double exp(double x)|求ex的值|计算结果|<br>double fabs(double x)|求双精度实数x的绝对值|计算结果|<br>double floor(double x)|求不大于双精度实数x的最大整数|<br>double fmod(double x,double y)|求x/y整除后的双精度余数<br>double frexp(double val,int *<em>exp)  |把双精度val分解尾数和以2为底的指数n，即val=x</em>2n，n存放在exp所指的变量中|返回位数x|0.5≤x&lt;1|<br>double log(double x)|求㏑x|计算结果|x&gt;0<br>double log10(double x)|求log10x|计算结果|x&gt;0<br>double modf(double val,double *ip)|把双精度val分解成整数部分和小数部分，整数部分存放在ip所指的变量中|返回小数部分|<br>double pow(double x,double y)|计算xy的值|计算结果|<br>double sin(double x)|计算sin(x)的值|计算结果x的单位为弧度<br>double sinh(double x)|计算x的双曲正弦函数sinh(x)的值|计算结果<br>double sqrt(double x)|计算x的开方|计算结果|x≥0<br>double tan(double x)|计算tan(x)|计算结果<br>double tanh(double x)|计算x的双曲正切函数tanh(x)的值|计算结果 </li>
</ul>
<blockquote>
<ul>
<li>通用工具库</li>
</ul>
<p>stdlib</p>
<p>rand() srand()exit()aexit()<br>srand初始化随机种子,rand产生随机数</p>
<p><code>srand( (unsigned)time( NULL ) );</code></p>
</blockquote>
<blockquote>
<ul>
<li>qsort函数</li>
</ul>
<p>定义在头文件<algorithm>中，使用时需要include该头文件</p>
</blockquote>
<blockquote>
<p>功 能: 使用快速排序例程进行排序 　　</p>
</blockquote>
<blockquote>
<p>用 法: void qsort(void <em>base, int nelem, int width, int (</em>fcmp)(const void *,const void *)); 　</p>
<ul>
<li>16.11诊断库</li>
</ul>
<p>&lt;assert.h&gt;</p>
<p>宏asset()向标准错误流（stderr）写一条错误消息并调用abort()来终止程序</p>
<p>16.12sting.h库中的memcpy()和memmove()</p>
<blockquote>
<p>memcpy 函数用于 把资源内存（src所指向的内存区域） 拷贝到目标内存（dest所指向的内存区域）；拷贝多少个？有一个size变量控制<br>拷贝的字节数；</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>函数原型：void *memcpy(void *dest, void *src, unsigned int count);</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>用法：（1）可以拷贝任何类型的对象，因为函数的参数类型是void<em>（未定义类型指针），也就是说传进去的实参可以是int</em>，short<em>，char</em>等等，<br>但是由于函数拷贝的过程是一个字节一个字节的拷贝的，所以实际操作的时候要把void<em>强制转化为char</em>，这样在指针加的时候才会保证每次加一个字节　</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p><font color=red>src和dest所指内存区域不能重叠，函数返回指向dest的指针。</font> </p>
</blockquote>
</blockquote>
<blockquote>
<ul>
<li><a href="https://blog.csdn.net/holandstone/article/details/6947119" target="_blank" rel="noopener">16.13可变参数：stdarg.h</a></li>
</ul>
</blockquote>

    </article>
    <!-- license  -->
    
    <!-- paginator  -->
    <ul class="post-paginator">
        <li class="next">
            
        </li>
        <li class="previous">
            
                <div class="prevSlogan">Previous Post</div>
                <a href= "/blog/2020/06/13/ps/" title= "Ps">
                    <div class="prevTitle">Ps</div>
                </a>
            
        </li>
    </ul>
    <!-- 评论插件 -->
    <!-- 来必力City版安装代码 -->

<!-- City版安装代码已完成 -->
    
    
    <!-- partial('_partial/comment/changyan') -->
    <!--PC版-->


    
    
    <script src="//cdn1.lncld.net/static/js/3.0.4/av-min.js"></script>
    <script src='//unpkg.com/valine/dist/Valine.min.js'></script>
    <div id="comment"></div>
    <script>
    new Valine({
        el: '#comment' ,
        notify:false, 
        verify:false, 
        appId: "g19wRrCtJOQVUMnXrqLrDfuH-gzGzoHsz",
        appKey: "EjjgoSfgn69eAldOwhtLAlu7",
        placeholder: "",
        path:window.location.pathname, 
        avatar:'mm' ,
        visitor: true,
    });
    </script>


    <!-- 评论 -->
</main>
            <!-- profile -->
            
        </div>
        <footer class="footer footer-unloaded">
<span id="timeDate" ,></span><span id="times"></span>
<script>
    var now = new Date();
    function createtime() {
        var grt = new Date("02/01/2020 00:00:00");//此处修改你的建站时间或者网站上线时间 
        now.setTime(now.getTime() + 250);
        days = (now - grt) / 1000 / 60 / 60 / 24; dnum = Math.floor(days);
        hours = (now - grt) / 1000 / 60 / 60 - (24 * dnum); hnum = Math.floor(hours);
        if (String(hnum).length == 1) { hnum = "0" + hnum; } minutes = (now - grt) / 1000 / 60 - (24 * 60 * dnum) - (60 * hnum);
        mnum = Math.floor(minutes); if (String(mnum).length == 1) { mnum = "0" + mnum; }
        seconds = (now - grt) / 1000 - (24 * 60 * 60 * dnum) - (60 * 60 * hnum) - (60 * mnum);
        snum = Math.round(seconds); if (String(snum).length == 1) { snum = "0" + snum; }
        document.getElementById("timeDate").innerHTML = "本站已安全运行 " + dnum + " 天 ";
        document.getElementById("times").innerHTML = hnum + " 小时 " + mnum + " 分 " + snum + " 秒";
    }
    //setInterval("createtime()", 250);
</script>
</footer>
    </div>
    <!-- toc -->
    
    <div class="toc-wrapper" style=
    







top:70vh;

    >
        <div class="toc-catalog">
            <span class="iconfont-archer catalog-icon">&#xe613;</span><span>CATALOG</span>
        </div>
        <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#printf函数"><span class="toc-number">1.</span> <span class="toc-text">printf函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#scanf-函数"><span class="toc-number">2.</span> <span class="toc-text">scanf()函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第五章运算符，表达式和语句"><span class="toc-number">3.</span> <span class="toc-text">第五章运算符，表达式和语句</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第六章-C控制语句：循环"><span class="toc-number">4.</span> <span class="toc-text">第六章 C控制语句：循环</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第七章分支和跳转"><span class="toc-number">5.</span> <span class="toc-text">第七章分支和跳转</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第八章字符输入输出"><span class="toc-number">6.</span> <span class="toc-text">第八章字符输入输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第九章函数"><span class="toc-number">7.</span> <span class="toc-text">第九章函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#9-3递归p225"><span class="toc-number">8.</span> <span class="toc-text">9.3递归p225</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#指针"><span class="toc-number">9.</span> <span class="toc-text">
指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十一章字符串和字符函数"><span class="toc-number">10.</span> <span class="toc-text">第十一章字符串和字符函数</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十二章存储类，链接和内存管理"><span class="toc-number">11.</span> <span class="toc-text">第十二章存储类，链接和内存管理</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十三章文件输入输出"><span class="toc-number">12.</span> <span class="toc-text">第十三章文件输入输出</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第十四章结构和其它数据形式"><span class="toc-number">13.</span> <span class="toc-text">第十四章结构和其它数据形式</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#联合："><span class="toc-number">14.</span> <span class="toc-text">联合：</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#枚举"><span class="toc-number">15.</span> <span class="toc-text">枚举</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#typedef"><span class="toc-number">16.</span> <span class="toc-text">typedef</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#14-13奇特的指针"><span class="toc-number">17.</span> <span class="toc-text">14.13奇特的指针</span></a></li><li class="toc-item toc-level-1"><a class="toc-link" href="#第16章C预处理和C库"><span class="toc-number">18.</span> <span class="toc-text">第16章C预处理和C库</span></a></li></ol>
    </div>
    
    <div class="back-top iconfont-archer">&#xe639;</div>
    <div class="sidebar sidebar-hide">
    <ul class="sidebar-tabs sidebar-tabs-active-0">
        <li class="sidebar-tab-archives"><span class="iconfont-archer">&#xe67d;</span><span class="tab-name">目录</span></li>
        <li class="sidebar-tab-tags"><span class="iconfont-archer">&#xe61b;</span><span class="tab-name">标签</span></li>
        <li class="sidebar-tab-categories"><span class="iconfont-archer">&#xe666;</span><span class="tab-name">分类</span></li>
    </ul>
    <div class="sidebar-content sidebar-content-show-archive">
          <div class="sidebar-panel-archives">
    <!-- 在ejs中将archive按照时间排序 -->
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    <div class="total-and-search">
        <div class="total-archive">
        Total : 13
        </div>
        <!-- search  -->
        
    </div>
    
    <div class="post-archive">
    
    
    
    
    <div class="archive-year"> 2020 </div>
    <ul class="year-list">
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/01</span><a class="archive-post-title" href= "/blog/2020/02/01/hello-world/" >Hello World</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/10</span><a class="archive-post-title" href= "/blog/2020/02/10/SAMBA%E6%9C%8D%E5%8A%A1%E5%99%A8/" >Samba服务器</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/24</span><a class="archive-post-title" href= "/blog/2020/02/24/markdown%E8%AF%AD%E6%B3%95/" >Markdown语法</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/25</span><a class="archive-post-title" href= "/blog/2020/02/25/pat1030%20Dijkstra%20%E5%A0%86%E4%BC%98%E5%8C%96/" >Pat1030 Dijkstra</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">02/25</span><a class="archive-post-title" href= "/blog/2020/02/25/pat1076%20BFS/" >Pat1076 BFS</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span><a class="archive-post-title" href= "/blog/2020/06/10/test/" >PT2262解码原理</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/10</span><a class="archive-post-title" href= "/blog/2020/06/10/%E7%BA%BF%E6%80%A7%E8%A1%A8%E4%B9%A0%E9%A2%98/" >线性表习题</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/12</span><a class="archive-post-title" href= "/blog/2020/06/12/%E6%95%B0%E7%94%B5/" >数电</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/blog/2020/06/13/1/" >1</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/blog/2020/06/13/c++%E9%98%9F%E5%88%97%E5%A0%86%E6%A0%88stl/" >C++队列堆栈stl</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/blog/2020/06/13/%E5%9B%BE%E7%9A%84%E9%81%8D%E5%8E%86&%E6%9C%80%E7%9F%AD%E8%B7%AF%E5%BE%84/" >图的遍历/最短路径</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/blog/2020/06/13/ps/" >Ps</a>
        </li>
    
    
        <li class="archive-post-item">
            <span class="archive-post-date">06/13</span><a class="archive-post-title" href= "/blog/2020/06/13/c%E8%AF%AD%E8%A8%80%E5%AD%A6%E4%B9%A0/" >Hello World</a>
        </li>
    
    </div>
  </div>
        <div class="sidebar-panel-tags">
    <div class="sidebar-tags-name">
    
        <span class="sidebar-tag-name" data-tags="萌新"><span class="iconfont-archer">&#xe606;</span>萌新</span>
    
        <span class="sidebar-tag-name" data-tags="Dijkstra堆优化"><span class="iconfont-archer">&#xe606;</span>Dijkstra堆优化</span>
    
        <span class="sidebar-tag-name" data-tags="优先队列"><span class="iconfont-archer">&#xe606;</span>优先队列</span>
    
        <span class="sidebar-tag-name" data-tags="markdown"><span class="iconfont-archer">&#xe606;</span>markdown</span>
    
        <span class="sidebar-tag-name" data-tags="BFS"><span class="iconfont-archer">&#xe606;</span>BFS</span>
    
        <span class="sidebar-tag-name" data-tags="BFS如何记录层数"><span class="iconfont-archer">&#xe606;</span>BFS如何记录层数</span>
    
        <span class="sidebar-tag-name" data-tags="解码"><span class="iconfont-archer">&#xe606;</span>解码</span>
    
        <span class="sidebar-tag-name" data-tags="ps note"><span class="iconfont-archer">&#xe606;</span>ps note</span>
    
        <span class="sidebar-tag-name" data-tags="图"><span class="iconfont-archer">&#xe606;</span>图</span>
    
        <span class="sidebar-tag-name" data-tags="数据结构"><span class="iconfont-archer">&#xe606;</span>数据结构</span>
    
        <span class="sidebar-tag-name" data-tags="线性表的操作"><span class="iconfont-archer">&#xe606;</span>线性表的操作</span>
    
        <span class="sidebar-tag-name" data-tags="数电"><span class="iconfont-archer">&#xe606;</span>数电</span>
    
        <span class="sidebar-tag-name" data-tags="c base"><span class="iconfont-archer">&#xe606;</span>c base</span>
    
    </div>
    <div class="iconfont-archer sidebar-tags-empty">&#xe678;</div>
    <div class="tag-load-fail" style="display: none; color: #ccc; font-size: 0.6rem;">
    缺失模块。<br/>
    1、请确保node版本大于6.2<br/>
    2、在博客根目录（注意不是archer根目录）执行以下命令：<br/>
    <span style="color: #f75357; font-size: 1rem; line-height: 2rem;">npm i hexo-generator-json-content --save</span><br/>
    3、在根目录_config.yml里添加配置：
    <pre style="color: #787878; font-size: 0.6rem;">
jsonContent:
  meta: false
  pages: false
  posts:
    title: true
    date: true
    path: true
    text: false
    raw: false
    content: false
    slug: false
    updated: false
    comments: false
    link: false
    permalink: false
    excerpt: false
    categories: true
    tags: true</pre>
    </div> 
    <div class="sidebar-tags-list"></div>
</div>
        <div class="sidebar-panel-categories">
    <div class="sidebar-categories-name">
    
        <span class="sidebar-category-name" data-categories="网络"><span class="iconfont-archer">&#xe60a;</span>网络</span>
    
        <span class="sidebar-category-name" data-categories="pat"><span class="iconfont-archer">&#xe60a;</span>pat</span>
    
        <span class="sidebar-category-name" data-categories="basic"><span class="iconfont-archer">&#xe60a;</span>basic</span>
    
        <span class="sidebar-category-name" data-categories="单片机"><span class="iconfont-archer">&#xe60a;</span>单片机</span>
    
        <span class="sidebar-category-name" data-categories="习题"><span class="iconfont-archer">&#xe60a;</span>习题</span>
    
    </div>
    <div class="iconfont-archer sidebar-categories-empty">&#xe678;</div>
    <div class="sidebar-categories-list"></div>
</div>
    </div>
</div> 
    <script>
    var siteMeta = {
        root: "/blog/",
        author: "minhao"
    }
</script>
    <!-- CDN failover -->
    <script src="https://cdn.jsdelivr.net/npm/jquery@3.3.1/dist/jquery.min.js"></script>
    <script type="text/javascript">
        if (typeof window.$ === 'undefined')
        {
            console.warn('jquery load from jsdelivr failed, will load local script')
            document.write('<script src="/blog/,lib/jquery.min.js,">\x3C/script>')
        }
    </script>
    <script src="/blog/scripts/main.js"></script>
    <!-- algolia -->
    
    <!-- busuanzi  -->
    
    <script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
    
    <!-- CNZZ  -->
    
    </div>
    <!-- async load share.js -->
    
        <script src="/blog/scripts/share.js" async></script>    
     
    </body>
</html>


